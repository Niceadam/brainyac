<html>

<head>
  <script>
    //For competitions:
    //	countdownseconds should be 60
    //	Enter to finish should be disabled
    //  competitionMode should be true (this should show Preload button to preload competition data for the file-based events)
    const competitionMode = false;
    const competitionTestMode = false; //for testing out competition mode with training data (also set competitionMode to true) - so we need long countdown and load button, but it just gets training data
    const compName = "";
    const preloadAll = false;
    const submitScoreOption = "copy"; //this is set to "copy" if we are simply copying the score to clipboard or "none" if we are not doing submission    

    if (!competitionMode) {
      window.onerror = function (message, source, lineno, colno, error) {

        // Print the error message
        let output = "Sorry, an error occurred. Please copy this error and send to kermodekatie@gmail.com:  Error message: " + message + " // ";

        // Print the url of the file that contains the error
        output += "URL: " + source + "  //  ";

        // Print the line number from which the error generated
        output += "Line number: " + lineno + "  //  ";

        // Print the column number of the error line
        //output.innerHTML += "Column number : " + colno + "<br>";

        // Print the error object
        output += "Error object: " + error;
        alert(output);
      }
    }


    const encryptWithAES = text => {
      const passphrase = '123';
      return CryptoJS.AES.encrypt(text, passphrase).toString();
    };

    if (competitionMode) document.title = "IAM Competition";

    // const decryptWithAES = ciphertext => {
    //   const passphrase = '123';
    //   const bytes = CryptoJS.AES.decrypt(ciphertext, passphrase);
    //   const originalText = bytes.toString(CryptoJS.enc.Utf8);
    //   return originalText;
    // };

    var red = "rgba(255,128,128,0.57)";
    var orange = "rgba(255,163,102,0.57)";
    var yellow = "rgba(255,255,128,0.87)";
    var green = "rgba(179,255,102,0.57)";
    var turquoise = "rgba(62, 181, 200, 0.57)";
    var sky = "rgba(150,189,242,0.57)";
    var purple = "rgba(223,159,191,0.87)";
    var pink = "rgba(246,184,189,0.57)";

    var mainImagesLoaded = 0;
    var preloading = false;
    var resuming = false;
    var myTimer;
    var markArray = [];

    var delta = 300;
    var thisPressTime = 0;
    var lastPressTime = 0;

    var preloaded = false;
    var preloaderImages;

    var trialNo;

    let validationTimeout;

    function debounce(func, delay) {
      clearTimeout(validationTimeout);
      validationTimeout = setTimeout(func, delay);
    }

    const events = [
      {
        "ref": "5N",
        "label": "5-minute Numbers",
        "amount": 760, //WR 630, need 756 -> 760
        "memoTime": 300,
        "recallTime": 900 //15mins
      },

      {
        "ref": "15N",
        "label": "15-minute Numbers",
        "amount": 1560, //WR 1122, need 1346 -> 1360 (TEMP 1560)
        "memoTime": 900,
        "recallTime": 1800 //30 mins
      },

      {
        "ref": "30N",
        "label": "30-Minute Numbers",
        "amount": 2360, //WR 1955, need 2346 -> 2360
        "memoTime": 1800,
        "recallTime": 3600 //60 mins
      },
      {
        "ref": "60N",
        "label": "Hour Numbers",
        "amount": 3920, //WR 3238, need 3886 -> 3920
        "memoTime": 3600,
        "recallTime": 7200 //120 mins
      },
      {
        "ref": "5F",
        "label": "5-Minute Names & Faces",
        "amount": 126, //WR 105, need 126 (63 people)
        "memoTime": 300,
        "recallTime": 900 //15 mins
      },
      {
        "ref": "15F",
        "label": "15-Minute Names & Faces",
        "amount": 270, //WR 224, need 270 (268.8)
        "memoTime": 900,
        "recallTime": 1800 //30 mins
      },
      {
        "ref": "5W",
        "label": "5-Minute Words",
        "amount": 174, //WR 145, need 174 -> 180
        "memoTime": 300,
        "recallTime": 900 //15 mins
      },
      {
        "ref": "15W",
        "label": "15-Minute Words",
        "amount": 382, //WR 318, need 382 -> 400 (WMC provided 382, let's go with that)
        "memoTime": 900,
        "recallTime": 2400 //40 mins
      },

      {
        "ref": "K1",
        "label": "Spoken Numbers Attempt 1",
        "amount": 200,
        "memoTime": 0,
        "recallTime": 600 //10 mins
      },
      {
        "ref": "K2",
        "label": "Spoken Numbers Attempt 2",
        "amount": 300,
        "memoTime": 0,
        "recallTime": 900 //15 mins
      },
      {
        "ref": "K3",
        "label": "Spoken Numbers Attempt 3",
        "amount": 550,
        "memoTime": 0,
        "recallTime": 1500  //25 mins  //line 7348 sets this to 1500 anyway
      },
      {
        "ref": "D",
        "label": "5-Minute Dates",
        "amount": 178, //WR 148, need 178
        "memoTime": 300,
        "recallTime": 900 //15 mins
      },
      {
        "ref": "SC",
        "label": "Speed Cards",
        "amount": 1,
        "memoTime": 300,
        "recallTime": 300
      },
      {
        "ref": "SXC",
        "label": "Speed Cards (recall only)",
        "amount": 1,
        "memoTime": 0,
        "recallTime": 300 //5 mins
      },
      {
        "ref": "10C",
        "label": "10-Minute Cards",
        "amount": 13,	//WR 550 cards, need 13 decks
        "memoTime": 600,
        "recallTime": 1800 //30 mins
      },
      {
        "ref": "30C",
        "label": "30-Minute Cards",
        "amount": 28, //WR 1202 cards, need 1442.4 cards = 27.7.. decks, rounded up to 28
        "memoTime": 1800,
        "recallTime": 3600 //60 mins
      },
      {
        "ref": "60C",
        "label": "Hour Cards",
        "amount": 43, //WR 1829 cards, need 2194.8 cards = 42.2 decks, rounded up to 43
        "memoTime": 3600,
        "recallTime": 7200 //120 mins
      },
      {
        "ref": "5I",
        "label": "5-Minute Images",
        "amount": 785, //WR 653, need 783.6 -> 785
        "memoTime": 300,
        "recallTime": 1200 //20 mins as of March 2022 (was 15 mins)
      },
      {
        "ref": "5B",
        "label": "5-Minute Binary",
        "amount": 1530,	//WR 1251, need 1501 -> 1530
        "memoTime": 300,
        "recallTime": 900 //15 mins
      },
      {
        "ref": "30B",
        "label": "30-Minute Binary",
        "amount": 7530, //WR 6270, need 7524 -> 7530
        "memoTime": 1800,
        "recallTime": 3600 //60 mins
      },
      {
        "ref": "TN",
        "label": "Numbers (Free)",
        "amount": 100,
        "memoTime": 60,
        "recallTime": 120

      },
      {
        "ref": "TC",
        "label": "Cards (Free)",
        "amount": 2,
        "memoTime": 60,
        "recallTime": 120
      },
      {
        "ref": "TF",
        "label": "Names & Faces (Free)",
        "amount": 20,
        "memoTime": 60,
        "recallTime": 120
      },
      {
        "ref": "TW",
        "label": "Words (Free)",
        "amount": 20,
        "memoTime": 60,
        "recallTime": 120
      },
      {
        "ref": "TI",
        "label": "Images (Free)",
        "amount": 100,
        "memoTime": 60,
        "recallTime": 120
      },
      {
        "ref": "TB",
        "label": "Binary (Free)",
        "amount": 300,
        "memoTime": 60,
        "recallTime": 120
      },
      {
        "ref": "TD",
        "label": "Dates (Free)",
        "amount": 30,
        "memoTime": 60,
        "recallTime": 120
      },
      {
        "ref": "TXC",
        "label": "Cards recall (Free)",
        "amount": 2,
        "memoTime": 0,
        "recallTime": 120
      }
    ];

    //const nationalEvents = ["5N","15N","5F","5W","D","SC","10C","5I","S","5B"];
    const nationalEvents = ["5N", "15N", "5F", "5W", "D", "SC", "SXC", "10C", "5I", "5B"];

    //const internationalEvents = ["5N","30N","15F","15W","D","SC","30C","5I","S","30B"];
    const internationalEvents = ["5N", "30N", "15F", "15W", "D", "SC", "SXC", "30C", "5I", "30B"];

    //const worldEvents = ["5N","60N","15F","15W","D","SC","60C","5I","S","30B"];
    const worldEvents = ["5N", "60N", "15F", "15W", "D", "SC", "SXC", "60C", "5I", "30B"];

    //const freeEvents = ["N","F","W","D","C","I","B"];

    const suitInitialList = new Array("s", "c", "h", "d");
    const faceList = new Array("J", "Q", "K");
    const nonfaceList = new Array("A", "2", "3", "4", "5", "6", "7", "8", "9", "10");

    const numbersPerPage = 480;
    const binaryPerPage = 360;
    const numbersPerRow = 40;
    const binaryPerRow = 30;
    const imagesPerPage = 25;
    const wordColumnsPerPage = 5;
    const wordsPerColumn = 20;

    const numberOfTrainingFemalesOval = 99;
    const numberOfTrainingMalesOval = 100;
    const numberOfTrainingFemalesSquare = 363;
    const numberOfTrainingMalesSquare = 365;

    var wordsPerPage;

    const nameRowsPerPage = 3;
    const namesPerRow = 3;
    var namesPerPage;

    //Change to 60 for real
    const countdownSeconds = competitionMode ? 60 : 5;
    const countdownRecallSeconds = competitionMode ? 0 : 5;


    const cardOffset = 9;
    var cardOffsetBig = 22;
    //const cardOffsetBig = 42;

    const numberOfJpgs = 466;
    const numberOfPngs = 5894;

    var scoreInfo = "";


    const cardAttributions = ["[Standard cards: Copyright 2015 Chris Aguilar conjurenation@gmail.com, Licensed under <a href='www.gnu.org/copyleft/lesser.html'>LGPL 3</a>]", "[French cards: David Bellot — <a href='http://svg-cards.sourceforge.net/'>http://svg-cards.sourceforge.net</a>, <a href='http://www.gnu.org/licenses/lgpl.html' title='GNU Lesser General Public License'>LGPL</a>]", "['Worn' cards: Copyright 2015 Chris Aguilar conjurenation@gmail.com, Licensed under <a href='www.gnu.org/copyleft/lesser.html'>LGPL 3</a>]"];
    //"[French cards: David Bellot — <a href='http://svg-cards.sourceforge.net/'>http://svg-cards.sourceforge.net</a>, <a href='http://www.gnu.org/licenses/lgpl.html' title='GNU Lesser General Public License'>LGPL</a>]"


    var skin = "";

    var intermediate = false;

    var currentDiscipline = "";
    var memoTime = "";
    var recallTime = "";
    var amount = 0;
    var grouping;
    var groupingH;
    var groupingW;
    var navGroupingsBin = [];
    var miniGroupings = [];
    var miniGroupStarts = [];
    var locusStarts = [];
    var imgsPerLocus = 1;
    var separations = [];
    var separationPointsBin = [];
    var hiColour;

    var countSeconds;
    var cint;

    var numberOfPages;
    var numberList;
    var binaryList;
    var binLevels;
    var curPos;
    var curMiniGroup;
    var curLocus;
    var curPage;
    var memoTimeTaken;
    var recallTimeTaken;
    var chosenAnswers = [];
    var cardList;
    var boneyardArray = [];
    var displayed;

    var memoTimeNeeded;

    var cardSet;
    var showingBlank = false;

    let imageArray = [];
    var actualImageArray = new Array();
    var actualImages = new Array();
    var answerArray = [];
    var usedImageNums = [];
    var blnImageSkip;
    var blnFocusBox;
    var blnHighlightOn;
    var imagesLoaded;

    var fontNow = '';
    var fontSizeNow = 0;
    //var fontReenieBeanie = ['Reenie Beanie', 38, 42];
    //var fontShadowsIntoLight = ['Shadows Into Light', 24, 26];
    var fontReenieBeanie = ['Reenie Beanie', 34, 41];
    var fontShadowsIntoLight = ['Reenie Beanie', 36, 42];
    //var fontRockSalt = ['Rock Salt', 19, 21];

    var datesLanguage;

    //Words
    //XML variables
    var fobWordsDoc;

    var wordList;
    //word ratios
    const percOfCNs = 80;
    const percOfANs = 10;
    const percOfVs = 10;

    var wordsLanguage;
    var wordsLanguagesPreloaded = false;

    //Dates
    var fobDatesDoc;
    var dateList;
    var shuffledDateList;
    const datesPerPage = 20;
    var datesLanguagesPreloaded = false;

    //Names
    var fobNamesDoc;
    var femaleImageArray = new Array();
    var maleImageArray = new Array();
    var genders;
    var curPos = 0;
    var curPage = 0;

    var namesCharset = 'Latin';
    var namesCharsetsPreloaded = false;
    var names = [];
    var newNames = [];
    var currentSurnames;
    var accentMap = {
      'Á': 'A', 'á': 'a', 'à': 'a', 'ä': 'a', 'ā': 'a', 'â': 'a', 'ã': 'a', 'å': 'a', 'æ': 'ae', 'ă': 'a',
      'Ç': 'C', 'ç': 'c', 'č': 'c', 'ć': 'c',
      'é': 'e', 'è': 'e', 'ë': 'e', 'ê': 'e', 'ė': 'e', 'ě': 'e',
      'ğ': 'g',
      'Í': 'i', 'í': 'i', 'ı': 'i', 'ï': 'i', 'î': 'i',
      'ł': 'l',
      'ñ': 'n', 'ń': 'n', 'ň': 'n',
      'Ö': 'O', 'ó': 'o', 'ō': 'o', 'ö': 'o', 'ô': 'o', 'õ': 'o', 'ø': 'o', 'œ': 'oe', 'ő': 'o', 'ò': 'o',
      'ŕ': 'r',
      'ş': 's', 'š': 's', 'ś': 's',
      'ț': 't',
      'Þ': 'Th',
      'þ': 'th',
      'ú': 'u', 'ù': 'u', 'ü': 'u', 'ū': 'u', 'û': 'u', 'ű': 'u',
      'ý': 'y',
      'ž': 'z', 'ż': 'z', 'ź': 'z',
      'آ': 'ا', 'أ': 'ا', 'إ': 'ا'
    };

    var wordsMap = {

      'آ': 'ا', 'أ': 'ا', 'إ': 'ا'
    };

    var trainingWordsMap = {

      'آ': 'ا', 'أ': 'ا', 'إ': 'ا',
      //NOT FOR COMPS - arbiting by hand is preferred
      'ي': 'ى',
      'ة': 'ه'
    };

    var nameList = [];
    var facesAmount;

    var shuffledNameList = [];

    var ended;

    var competitionPreloadingRequired;

    const getCurrentDisciplineType = () => {
      if (currentDiscipline.indexOf("K") > -1) return "K";
      return currentDiscipline[currentDiscipline.length - 1];
    }

    function changeDisciplines() {
      //remove all options from the box
      $("#selDiscipline option").remove();

      //get format
      var thisFormat = document.getElementById("selFormat").options[document.getElementById("selFormat").selectedIndex].value;
      var thisArray;
      switch (thisFormat) {
        case "N":
          thisArray = nationalEvents;

          break;

        case "I":

          thisArray = internationalEvents;
          break;

        default:

          thisArray = worldEvents;
      }

      //add all events in that format to the box

      if (thisFormat == "T") {
        $("#selDiscipline").append("<option value='TN'>Numbers</option>");
        $("#selDiscipline").append("<option value='TF'>Names & Faces</option>");
        $("#selDiscipline").append("<option value='TW'>Words</option>");
        $("#selDiscipline").append("<option value='TD'>Dates</option>");
        $("#selDiscipline").append("<option value='TC'>Cards</option>");
        $("#selDiscipline").append("<option value='TXC'>Cards recall only</option>");
        $("#selDiscipline").append("<option value='TI'>Images</option>");
        $("#selDiscipline").append("<option value='TB'>Binary</option>");


      } else {
        for (j = 0; j < events.length; j++) {
          if (thisArray.indexOf(events[j].ref) > -1) {

            $("#selDiscipline").append("<option value='" + events[j].ref + "'>" + events[j].label + "</option>");

          }
        }
      }

      //add spoken numbers option for recall only, in competition mode (but not in free training mode)
      if (competitionMode && thisFormat != "T") {
        $("#selDiscipline").append("<option value='K1'>Spoken Numbers Attempt 1 (recall only)</option>");
        $("#selDiscipline").append("<option value='K2'>Spoken Numbers Attempt 2 (recall only)</option>");
        $("#selDiscipline").append("<option value='K3'>Spoken Numbers Attempt 3 (recall only)</option>");

      }

      //set the discipline according to what was previously selected
      const selectedDiscipline = localStorage.getItem("discipline");
      const disciplineSelect = document.querySelector(`select[id="selDiscipline"]`);
      const isDisciplineInDropdown = Array.from(disciplineSelect.options).some(
        option => option.value === selectedDiscipline
      );
      disciplineSelect.value = isDisciplineInDropdown ? selectedDiscipline : '5N';

      localStorage.setItem("format", thisFormat);
    }

    function preloadData() {
      //If competition mode, this is called when the user clicks Preload data button
      //If in training mode (or comp mode when not preloading all and not doing numbers, cards or binary):
      //    this is called when the user clicks Start (for images, when they go to settings page)


      if (competitionPreloadingRequired) {
        document.getElementById("btnPreload").innerText = "Loading...";
      } else {
        document.getElementById("btnStartMemoCountdown").innerText = "Loading...";

        document.getElementById('btnStartMemoCountdown').setAttribute('disabled', "");
      }


      //For dates or words, get the chosen language		
      if (currentDiscipline.indexOf("D") > -1) {
        datesLanguage = document.getElementById("selDatesLanguage").options[document.getElementById("selDatesLanguage").selectedIndex].value;
        //save it
        localStorage.setItem("datesLanguage", datesLanguage);
      }
      if (currentDiscipline.indexOf("W") > -1) {
        wordsLanguage = document.getElementById("selWordsLanguage").options[document.getElementById("selWordsLanguage").selectedIndex].value;
        //save it
        localStorage.setItem("wordsLanguage", wordsLanguage);
      }

      //For names, get the chosen charset
      /*if (currentDiscipline.indexOf("F") > -1 && competitionMode) {
          namesCharset = document.getElementById("selNamesCharset").options[document.getElementById("selNamesCharset").selectedIndex].value;
      }*/
      if (currentDiscipline.indexOf("F") > -1) {
        namesCharset = document.getElementById("selNamesCharset").options[document.getElementById("selNamesCharset").selectedIndex].value;
        localStorage.setItem("namesCharset", namesCharset);
      }

      //preload other stuff
      switch (currentDiscipline) {

        case "10C":
        case "30C":
        case "60C":
        case "SC":
        case "SXC":
        case "TXC":
        case "TC":
          //If competition preloading required, preload the card data
          if (competitionPreloadingRequired && currentDiscipline.indexOf("XC") == -1) preloadCardData();
          //Always preload the images
          preloadCardImages();

          break;
        case "D":
        case "TD":
          readDatesFile(datesLanguage);
          if (!competitionMode) startMemoCountdown();
          break;
        case "5F":
        case "15F":
        case "TF":
          if (competitionMode && !competitionTestMode) {
            readNamesFile(namesCharset);
          } else {
            preloadNames();
            //startMemoCountdown();
          }
          break;
        case "5W":
        case "15W":
        case "TW":
          readWordsFile(wordsLanguage);
          if (!competitionMode) startMemoCountdown();
          break;
        case "TI":
        case "5I":
          preloadImages(false);
          break;
        case "5N":
        case "15N":
        case "30N":
        case "60N":
        case "5B":
        case "30B":
        case "K1":
        case "K2":
        case "K3":
          if (competitionPreloadingRequired && !competitionTestMode) {
            preloadDigits();
          } else if (competitionTestMode) {
            document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
            document.getElementById("btnStartMemoCountdown").innerText = "Start";

            document.getElementById("btnPreload").innerText = "Preload data";

            localStorage.setItem("preloadedData", JSON.stringify(numberList));
            preloaded = true;

          }
          break;
        default:
          startMemoCountdown();
      }


    }

    function goToSelection() {
      preloaded = false;
      intermediate = false;

      //reset any timers that are running
      if (myTimer) clearTimeout(myTimer);

      //check if user's browser has localStorage facilities
      if (typeof (Storage) == "undefined") {
        // No localStorage support
        alert("Sorry, your browser does not meet the technical specifications. It is recommended that you use the latest version of Chrome or Firefox.")
      }

      //PRELOAD IMAGES SECTION

      //Change the text of the Go button to a loading text
      document.getElementById("btnGo").innerText = "Loading images... Please wait";

      //Reset the number of images loaded - we need to load all the backgrounds before we go to the settings page
      mainImagesLoaded = 0;
      //**PAPER**
      //	var mainImageURLs = ['hugeWoodMatchPlanks2.png', 'IAMarble2.jpg', 'felt2.png', 'hugeWoodPaperAMatch.jpg'];

      document.getElementById("btnGo").removeAttribute("disabled");
      if (localStorage.getItem("phase")) document.getElementById("btnResume").style.visibility = "visible";
      document.getElementById("btnGo").innerText = "Go";

      /*
      //Do the preloading if we 
              if (mainImagesLoaded == 0) {
                  mainImageURLs.forEach(function (el) {
                      var bg = new Image();
                      bg.src = el;
                      bg.onload = function () {
                          console.log(++mainImagesLoaded);
                          if (mainImagesLoaded == mainImageURLs.length) {
      
                              document.getElementById("btnGo").removeAttribute("disabled");
                              if (localStorage.getItem("phase")) document.getElementById("btnResume").style.visibility = "visible";
                              document.getElementById("btnGo").innerText = "Go";
      
                          }
                      };
                  })
              }
      */
      preloading = false;

      if (!datesLanguagesPreloaded) {
        preloadDatesLanguages();
      }
      if (!namesCharsetsPreloaded && competitionMode && !competitionTestMode) {
        preloadNamesCharsets();
      }

      if (!wordsLanguagesPreloaded) {
        preloadWordsLanguages();
      }
      document.body.className = "selectionSkin";
      document.getElementById("selectionRow").style = "display:block";
      document.getElementById("logoRow").style = "display:block";

      document.getElementById("topMargin").style = "display:none";
      document.getElementById("settingsRow0").style = "display:none";
      document.getElementById("countdownRow").style = "display:none";
      document.getElementById("countdownText").innerHTML = "";
      document.getElementById("countdownTime").innerHTML = "";
      document.getElementById("memoRow").style = "display:none";
      document.getElementById("memoBox").classList.remove(skin + "memoHeightDates");
      document.getElementById("memoBox").classList.add(skin + "memoHeight");
      document.getElementById("recallBox").classList.remove(skin + "memoHeightDates");
      document.getElementById("recallBox").classList.add(skin + "memoHeight");
      document.getElementById("scoreBox").classList.remove(skin + "memoHeightDates");
      document.getElementById("scoreBox").classList.add(skin + "memoHeight");
      document.getElementById("recallRow").style = "display:none";
      document.getElementById("recallContentDiv").style = "display:block";
      document.getElementById("analogueCardsRecallContentDiv").style = "display:block";
      document.getElementById("finishBtnDiv").style.display = "block";
      //document.getElementById("spanShift").style="display:block";
      document.getElementById("cardsMemoTime").innerText = "";
      document.getElementById("cardsMemoTimeScore").innerText = "";
      document.getElementById("scoreRow").style = "display:none";
      document.getElementById("btnBackToSelection").style = "display:none";
      document.getElementById("btnSubmitScore").style = "display:none";
      document.getElementById("memoContentDiv").innerHTML = "";
      document.getElementById("analogueCardsMemoContentDiv").innerHTML = "";
      //document.getElementById("recallContentDiv").innerHTML = "";
      //document.getElementById("scoreContentDiv").innerHTML = "";

      //clear vignette
      //$('#hiddenDiv').fadeOut(1500);
      //$('#darkenVignette').fadeOut(1500);
      document.getElementById("hiddenDiv").style.opacity = 0;
      document.getElementById("darkenVignette").style.opacity = 0;

      changeDisciplines();
      clearInterval(cint);
      ended = true;
      currentDiscipline = "";
      miniGroupings = [];
      chosenAnswers = [];

      //changeSkin();

      //reset so no card table background appears
      if (skin.indexOf("analogue") > -1) {
        $("#memoBox").addClass("analogue1boxA");
        $("#memoBox").removeClass("analogue1boxGreen");
        $("#recallBox").addClass("analogue1boxB");
        $("#recallBox").removeClass("analogue1boxGreen");

        $("#scoreBox").addClass("analogue1boxB");
        $("#scoreBox").removeClass("analogue1boxGreen");
      }

    }

    function getSkin() {
      // skin = document.getElementById("selSkin").options[document.getElementById("selSkin").selectedIndex].value;
      var skinOptions = document.getElementsByName('selSkin');
      if (skinOptions[0].checked) {
        return skinOptions[0].value;
      } else {
        return skinOptions[1].value;
      }

    }

    function determineIfPreloadingRequired() {
      //Work out if we need to preload
      if (competitionMode && preloadAll) {
        competitionPreloadingRequired = true;
      } else if (competitionMode && !competitionTestMode) {
        //2020, took out Cards because we don't need to preload Cards (data) if not preloading all
        if (currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("K") > -1 || currentDiscipline.indexOf("F") > -1 || currentDiscipline.indexOf("D") > -1 || currentDiscipline.indexOf("I") > -1) {
          competitionPreloadingRequired = true;
        } else {
          competitionPreloadingRequired = false;
        }
      } else {
        competitionPreloadingRequired = false;
      }

    }

    function goToSettings(returningFromTest = false) {

      amount = 0;
      resuming = false;
      document.getElementById("btnStartMemoCountdown").innerText = "Start";
      document.getElementById("btnPreload").innerText = "Preload data";
      document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
      document.getElementById("cardAttribution").innerHTML = "";

      //Get discipline and determine if it's one that needs preloading for a competition
      currentDiscipline = document.getElementById("selDiscipline").options[document.getElementById("selDiscipline").selectedIndex].value;
      localStorage.setItem("discipline", currentDiscipline);
      determineIfPreloadingRequired();

      //clear vignette
      document.getElementById("hiddenDiv").style.opacity = 0;
      document.getElementById("darkenVignette").style.opacity = 0;


      //Reset mark array
      markArray = [];
      localStorage.removeItem("markArray");

      //Get skin
      skin = getSkin();

      //Get highlight colour if exists
      hiColour = localStorage.getItem("hiColour") || "green";

      //reset other variables
      memoTimeNeeded = false;




      //green box for cards
      if (skin.indexOf("analogue") > -1 && currentDiscipline.indexOf("C") > -1) {
        $("#settingsBox").addClass("analogue1boxGreen");
        $("#settingsBox").removeClass("analogue1boxA");
      }


      //remove logo row if skin is analogue

      if (skin.indexOf("analogue") > -1) {
        document.getElementById("logoRow").style = "display:none";
        document.getElementById("topMargin").style = "display:block";
        document.getElementById("btnBackToSelection2").style = "display:inline";

      } else {
        document.getElementById("logoRow").style = "display:block";
        document.getElementById("topMargin").style = "display:none";
        document.getElementById("btnBackToSelection2").style = "display:none";


        if (currentDiscipline.indexOf("C") > -1) {
          document.getElementById("settingsBox").classList.remove(skin + "memoHeight");

        }

      }


      // clear content from test page if exists
      document.getElementById("memoContentDiv").innerHTML = "";
      document.getElementById("analogueCardsMemoContentDiv").innerHTML = "";

      //Display correct elements
      document.getElementById("selectionRow").style = "display:none";
      document.getElementById("settingsRow0").style = "display:block";
      document.getElementById("countdownRow").style = "display:none";
      document.getElementById("countdownText").innerHTML = "";
      document.getElementById("countdownTime").innerHTML = "";
      document.getElementById("memoRow").style = "display:none";
      document.getElementById("recallRow").style = "display:none";
      document.getElementById("scoreRow").style = "display:none";
      document.getElementById("btnBackToSelection").style = "display:block";


      var titleElements = document.getElementsByClassName("disciplineTitle");
      var title = lookupProperty(currentDiscipline, "label");
      for (var i = 0; i < titleElements.length; i++) {
        titleElements[i].innerHTML = title;
      }


      titleElements = document.getElementsByClassName("disciplineTitleMemo");
      title = lookupProperty(currentDiscipline, "label");
      for (var i = 0; i < titleElements.length; i++) {
        titleElements[i].innerHTML = title;
      }


      //Show focus box dropdown if necessary
      if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("B") > -1 || currentDiscipline.indexOf("W") > -1) {
        document.getElementById("divFocusBox").style = "display:block";
        if (localStorage.getItem("blnFocusBox" + (getCurrentDisciplineType())) === 'true') {
          document.getElementById("chkFocusBox").checked = true;
        } else document.getElementById("chkFocusBox").checked = false;
        if (localStorage.getItem("blnHighlightOn" + (getCurrentDisciplineType())) === 'true') {
          document.getElementById("chkHighlightOn").checked = true;
        } else document.getElementById("chkHighlightOn").checked = false;
      } else {
        document.getElementById("divFocusBox").style = "display:none";
      }

      //Get image skip preference
      if (currentDiscipline.indexOf("I") > -1 && localStorage.getItem("blnImageSkip") === 'true') document.getElementById("chkSkipFinalImage").checked = true;


      //Show Grouping dropdown if necessary
      if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1 || currentDiscipline.indexOf("K") > -1) {
        document.getElementById("divGrouping").style = "display:block";
        if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("K") > -1) {
          document.getElementById("selGrouping").style = "display:none";
        } else {
          document.getElementById("selGrouping").style = "display:inline-block";
          //make sure correct option is selected
          //document.getElementById("selGrouping").options.forEach(el => if (el == localStorage.getItem("grouping" + currentDiscipline)) el.selected = true);
          //document.getElementById("selGrouping").options.forEach(el => if (el == "2") el.selected = true);
          $('#selGrouping>option').filter(function () {
            return ($(this).text() == localStorage.getItem("grouping" + currentDiscipline));
          }).prop('selected', true);


        }

      }
      else {
        document.getElementById("divGrouping").style = "display:none";
      }


      //Show complex grouping dropdown if necessary; get and apply separations
      if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("K") > -1) {
        document.getElementById("divComplexGrouping").style = "display:block";

        if (localStorage.getItem("miniGroupings") != "" && localStorage.getItem("miniGroupings") != "[null]" && localStorage.getItem("miniGroupings") != null && localStorage.getItem("miniGroupings").length > 0) {
          miniGroupings = JSON.parse(localStorage.getItem("miniGroupings"));
          document.getElementById("inpMiniGroupings").value = miniGroupings.reduce((acc, val, idx) => {
            if (idx === 0) {
              acc = val.toString() + '-';
            }
            if (idx <= miniGroupings.length - 2) {
              return acc + (miniGroupings[idx + 1]).toString() + '-';
            } else {
              return acc.slice(0, acc.length - 1);
            }
          }, '');
        } else {
          miniGroupings = [3];
          document.getElementById("inpMiniGroupings").value = "3";
        }

        if (localStorage.getItem("separations") != "" && localStorage.getItem("separations") != null) {
          arr = JSON.parse(localStorage.getItem("separations"));
        } else {
          arr = [];
        }

        if (arr.length && arr[0] != null) {
          document.getElementById("inpSeparation").value = arr.reduce((acc, val, idx) => {
            if (idx === 0) {
              acc = val.toString() + '-';
            }
            if (idx <= arr.length - 2) {
              return acc + (Math.abs(val - arr[idx + 1])).toString() + '-';
            } else {
              return acc.slice(0, acc.length - 1);
            }
          }, '');
        } else {
          document.getElementById("inpSeparation").value = "";
        }
        if (document.getElementById("inpSeparation").value == "0") document.getElementById("inpSeparation").value = "";
        applySeparation();

        //apply mini groupings otherwise "grouping" isn't updated until the selection is changed on grouping for nav.
        //however, "grouping" didn't seem to affect anything until score page
        applyMiniGroupings();
      }
      else {
        document.getElementById("divComplexGrouping").style = "display:none";
      }

      //Show Binary Grouping dropdown if necessary; get and apply separations
      if (currentDiscipline.indexOf("B") > -1) {
        document.getElementById("divBinGrouping").style = "display:block";

        //get width and height from storage (NEW 2023)
        navGroupingsBin = JSON.parse(localStorage.getItem("navGroupingsBin"));
        console.log("1055 " + navGroupingsBin);
        if (!navGroupingsBin || !navGroupingsBin.length) {
          //default values
          navGroupingsBin = [3];
          localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
        }
        document.getElementById("inpNavGroupingsBin").value = navGroupingsBin.join("-")

        if (localStorage.getItem("groupingH") !== "" && localStorage.getItem("groupingH") != null) {
          $('#selBinGroupingH>option').filter(function () {
            return ($(this).text() == localStorage.getItem("groupingH"));
          }).prop('selected', true);
        }

        //get separations from storage
        separations = JSON.parse(localStorage.getItem("separationsBin"));
        if (!separations || !separations.length) {
          separations = [];
          localStorage.setItem("separationsBin", JSON.stringify(separations));
        }

        if (separations.length) {
          document.getElementById("inpSeparationBin").value = separations.join("-")
        } else {
          document.getElementById("inpSeparationBin").value = "";
        }

        // if (arr.length && arr[0] != null) {
        //     document.getElementById("inpSeparationBin").value = arr.reduce((acc, val, idx) => {
        //         if (idx === 0) {
        //             acc = val.toString() + '-';
        //         }
        //         if (idx <= arr.length - 2) {
        //             return acc + (Math.abs(val - arr[idx + 1])).toString() + '-';
        //         } else {
        //             return acc.slice(0, acc.length - 1);
        //         }
        //     }, '');
        // } else {
        //     document.getElementById("inpSeparationBin").value = "";
        // }
        // if (document.getElementById("inpSeparationBin").value == "0") document.getElementById("inpSeparationBin").value = "";

        applySeparationBin();
      }
      else {
        document.getElementById("divBinGrouping").style = "display:none";
      }

      //Show Colour dropdown if necessary
      if (currentDiscipline.indexOf("C") > -1) {
        document.getElementById("divHighlightColour").style = "display:none";
      }
      else {
        document.getElementById("divHighlightColour").style = "display:block";
      }

      //Show Trial dropdown if necessary
      if ((currentDiscipline === "5N" || currentDiscipline === 'SC') && competitionMode) {
        document.getElementById("divTrial").style = "display:block";
      }
      else {
        document.getElementById("divTrial").style = "display:none";
      }

      //Show Languages dropdown if necessary
      if (currentDiscipline.indexOf("D") > -1) {
        document.getElementById("divDatesLanguages").style = "display:block";
        $('#selDatesLanguage>option').filter(function () {
          return ($(this).text() == localStorage.getItem("datesLanguage"));
        }).prop('selected', true);
      }
      else {
        document.getElementById("divDatesLanguages").style = "display:none";
      }


      if (currentDiscipline.indexOf("W") > -1) {
        document.getElementById("divWordsLanguages").style = "display:block";
        $('#selWordsLanguage>option').filter(function () {
          return ($(this).text() == localStorage.getItem("wordsLanguage"));
        }).prop('selected', true);
      }
      else {
        document.getElementById("divWordsLanguages").style = "display:none";
      }

      /*
              if (currentDiscipline.indexOf("F") > -1 && competitionMode) {
                  document.getElementById("divNamesCharsets").style = "display:block";
              }
              else {
                  document.getElementById("divNamesCharsets").style = "display:none";
              }
      */

      if (currentDiscipline.indexOf("F") > -1) {
        document.getElementById("divNamesCharsets").style = "display:block";
        $('#selNamesCharset>option').filter(function () {
          return ($(this).text() == localStorage.getItem("namesCharset"));
        }).prop('selected', true);
        $('#selFacesFormat>option').filter(function () {
          return ($(this).text().toLowerCase() == localStorage.getItem("facesFormat"));
        }).prop('selected', true);
        if (competitionMode) {
          document.getElementById("divFacesFormat").style = "display:none";
        } else {
          document.getElementById("divFacesFormat").style = "display:block";
        }
      }
      else {
        document.getElementById("divNamesCharsets").style = "display:none";
      }


      //Show free training settings if necessary
      if (currentDiscipline.indexOf("T") > -1) {
        document.getElementById("divFree").style.display = "block";
        document.getElementById("amountText").innerText = (currentDiscipline.indexOf("C") > -1) ? "Decks:" : "Amount:";

        //set free training settings
        if (localStorage.getItem("amount" + currentDiscipline)) {
          document.getElementById("inpAmount").value = localStorage.getItem("amount" + currentDiscipline);
        } else {
          document.getElementById("inpAmount").value = lookupProperty(currentDiscipline, "amount");
          localStorage.setItem("amount" + currentDiscipline, validateAmount(document.getElementById("inpAmount").value));
        }
        if (localStorage.getItem("memoTime" + currentDiscipline)) {
          document.getElementById("inpMemoMins").value = Math.floor(localStorage.getItem("memoTime" + currentDiscipline) / 60);
          document.getElementById("inpMemoSecs").value = Math.floor(localStorage.getItem("memoTime" + currentDiscipline) % 60);
        } else {
          document.getElementById("inpMemoMins").value = Math.floor(lookupProperty(currentDiscipline, "memoTime") / 60);
          document.getElementById("inpMemoSecs").value = Math.floor(lookupProperty(currentDiscipline, "memoTime") % 60);
          localStorage.setItem("memoTime" + currentDiscipline, document.getElementById("inpMemoMins").value * 60 + document.getElementById("inpMemoSecs").value);
        }
        if (localStorage.getItem("recallTime" + currentDiscipline)) {
          document.getElementById("inpRecallMins").value = Math.floor(localStorage.getItem("recallTime" + currentDiscipline) / 60);
          document.getElementById("inpRecallSecs").value = Math.floor(localStorage.getItem("recallTime" + currentDiscipline) % 60);
        } else {
          document.getElementById("inpRecallMins").value = Math.floor(lookupProperty(currentDiscipline, "recallTime") / 60);
          document.getElementById("inpRecallSecs").value = Math.floor(lookupProperty(currentDiscipline, "recallTime") % 60);
          localStorage.setItem("recallTime" + currentDiscipline, document.getElementById("inpRecallMins").value * 60 + document.getElementById("inpRecallSecs").value);
        }
      } else {
        document.getElementById("divFree").style.display = "none";
      }


      //Preload data for images if not in competition mode (new July 2019)
      if ((!competitionMode) && currentDiscipline.indexOf("I") > -1 && !returningFromTest && !preloaded) preloadData();




      //Show preview if necessary
      if (currentDiscipline.indexOf("I") > -1 || currentDiscipline.indexOf("K") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("F") > -1 || currentDiscipline.indexOf("D") > -1) {
        document.getElementById("divPreview").style = "display:none";
        if (currentDiscipline.indexOf("W") > -1) {
          document.getElementById("divInstructions").innerHTML = "<table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&uarr; &darr; &larr; &rarr;</td><td>navigate</td></tr><tr><td>shift-tab / tab</td><td>previous/next cell</td></tr><tr><td>spacebar</td><td>return to start</td></tr><tr><td>, / .</td><td>previous/next page</td></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"
        } else {
          document.getElementById("divInstructions").innerHTML = "<table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&uarr; &darr; &larr; &rarr;</td><td>navigate</td></tr><tr><td>shift-tab / tab</td><td>previous/next cell</td></tr><tr><td>spacebar</td><td>return to start</td></tr><tr><td>, / .</td><td>previous/next page</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"
        }
      } else {
        document.getElementById("divPreview").style = "display:block";
        if (currentDiscipline.indexOf("C") > -1) {
          if (currentDiscipline.indexOf("SC") > -1) {
            //document.getElementById("divInstructions").innerHTML = "<h4>During memorisation:</h4>Spacebar...........return to start<br /><br />"
            document.getElementById("divInstructions").innerHTML = "<div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&larr; &rarr;</td><td>navigate</td></tr><tr><td>spacebar / &uarr;</td><td>return to start of deck</td></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>Backspace</td><td>delete card in previous cell</td></tr></table></div><div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>Del</td><td>delete card in current cell</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr><tr><td>Enter</td><td>end memorisation</td></tr></table><br />"
          } else {
            document.getElementById("divInstructions").innerHTML = "<div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&larr; &rarr;</td><td>navigate</td></tr><tr><td>spacebar</td><td>return to start of first deck</td></tr><tr><td>&uarr;</td><td>return to start of deck</td></tr><tr><td>, / .</td><td>previous/next deck</td></tr></table></div><div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>Backspace</td><td>delete card in previous cell</td></tr><tr><td>Del</td><td>delete card in current cell</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"
          }
        } else {
          //document.getElementById("divInstructions").innerHTML = "<h3>During memorisation:</h3>Spacebar...........return to start<br />Comma/period..........previous/next page<br /><br />"
          document.getElementById("divInstructions").innerHTML = "<table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&uarr; &darr; &larr; &rarr;</td><td>navigate</td></tr><tr><td>shift-tab / tab</td><td>previous/next cell</td></tr><tr><td>spacebar</td><td>return to start</td></tr><tr><td>, / .</td><td>previous/next page</td></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"

        }
      }
      //resetSeparations();



      //changeSkin();
      //	changeSelHColour();


      //Show highlighter colour if necessary ***

      //Show Decks input if necessary
      if (currentDiscipline.indexOf("C") > -1) {
        if (currentDiscipline != "SC" && currentDiscipline != "TC") {
          document.getElementById("divDecks").style = "display:inline-block";
          //	if (document.getElementById("inpDecks").value == "") {
          if (localStorage.getItem("decks" + currentDiscipline) == "" || !(localStorage.getItem("decks" + currentDiscipline))) {
            document.getElementById("inpDecks").value = lookupProperty(currentDiscipline, "amount");
          } else {
            document.getElementById("inpDecks").value = localStorage.getItem("decks" + currentDiscipline);
          }
          //	}
        } else {

          document.getElementById("divDecks").style = "display:none";

        }

        document.getElementById("divCardSet").style = "display:flex";

        if (document.getElementById("chkLeftToRight").checked === "true") {
          document.getElementById("divStartRecallRight").style = "display:none";
        } else {
          document.getElementById("divStartRecallRight").style = "display:inline-block";
        }

        //show 'double click to end' input if it's speed cards
        if (currentDiscipline == "SC") {
          document.getElementById("divEnd").style = "flex:1";
        } else {
          document.getElementById("divEnd").style = "display:none";
        }


        //set settings according to localStorage
        console.log("retrieving card settings from local storage")

        const cardsLeftToRight = localStorage.getItem("cardsLeftToRight") === 'true';
        const startFromRight = localStorage.getItem("startFromRight") === 'true';

        if (cardsLeftToRight) {
          document.getElementById("chkLeftToRight").checked = true;
          document.getElementById("divStartRecallRight").style = "display:none";
          document.getElementById("lblChkDblToEnd").innerText = "End on double click of →";
        } else {
          document.getElementById("chkLeftToRight").checked = false;
          document.getElementById("divStartRecallRight").style = "display:inline-block";
          document.getElementById("lblChkDblToEnd").innerText = "End on double click of ←";
          if (startFromRight) {
            document.getElementById("chkStartRecallRight").checked = true;
          } else {
            document.getElementById("chkStartRecallRight").checked = false;
          }
        }
        cardOffsetBig = localStorage.getItem("cardOffsetBig") || 22;
        if (cardOffsetBig == '42') {
          document.getElementById("chkLargerGap").checked = true;
          //updatePreview();             
        }
        cardsDblToEnd = localStorage.getItem("cardsDblToEnd");
        if (cardsDblToEnd) document.getElementById("chkDblToEnd").checked = true;

      }
      else {
        document.getElementById("divDecks").style = "display:none";
        document.getElementById("divCardSet").style = "display:none";
      }

      //Get colour if necessary
      selectHiColour(hiColour);

      changeSkin();

      updatePreview(); // 2022  if this causes a problem, move it back to line 1153 (before the Cards section)


      //Show Skip box if necessary
      if (currentDiscipline == "5I" || currentDiscipline == "TI") {
        document.getElementById("divSkip").style = "display:block";
      } else {
        document.getElementById("divSkip").style = "display:none";
      }

      if (competitionTestMode && currentDiscipline.indexOf("F") > -1) {
        amount = resuming ? localStorage.getItem("amount") : (amount > 0 ? amount : lookupProperty(currentDiscipline, "amount"));
      }

      //Show Preload button if necessary
      if (competitionPreloadingRequired && currentDiscipline.indexOf("XC") == -1 && (currentDiscipline.indexOf("I") > -1 || currentDiscipline.indexOf("K") > -1 || currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("B") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1 || currentDiscipline.indexOf("D") > -1 || currentDiscipline.indexOf("F") > -1)) {
        document.getElementById("btnPreload").style = "display:inline";
        if (preloaded) {
          //	if (competitionMode) {
          document.getElementById("btnPreload").innerText = "Preload data";
          //	}
          document.getElementById('btnStartMemoCountdown').removeAttribute('disabled');
          document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
          //restore saved data
          if (currentDiscipline == "5I") {
            actualImageArray = JSON.parse(localStorage.getItem("preloadedData")).map(el => {return {src: "IAM Images/" + el}});
            imageArray = JSON.parse(localStorage.getItem("preloadedData"));
            amount = imageArray.length;
          } else if (currentDiscipline.indexOf("W") > -1) {
            wordList = JSON.parse(localStorage.getItem("preloadedData"));
            if (!competitionTestMode) {
              amount = wordList.length;
            }
          } else if (currentDiscipline.indexOf("D") > -1) {
            dateList = JSON.parse(localStorage.getItem("preloadedData"));
            if (!competitionTestMode) amount = dateList.length
          } else if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("K") > -1) {
            numberList = JSON.parse(localStorage.getItem("preloadedData"));
            if (!competitionTestMode) amount = numberList.length;
          } else if (currentDiscipline.indexOf("B") > -1) {
            binaryList = JSON.parse(localStorage.getItem("preloadedData"));
            if (!competitionTestMode) amount = binaryList.length;
          } else if (currentDiscipline.indexOf("C") > -1 && preloadAll) {
            cardList = JSON.parse(localStorage.getItem("preloadedData"));
            amount = cardList.length;
          } else {
            if (!competitionTestMode) {
              nameList = JSON.parse(localStorage.getItem("preloadedData"));
              amount = nameList.length * 2;
            }
          }
        } else {

          document.getElementById("btnPreload").removeAttribute("disabled");
          document.getElementById("btnStartMemoCountdown").setAttribute("disabled", "");
          document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
        }

      } else {
        //in training mode, don't show preload button
        document.getElementById("btnPreload").style = "display:none";

        //in training mode, start button available straight away for certain disciplines
        //	if (currentDiscipline.indexOf("I") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1 || currentDiscipline.indexOf("D") > -1 || currentDiscipline.indexOf("F") > -1) {
        if (currentDiscipline.indexOf("I") > -1 && !returningFromTest && !preloaded) {
          document.getElementById('btnStartMemoCountdown').setAttribute('disabled', "");
          document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
        } else {
          document.getElementById('btnStartMemoCountdown').removeAttribute('disabled');
          document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
        }
      }
    }

    function startMemoCountdown(test = false) {

      if (skin.indexOf("analogue") > -1 && currentDiscipline.indexOf("C") > -1) {
        $("#hiddenDiv")
          //.delay(30000)				
          .animate({opacity: .8}, 950).delay(200)
          .animate({opacity: .7}, 1200, 'swing')
          .animate({opacity: .83}, 1100)
        $("#darkenVignette")
          //.delay(30000)
          .animate({opacity: 1}, 1150)
          .animate({opacity: .25}, 1200, 'swing')
        $("#countdownBox").addClass("analogue1boxGreen");
        $("#countdownBox").removeClass("analogue1boxB");
      }


      document.getElementById("logoRow").style = "display:none";
      document.getElementById("topMargin").style = "display:block";
      document.getElementById("btnBackToSelection2").style = "display:none";

      //delete previous set of recall data, delete recall and score content div
      localStorage.setItem("chosen", "[]");
      document.getElementById("scoreContentDiv").innerHTML = "";
      document.getElementById("analogueCardsScoreContentDiv").innerHTML = "";
      document.getElementById("recallContentDiv").innerHTML = "";
      document.getElementById("analogueCardsRecallContentDiv").innerHTML = "";

      //get amount


      if (currentDiscipline == "10C" || currentDiscipline == "60C" || currentDiscipline == "30C") {
        var regAmount = lookupProperty(currentDiscipline, "amount");
        amount = resuming ? localStorage.getItem("amount") : document.getElementById("inpDecks").value;
        if (isNaN(Number(amount)) || amount <= 0) amount = regAmount;
        localStorage.setItem("amount", amount);
        localStorage.setItem("decks" + currentDiscipline, amount);
      }
      else {
        if (competitionMode && !competitionTestMode && preloaded) {
          amount = resuming ? localStorage.getItem("amount") : (amount > 0 ? amount : lookupProperty(currentDiscipline, "amount"));
          console.log("amount set to " + amount);
        } else {
          amount = resuming ? localStorage.getItem("amount") : (freeTraining() ? validateAmount(document.getElementById("inpAmount").value) : lookupProperty(currentDiscipline, "amount"));
        }

        localStorage.setItem("amount", amount);
      }

      //Get cards/words grouping
      if (currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1) {
        grouping = resuming ? Number(localStorage.getItem("grouping")) : Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
        localStorage.setItem("grouping", grouping);
        localStorage.setItem("grouping" + currentDiscipline, grouping);
      }


      //Get binary grouping
      if (currentDiscipline.indexOf("B") > -1) {
        groupingH = resuming ? Number(localStorage.getItem("groupingH")) : Number(document.getElementById("selBinGroupingH").options[document.getElementById("selBinGroupingH").selectedIndex].value);
        if (resuming) {
          navGroupingsBin = JSON.parse(localStorage.getItem("navGroupingsBin"));
          if (!navGroupingsBin || !navGroupingsBin.length) {
            //default values
            navGroupingsBin = [3];
            localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
          }
        } else {
          const navString = getValidNavBinString(document.getElementById("inpNavGroupingsBin").value);
          if (navString) {
            navGroupingsBin = navString.split('-').map(str => parseInt(str));
          } else {
            navGroupingsBin = [3];
          }
          localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
          //document.getElementById("inpNavGroupingsBin").value = navString;
        }
      }

      //Get highlighter colour (is this needed?)
      if (currentDiscipline.indexOf("B") > -1 || currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("K") > -1) {
        //	hiColour = resuming ? localStorage.getItem("hiColour") : document.getElementById("selHColour").options[document.getElementById("selHColour").selectedIndex].value;
        hiColour = resuming ? localStorage.getItem("hiColour") : hiColour;

        //change css variable
        document.body.style.setProperty("--highlightColor", this[hiColour]);
      }



      //Display countdown section only
      document.getElementById("selectionRow").style = "display:none";	//added in case we are resuming and go straight from selection to countdown
      document.getElementById("settingsRow0").style.display = 'none';
      document.getElementById("countdownTable").style.display = 'inline';
      document.getElementById("countdownRecallTable").style.display = 'none';
      document.getElementById("countdownText").innerHTML = "";
      document.getElementById("countdownTime").innerHTML = "";
      document.getElementById("countdownRow").style.display = "block";
      // document.getElementsByClassName("countdownDisciplineTitle").innerHTML = lookupProperty(currentDiscipline,"label");

      var titleElements = document.getElementsByClassName("countdownDisciplineTitle");
      var title = lookupProperty(currentDiscipline, "label");
      for (var i = 0; i < titleElements.length; i++) {
        titleElements[i].innerHTML = title;
      }

      //Get memo and recall times
      memoTime = lookupProperty(currentDiscipline, "memoTime");

      if (freeTraining()) {
        if (resuming) {
          memoTime = localStorage.getItem("memoTime" + currentDiscipline);
          recallTime = localStorage.getItem("recallTime" + currentDiscipline);
        } else {
          memoTime = Number(document.getElementById("inpMemoMins").value) * 60 + Number(document.getElementById("inpMemoSecs").value);
          recallTime = Number(document.getElementById("inpRecallMins").value) * 60 + Number(document.getElementById("inpRecallSecs").value);
          localStorage.setItem("memoTime" + currentDiscipline, memoTime);
          localStorage.setItem("recallTime" + currentDiscipline, recallTime);
        }
      }

      //Get the data to be memorised
      //NUMBERS
      if ((currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("K") > -1)) {

        if (resuming) {
          //restore number list
          numberList = JSON.parse(localStorage.getItem("correctAnswers"));
        } else {
          if (!competitionPreloadingRequired || test || competitionTestMode) {
            //new random numbers		
            numberList = [];
            for (i = 0; i < amount; i++) {
              numberList.push(Math.floor(Math.random() * 10));
            }
          }
          //save number list in storage
          if (!test) localStorage.setItem("correctAnswers", JSON.stringify(numberList));
        }
      }

      //BINARY
      if (currentDiscipline.indexOf("B") > -1) {

        if (resuming) {
          //restore binary digit list
          binaryList = JSON.parse(localStorage.getItem("correctAnswers"));
        } else {
          if (!competitionPreloadingRequired || test || competitionTestMode) {
            //new random binary digits
            binaryList = [];
            for (i = 0; i < amount; i++) {
              binaryList.push(Math.floor(Math.random() * 2));
            }
          }
          //save binary list in storage
          if (!test) localStorage.setItem("correctAnswers", JSON.stringify(binaryList));

        }
      }

      //CARDS

      /*
      if (currentDiscipline.indexOf("C") > -1 &&  (!competitionMode || test)) {
          cardList = [];
          if (resuming) {
              //restore card list
              cardList = competitionMode ? JSON.parse(localStorage.getItem("preloadedData")) : JSON.parse(localStorage.getItem("correctAnswers"));
          } else {
                  //if in training mode, generate random decks
                  if (!competitionMode || test) {
                  //for each deck
                  for (var d = 0; d < amount; d++) {
                      //generate a standard deck
                      var deck = getStandardDeck();
 
                      shuffle(deck);
 
                      cardList.push(deck);
                  }
              }
                  //save card list
                  if (!test) localStorage.setItem("correctAnswers", JSON.stringify(cardList));
          	
          }
      }*/

      if (currentDiscipline.indexOf("C") > -1) {

        if (resuming) {
          //restore card list
          cardList = (competitionMode & preloadAll) ? JSON.parse(localStorage.getItem("preloadedData")) : JSON.parse(localStorage.getItem("correctAnswers"));
        } else {
          //if in training mode (or competition but not preloading all), generate random decks

          if (!competitionMode || !preloadAll || test || competitionTestMode) {
            //for each deck
            cardList = [];
            for (var d = 0; d < amount; d++) {
              //generate a standard deck
              var deck = getStandardDeck();

              shuffle(deck);

              cardList.push(deck);
            }
          }
          //save card list
          if (!test) localStorage.setItem("correctAnswers", JSON.stringify(cardList));

        }
      }

      if (currentDiscipline.indexOf("I") > -1) {
        //nothing needs to happen here
      }


      if (currentDiscipline.indexOf("W") > -1) {

        if (!competitionMode || test || competitionTestMode) {
          if (test) {
            readWordsFile('English', true);
            generateWordList();

          } else {
            //if resuming, get dates list from storage
            if (resuming) {
              wordList = JSON.parse(localStorage.getItem("correctAnswers"))
              wordsLanguage = localStorage.getItem("wordsLanguage")
            } else {
              generateWordList();
              localStorage.setItem("correctAnswers", JSON.stringify(wordList));
            }
          }

        } else {
          //do we need to get words list from storage for competition mode?
        }




      }


      if (currentDiscipline.indexOf("F") > -1) {

        if (test || competitionTestMode) preloadNames(true);

        if (competitionMode) {
          shuffledNameList = JSON.parse(localStorage.getItem("shuffledNameList"));
          //openNamesFile();

          //generateNamesandFaces();
        }
      }

      if (currentDiscipline.indexOf("D") > -1) {

        if (!competitionMode || test || competitionTestMode) {
          if (test) {
            readDatesFile('English', true);
            addYearsForDates();
          } else {
            //if resuming, get dates list from storage
            if (resuming) {
              dateList = JSON.parse(localStorage.getItem("correctAnswers"))
              datesLanguage = localStorage.getItem("datesLanguage")
            } else {
              addYearsForDates();
              localStorage.setItem("correctAnswers", JSON.stringify(dateList));
            }
          }

        } else {
          //do we need to get dates list from storage for competition mode?
        }
      }

      //Display countdown clock
      if (currentDiscipline.indexOf("SC") > -1) {
        countSeconds = test ? -2 : (resuming ? -4 : 5);
      } else {
        countSeconds = test ? -2 : (resuming ? -4 : countdownSeconds);
      }
      cint = setInterval(showSeconds, 1000);
    }

    // function resetMiniGroupings() {
    // 	// miniGroupings = [];
    // 	// document.getElementById("inpMiniGroupings").value = "";
    // 	// localStorage.setItem("miniGroupings", "");
    // }


    function resetSeparations() {

      if (currentDiscipline.indexOf("N") > -1) {
        separations = [];
        document.getElementById("inpSeparation").value = "";
        localStorage.setItem("separations", []);

      } else {
        //NEW 2023 - not resetting binary separations unless now impossible
        // const sepTotal = document.getElementById("inpSeparationBin").value.indexOf("-") > -1 ? bla : parseInt(document.getElementById("inpSeparationBin").value);
        // if (sepTotal > document.getElementById("selBinGroupingW").value) {
        //     separations = [];
        //     document.getElementById("inpSeparationBin").value = "";
        //     localStorage.setItem("separationsBin", "[]");
        // }
        // shouldn't be needed now we validate inside applySeparationBin
        applySeparationBin();
      }
    }

    function updateLeftToRightSettings() {
      const cardsLeftToRight = document.getElementById("chkLeftToRight").checked;
      if (cardsLeftToRight) {
        document.getElementById("divStartRecallRight").style.display = "none";
        //update label for chkDblToEnd
        document.getElementById("lblChkDblToEnd").innerText = "End on double click of →";
      } else {
        document.getElementById("divStartRecallRight").style.display = "inline-block";
        document.getElementById("lblChkDblToEnd").innerText = "End on double click of ←";
      }
    }

    function updatePreview() {

      let previewString = "";
      if (currentDiscipline.indexOf("N") > -1) {
        previewString = "<table align='center' class='centred'><tr>";

        //get locus size
        if (miniGroupings.length > 0) {
          locusSize = miniGroupings.reduce((acc, val) => Number(acc) + Number(val));
        } else {
          //grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
          grouping = validateNavGroupingsNum(document.getElementById("inpMiniGroupings").value);
          localStorage.setItem("grouping", grouping);
          localStorage.setItem("grouping" + currentDiscipline, grouping);
          locusSize = grouping * imgsPerLocus;
        }

        //to catch situations where miniGroupings gets set to [0] somehow
        if (locusSize === 0) {
          locusSize = 3;
          console.log("miniGroupings was set to [0] or similar. Please check grouping settings.");
          miniGroupings = [3];
          document.getElementById("inpMiniGroupings").value = "3";
        }

        //add the locus before the selected one	
        for (i = 1; i <= locusSize; i++) {
          if (separations.length > 0 && (separations.indexOf(i) > -1 || i == locusSize)) {
            previewString += "<td id='preview" + i + "' class='separation " + skin + "numbersMemo'>" + i % 10 + "</td>";
          } else {
            previewString += "<td id='preview" + i + "' class='" + skin + "numbersMemo'>" + i % 10 + "</td>";
          }
        }

        //add selected one
        if (miniGroupings.length > 0) {
          //Show the selected group, with minigroupings
          var counter = 1;
          miniGroupings.forEach((el, i) => {
            for (j = 1; j <= el; j++) {
              //if first minigrouping then counts as normal selected
              if (i == 0) {

                if (separations.length > 0 && (separations.indexOf(counter) > -1 || counter == locusSize)) {
                  previewString += "<td id='previewSel" + counter + "' class='separation " + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
                } else {
                  previewString += "<td id='previewSel" + counter + "' class='" + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
                }
              } else {
                //else use numbersInLocus class
                if (separations.length > 0 && (separations.indexOf(counter) > -1 || counter == locusSize)) {
                  previewString += "<td id='preview" + counter + "' class='separation " + skin + "numbersInLocus " + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
                } else {
                  previewString += "<td id='preview" + counter + "' class='" + skin + "numbersInLocus " + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
                }
              }
            }

          });
        } else {
          //Show the selected group
          for (i = 1; i <= locusSize; i++) {
            if (separations.length > 0 && (separations.indexOf(i) > -1 || i == locusSize)) {
              previewString += "<td id='previewSel" + i + "' class='separation " + skin + "numbersMemo'>" + i % 10 + "</td>";
            } else {
              previewString += "<td id='previewSel" + i + "' class='" + skin + "numbersMemo'>" + i % 10 + "</td>";
            }
          }
        }

        for (i = 1; i <= locusSize; i++) {
          if (separations.length > 0 && (separations.indexOf(i) > -1 || i == locusSize)) {
            previewString += "<td id='preview" + (parseFloat(i) + parseFloat(locusSize)) + "' class='separation " + skin + "numbersMemo'>" + i % 10 + "</td>";
          } else {
            previewString += "<td id='preview" + (parseFloat(i) + parseFloat(locusSize)) + "' class='" + skin + "numbersMemo'>" + i % 10 + "</td>";
          }

        }
        previewString += "</tr></table>";

        document.getElementById("preview").innerHTML = previewString;

        //change preview skin

        for (i = 1; i <= locusSize * 2; i++) {
          document.getElementById("preview" + i).classList.remove(skin + "numbersSelected");
        }
        if (miniGroupings.length > 0) {
          for (i = 1; i <= miniGroupings[0]; i++) {
            document.getElementById("previewSel" + i).classList.add(skin + "numbersSelected");
          }
          for (i = locusSize + miniGroupings[0]; i <= locusSize; i++) {
            document.getElementById("preview" + i).classList.remove(skin + "numbersInLocus");
          }
        } else {
          //select whole locus
          for (i = 1; i <= locusSize; i++) {
            document.getElementById("previewSel" + i).classList.add(skin + "numbersSelected");
          }
        }
        //change preview highlight
        //var selNums = document.getElementsByClassName(skin + "numbersSelected");
        //for (let el of selNums) {
        //  el.style.background = this[hiColour];
        // }
      }

      if (currentDiscipline.indexOf("B") > -1) {
        console.log("1785 - " + navGroupingsBin);
        previewString = "<table align='center' class='centred'>";

        if (navGroupingsBin.length > 0) {
          var groupingH = Number(document.getElementById("selBinGroupingH").options[document.getElementById("selBinGroupingH").selectedIndex].value);
          var initialGroupingW = navGroupingsBin[0];
          var highlightGroupSize = navGroupingsBin.reduce((acc, val) => Number(acc) + Number(val));
        } else {
          //set default values
          var groupingH = 1
          var initialGroupingW = 3;
          var highlightGroupSize = 3;
        }

        localStorage.setItem("groupingH", groupingH);  //*** these should not be set here logically
        localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin)); //*** these should not be set here logically                

        for (h = 1; h <= groupingH; h++) {
          previewString += "<tr>";

          //if highlightGroupSize <= 10, add the highlight group before the selected one	
          if (highlightGroupSize <= Math.ceil(binaryPerRow / 3)) {
            for (w = 1; w <= highlightGroupSize; w++) {
              previewString += "<td class='preview " + skin + "binaryMemo'>0</td>";
            }
          }


          //   if (navGroupingsBin.length > 0) {
          //Show the selected highlight group, with minigroupings
          var counter = 1;
          navGroupingsBin.forEach((el, set) => {
            for (j = 1; j <= el; j++) {
              //if first set in highlight then counts as normal selected
              if (set === 0) {
                previewString += "<td class='preview " + skin + "binaryMemo " + skin + "binarySelected'>" + 1 + "</td>";
              } else {
                //else use numbersInLocus class
                previewString += "<td class='preview " + skin + "numbersInLocus " + skin + "binaryMemo'>" + 1 + "</td>";
              }
            }

          });
          // } else {
          //     //Show the selected group
          //     for (w = 1; w <= groupingW; w++) {
          //         if (separations.length > 0 && (separations.indexOf(w) > -1 || w == groupingW)) {
          //             previewString += "<td id='previewSel" + ((h - 1) * groupingW + w) + "' style='border-right:solid 1px black'>1</td>";
          //         } else {
          //             previewString += "<td id='previewSel" + ((h - 1) * groupingW + w) + "'>1</td>";
          //         }
          //     }
          // }

          //if highlightGroupSize <= 10, add the highlight group after the selected one	
          if (highlightGroupSize <= Math.ceil(binaryPerRow / 3)) {
            for (w = 1; w <= highlightGroupSize; w++) {
              //  previewString += "<td id='preview" + ((h - 1) * groupingW + w + groupingW * groupingH) + "'>0</td>";
              previewString += "<td class='preview " + skin + "binaryMemo'>0</td>";
            }
          }
          previewString += "</tr>";
        }
        previewString += "</table>";

        document.getElementById("preview").innerHTML = previewString;

        //change preview skin

        // for (i = 1; i <= groupingH * groupingW * 2; i++) {

        //     document.getElementById("preview" + i).className = skin + "binaryMemo";

        // }
        // for (i = 1; i <= groupingH * groupingW; i++) {
        //     document.getElementById("previewSel" + i).className = skin + "binaryMemo " + skin + "binarySelected";
        // }

        //change preview highlight
        //  var selNums = document.getElementsByClassName(skin + "binarySelected");


        //add separations
        let previewCells = document.querySelectorAll(".preview");

        let separationIndex = 0; // Initialize the separation index
        let separationCountdown = separations[separationIndex]; // Initialize the separation countdown
        previewCells.forEach((el, i) => {
          //if (separations.length > 0 && (separations.indexOf(i) > -1)) previewCells[i].classList.add('separation')
          if (separationCountdown === 1) {
            previewCells[i].classList.add('separation')
            // Increment the separation index
            separationIndex++;

            // If the separation index exceeds the separations array length, reset it
            if (separationIndex >= separations.length) {
              separationIndex = 0;
            }

            // Update the separation countdown based on the current separation index
            separationCountdown = separations[separationIndex];
          } else {
            // Decrement the separation countdown for the next iteration
            separationCountdown--;
          }

        })

      }

      if (currentDiscipline.indexOf("C") > -1) {
        grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
        localStorage.setItem("grouping", grouping);
        localStorage.setItem("grouping" + currentDiscipline, grouping);

        localStorage.setItem("cardOffsetBig", cardOffsetBig);
        if (cardOffsetBig == 22) {
          document.getElementById("chkLargerGap").checked = false;
        } else {
          document.getElementById("chkLargerGap").checked = true;
        }


        var classString = skin + "cardOneMemo";
        var classString2 = skin + "cardOtherMemo";


        cardSet = Number(document.getElementById("selCardSet").options[document.getElementById("selCardSet").selectedIndex].value);

        //use worn set for standard set if analogue skin
        // if (cardSet == 1 && skin.indexOf("analogue") > -1) {
        //     cardSet = 3;
        // }

        localStorage.setItem("cardSet", cardSet);

        document.getElementById("cardAttribution").innerHTML = cardAttributions[cardSet - 1];

        previewString = "<div style='height:220px;position:relative;left:-" + (114.37 + (grouping - 1) * 22) / 2 + "'><img id='cardOne' src='Card images " + cardSet + "/c13.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig'  style='left:50%;margin:0 0 0 " + 0 + "px'>";
        for (var i = 1; i < grouping; i++) {
          offset = i * cardOffsetBig;
          previewString += "<img src='Card images " + cardSet + "/c" + (i > 3 ? "0" : "") + (13 - i) + ".png' class='" + skin + "cardOtherMemo " + skin + "cardImgBig' style='left:50%;margin:0 0 0 " + offset + "px'>";

        }
        previewString += "</div>";
        document.getElementById("preview").innerHTML = previewString;
      }


      if (currentDiscipline.indexOf("W") > -1) {
        grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
        localStorage.setItem("grouping", grouping);
        localStorage.setItem("grouping" + currentDiscipline, grouping);
      }
    }

    function getStandardDeck() {
      var deck = new Array();
      //get a deck of 52 cards (non-faces)
      for (i = 0; i < nonfaceList.length; i++) {
        for (j = 0; j < suitInitialList.length; j++) {
          deck.push({
            cv: nonfaceList[i],
            cs: suitInitialList[j]
          });
        }

      }


      //get the face cards into the deck
      for (i = 0; i < faceList.length; i++) {
        for (j = 0; j < suitInitialList.length; j++) {
          deck.push({
            cv: faceList[i],
            cs: suitInitialList[j]
          });
        }
      }


      return deck;

    }

    function sortBoneyard(boneyard) {
      const suitSortList = new Array("s", "h", "c", "d");
      const valueSortList = nonfaceList.concat(faceList);

      boneyard.sort(function (a, b) {
        if (suitSortList.indexOf(a.cs) < suitSortList.indexOf(b.cs)) {
          //a has a suit that appears earlier
          return -1;
        } else if (suitSortList.indexOf(a.cs) == suitSortList.indexOf(b.cs)) {
          //suits are same, check value
          if (valueSortList.indexOf(a.cv) < valueSortList.indexOf(b.cv)) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return 1;
        }

      });
      return boneyard;
    }

    function shuffle(array) {
      var currentIndex = array.length, temporaryValue, randomIndex;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {

        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    }

    function showSeconds() {
      localStorage.setItem("phase", "memo");

      document.getElementById("countdownText").innerHTML = "Memorisation starts in: ";
      document.getElementById("countdownTime").innerHTML = countSeconds;
      countSeconds--;
      if (countSeconds <= -1) {
        clearInterval(cint);
        startMemo(countSeconds == -3);
      }
    }

    function testPage() {
      //	getSettings();

      //may need to load data
      if (currentDiscipline.indexOf("I") > -1) {
        preloadImages(true);
      }
      if (currentDiscipline.indexOf("C") > -1) {


        preloadCardImages(true);
      }
      if (currentDiscipline.indexOf("F") > -1) {
        //can't do it here as don't have amount yet, so doing it in startmemocountdown
        //	preloadNames(true);
      }

      if (currentDiscipline.indexOf("K") > -1 || currentDiscipline.indexOf("XC") > -1) {
        startRecallCountdown(true);
      } else {
        startMemoCountdown(true);
      }
    }

    /*
        function getSettings() {
            switch (currentDiscipline) {
                case "5N":
                case "15N":
                case "30N":
                case "60N":
                    //get number settings
                    break;
                case "5B":
                case "30B":
                    //get binary settings
                    break;
                case "10C":
                case "30C":
                case "60C":
                //get long cards settings (grouping, decks, card set, direction)
    
                    break;
    
                case "SC":
                case "SXC":
                //get speed cards settings
    
                    break;
                case "D":
                    //get dates settings
                    break;
                case "5F":
                case "15F":
                    //get names settings
                    break;
                case "5W":
                case "15W":
                //get words settings
                    break;
                	
                default:
            //get images settings
            }
        }
    */
    /*
    function preloadAllImages() {
         var ext, imageURL;
         var allImages = [];
         ext = "png";
    for (i = 1; i < numberOfPngs;i++) {
    	
        imageURL = "Image (" + i + ")." + ext;
     allImages.push(imageURL);
    	
    }
    ext = "jpg";
    for (i = 1; i < numberOfJpgs;i++) {
        imageURL = "Image (" + i + ")." + ext;
    allImages.push(imageURL);
	
    }
	
	
    //preload images
    imagesLoaded =0 ;
    var allImageLoads = [];
    for (let im = 0; im < allImages.length; im++) {
        allImageLoads[im] = new Image();
        allImageLoads[im].src = 'IAM Images/' + allImages[im];
        allImageLoads[im].onload = function() {imagesLoaded++};
    }
	
	
    }
	
    */

    /*
    function preloadCompetitionData() {
        preloadCardImages();
        preloadImages();
        //get format
     var thisFormat = document.getElementById("selFormat").options[document.getElementById("selFormat").selectedIndex].value;
     //"N"
        preloadNameImages();
    }*/

    function preloadNames(test = false) {
      //First generate the names and faces
      openNamesFile();
      generateNamesandFaces(test);


    }

    // Call this function whenever the user changes the number of images
    function handleImageAmountChange() {
      if (getCurrentDisciplineType() !== "I") return;
      // Update the 'amount' variable
      amount = validateAmount(document.getElementById("inpAmount").value);
      localStorage.setItem("amount" + currentDiscipline, amount);

      // Restart the preload process
      clearInterval(preloaderImages);
      document.getElementById("btnStartMemoCountdown").setAttribute("disabled", true);
      preloadImages();
    }


    // function preloadImages(test = false) {
    //     document.getElementById('btnStartMemoCountdown').setAttribute('disabled', '');

    //     //new 2024, testing
    //     if (preloaderImages) {
    //         clearInterval(preloaderImages);
    //     }

    //     var imagesLoaded = 0;
    //     preloaded = false;

    //     document.getElementById("btnStartMemoCountdown").innerText = "Loading images... Please wait";
    //     document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
    //     preloading = true;
    //     if (freeTraining()) {
    //         amount = validateAmount((document.getElementById("inpAmount").value));
    //     } else {
    //         amount = lookupProperty("5I", "amount");

    //     }

    //     imageArray = [];
    //     actualImageArray = [];
    //     //get the images
    //     var imageURL;
    //     var num;
    //     var ext;

    //     //check if preloading competition data (not test)
    //     if (!test && competitionMode && !competitionTestMode && preloadAll) {

    //         var rawFile = new XMLHttpRequest();
    //         rawFile.open("GET", "Data_" + compName + "/Images/images.txt", true);
    //         rawFile.onload = function () {
    //             if (rawFile.readyState === 4) {
    //                 if (rawFile.status === 200 || rawFile.status == 0) {
    //                     var imagesText = rawFile.responseText;

    //                     imagesText.trim();
    //                     var txtArray = imagesText.split('\r\n');

    //                     for (var i = 0; i < amount + 1; i++) {

    //                         if (txtArray[i][0] == '[') {

    //                             //The last item is the shuffle order
    //                             answerArray = [];
    //                             var shuffleOrder = JSON.parse(txtArray[i]);

    //                             answerArray = shuffleOrder.slice();

    //                             //save it
    //                             localStorage.setItem("answerArray", JSON.stringify(answerArray));

    //                             break;
    //                         }


    //                         else if (txtArray[i] !== "") {
    //                             imageArray.push(txtArray[i]);
    //                         }


    //                     }

    //                     localStorage.setItem("imageArray", JSON.stringify(imageArray));

    //                     //if organiser didn't provide enough images, change the amount
    //                     if (competitionMode && !test && !competitionTestMode) amount = imageArray.length;


    //                     //preload images

    //                     for (let im = 0; im < amount; im++) {
    //                         actualImageArray[im] = new Image();
    //                         actualImageArray[im].src = 'IAM Images/' + imageArray[im];
    //                         actualImageArray[im].onload = function () {

    //                             console.log(++imagesLoaded);
    //                             document.getElementById("btnStartMemoCountdown").innerText = "Loading images: " + (imagesLoaded + 1) + " of " + amount;

    //                             if (imagesLoaded == amount) {
    //                                 document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
    //                                 document.getElementById("btnStartMemoCountdown").innerText = "Start";
    //                                 document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

    //                                 document.getElementById("btnPreload").innerText = "Preload data";

    //                                 localStorage.setItem("preloadedData", JSON.stringify(imageArray));
    //                                 preloaded = true;
    //                             }
    //                         };
    //                     }
    //                 }
    //             }
    //         }
    //         rawFile.send(null);

    //     } else {
    //         for (i = 0; i < amount; i++) {
    //             //uncoment these lines if duplicates are allowed on different rows
    //             //		if (i % 5 == 0) {
    //             //			usedImageNums = [];
    //             //		}	
    //             num = Math.floor(Math.random() * (numberOfPngs + numberOfJpgs)) + 1;
    //             while (usedImageNums.indexOf(num) > -1) {
    //                 num = Math.floor(Math.random() * (numberOfPngs + numberOfJpgs)) + 1;
    //             }
    //             usedImageNums.push(num);
    //             if (num > numberOfPngs) {
    //                 ext = "jpg";
    //                 num -= numberOfPngs;
    //             } else {
    //                 ext = "png";
    //             }
    //             imageURL = "Image (" + num + ")." + ext;
    //             imageArray.push(imageURL);
    //         }

    //         //shuffle the images
    //         shuffle(imageArray);

    //         localStorage.setItem("imageArray", JSON.stringify(imageArray));


    //         //preload images
    //         var imagesLoaded = 0;
    //         for (let im = 0; im < amount; im++) {                    
    //             actualImageArray[im] = new Image();
    //             actualImageArray[im].src = 'IAM Images/' + imageArray[im];                    
    //             actualImageArray[im].onload = function () {
    //                 if (!test && getCurrentDisciplineType() === "I") {
    //                     console.log(++imagesLoaded + " " + preloading + " test: " + test);
    //                     document.getElementById("btnStartMemoCountdown").innerText = "Loading images: " + (imagesLoaded + 1) + " of " + amount;
    //                     if (imagesLoaded == amount && preloading && !test) {
    //                         //		startMemoCountdown();
    //                         if (competitionMode) document.getElementById("btnPreload").style.display = "none";
    //                         document.getElementById("btnStartMemoCountdown").innerText = "Start";
    //                         document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
    //                         document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
    //                         preloaded = true;
    //                         localStorage.setItem("preloadedData", JSON.stringify(imageArray));
    //                     }
    //                 }
    //             };
    //         }
    //     }


    // // new 2024, testing
    //     preloaded = false;
    //     preloaderImages = setInterval(function () {
    //         // Check if all images are loaded
    //         if (imagesLoaded == amount) {
    //             clearInterval(preloaderImages);

    //             // Enable the Start button and update UI
    //             document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
    //             document.getElementById("btnStartMemoCountdown").innerText = "Start";
    //             document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

    //             document.getElementById("btnPreload").innerText = "Preload data";

    //             localStorage.setItem("preloadedData", JSON.stringify(imageArray));
    //             preloaded = true;
    //         }
    //     }, 1000);

    // }
    async function preloadImages(test = false) {
      let amount;
      imageArray = [];
      // Initialize or reset the actualImageArray
      actualImageArray = [];

      if (freeTraining()) {
        amount = validateAmount((document.getElementById("inpAmount").value));
      } else {
        amount = lookupProperty("5I", "amount");
      }

      console.log(amount);

      const isPredefinedCompetitionData = !test && competitionMode && !competitionTestMode && preloadAll;
      const maxRetries = 3;
      const throttleLimit = 100; // Max concurrent requests
      let imagesLoaded = 0;

      if (preloaderImages) {
        clearInterval(preloaderImages);
      }

      // Helper function to load images with retry logic
      const loadImage = (url, index, retries = maxRetries) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.src = 'IAM Images/' + url;

          img.onload = () => {
            imagesLoaded++;
            document.getElementById("btnStartMemoCountdown").innerText = `Loading images: ${imagesLoaded} of ${amount}`;
            actualImageArray[index] = img;
            resolve(true);
          };

          img.onerror = () => {
            if (retries > 0) {
              console.log(`Retrying image: ${url} (Attempts left: ${retries})`);
              resolve(loadImage(url, index, retries - 1)); // Retry recursively
            } else {
              console.error(`Failed to load image: ${url}`);
              resolve(false); // Fail gracefully
            }
          };
        });
      };

      // Throttle loading to avoid overwhelming the server
      const throttleLoadImages = async (imageArray) => {
        let currentIndex = 0;

        const loader = async () => {
          if (currentIndex >= imageArray.length) return;

          const batch = [];
          for (let i = 0; i < throttleLimit && currentIndex < imageArray.length; i++) {
            batch.push(loadImage(imageArray[currentIndex], currentIndex));
            currentIndex++;
          }
          await Promise.allSettled(batch);
          await loader(); // Continue loading the next batch
        };

        await loader(); // Start loading the first batch
      };

      // Preload images logic
      if (isPredefinedCompetitionData) {
        const response = await fetch(`Data_${compName}/Images/images.txt`);
        if (response.ok) {
          const imagesText = await response.text();
          const txtArray = imagesText.trim().split('\r\n');

          for (let i = 0; i < amount + 1; i++) {
            if (txtArray[i][0] === '[') {
              answerArray = JSON.parse(txtArray[i]);
              localStorage.setItem("answerArray", JSON.stringify(answerArray));
              break;
            } else if (txtArray[i] !== "") {
              imageArray.push(txtArray[i]);
            }
          }

          localStorage.setItem("imageArray", JSON.stringify(imageArray));
          amount = imageArray.length; // Adjust amount to the length of loaded images

          await throttleLoadImages(imageArray); // Load images with throttling
        }
      } else {
        for (let i = 0; i < amount; i++) {
          let num = Math.floor(Math.random() * (numberOfPngs + numberOfJpgs)) + 1;
          while (usedImageNums.includes(num)) {
            num = Math.floor(Math.random() * (numberOfPngs + numberOfJpgs)) + 1;
          }
          usedImageNums.push(num);

          const ext = num > numberOfPngs ? "jpg" : "png";
          if (num > numberOfPngs) num -= numberOfPngs;
          const imageURL = `Image (${num}).${ext}`;
          imageArray.push(imageURL);
        }

        shuffle(imageArray);
        localStorage.setItem("imageArray", JSON.stringify(imageArray));

        await throttleLoadImages(imageArray); // Throttled loading for random data
      }

      preloaded = false;
      preloaderImages = setInterval(() => {
        if (imagesLoaded >= amount) {
          finishPreload();
        }
      }, 1000);
    }

    function finishPreload() {
      clearInterval(preloaderImages);
      document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
      document.getElementById("btnStartMemoCountdown").innerText = "Start";
      document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
      document.getElementById("btnPreload").innerText = "Preload data";
      localStorage.setItem("preloadedData", JSON.stringify(imageArray));
      preloaded = true;
    }

    function preloadDigits() {
      var rawFile;
      var src;

      //get trial number if needed
      trialNo = currentDiscipline == "5N" ? document.getElementById("selTrial").value : "";

      src = "Data_" + compName + "/Digits/" + currentDiscipline + trialNo + ".txt";
      rawFile = new XMLHttpRequest();
      rawFile.open("GET", src, true); // third parameter is true

      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var numText = rawFile.responseText.trim();
            numberList = [];
            for (var i = 0; i < numText.length; i++) {
              numberList.push(numText[i]);
            }

            if (currentDiscipline.indexOf("B") > -1) binaryList = numberList.slice();

            document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
            document.getElementById("btnStartMemoCountdown").innerText = "Start";

            document.getElementById("btnPreload").innerText = "Preload data";

            localStorage.setItem("preloadedData", JSON.stringify(numberList));
            preloaded = true;


            //if organiser didn't provide enough digits (for Spoken), change the amount
            if (competitionMode) amount = numberList.length;
          }
        }
      }

      rawFile.send(null);
    }

    function preloadCardData() {

      document.getElementById("btnStartMemoCountdown").innerText = "Loading data... Please wait";
      var rawFile = new XMLHttpRequest();

      rawFile.open("GET", "Data_" + compName + "/Cards/" + currentDiscipline + ".txt", true);

      rawFile.onload = function () {

        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var cardText = rawFile.responseText;


            cardText = cardText.replace(/\\/ig, '');

            cardList = JSON.parse(cardText);

            document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
            document.getElementById("btnStartMemoCountdown").innerText = "Start";

            document.getElementById("btnPreload").innerText = "Preload data";

            localStorage.setItem("preloadedData", JSON.stringify(cardList));
            preloaded = true;
          }
        }
      }
      rawFile.send(null);





    }

    function preloadCardImages(test = false) {

      var cardArray = getStandardDeck();

      var actualCardArray = [];
      //preload images
      var cardsLoaded = 0;



      actualCardArray[0] = new Image();
      actualCardArray[0].src = "Card images " + cardSet + "/back.png";
      actualCardArray[0].onload = function () {
        console.log(++cardsLoaded);
        if (cardsLoaded == 53) {
          if (competitionPreloadingRequired && !test) {
            document.getElementById("btnStartMemoCountdown").innerText = "Start";
            document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

            document.getElementById("btnPreload").innerText = "Preload data";

            preloaded = true;
          } else {
            document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

            document.getElementById("btnStartMemoCountdown").innerText = "Start";
            if (!test) startMemoCountdown();
          }
        }
      };

      for (let c = 1; c < 53; c++) {
        actualCardArray[c] = new Image();
        actualCardArray[c].src = "Card images " + cardSet + "/" + cardArray[c - 1]["cs"] + getValueName(cardArray[c - 1]["cv"]) + ".png";
        actualCardArray[c].onload = function () {
          console.log(++cardsLoaded);
          if (cardsLoaded == 53) {
            if (competitionPreloadingRequired && !test) {
              document.getElementById("btnStartMemoCountdown").innerText = "Start";
              document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
              document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

              document.getElementById("btnPreload").innerText = "Preload data";
              preloaded = true;
            } else {
              document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
              document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

              document.getElementById("btnStartMemoCountdown").innerText = "Start";
              if (!test) startMemoCountdown();
            }
          }
        };
      }


    }


    function moveNextInCurrentDiscipline() {
      switch (currentDiscipline) {
        case "5N":
        case "15N":
        case "30N":
        case "60N":
        case "TN":
          moveNextNumMemo();
          break;
        case "5B":
        case "30B":
        case "TB":
          moveNextBinMemo();
          break;
        case "10C":
        case "30C":
        case "60C":
        case "SC":
        case "TC":
          moveNextCardsMemo();
          break;
        case "D":
        case "TD":
          moveNextDatesMemo();
          break;
        case "5F":
        case "15F":
        case "TF":
          moveNextNamesMemo();
          break;
        case "5W":
        case "15W":
        case "TW":
          moveNextWordsMemo();
          break;
        case "S":
          break;
        default:
          moveNextImagesMemo();
      }
    }



    function startMemo(test = false) {
      //Display memo section only
      document.getElementById("countdownRow").style = "display:none";
      document.getElementById("memoRow").style = "display:block";

      //All of this is to restore the memo stuff after the intermediateSR screen from previous attempt
      document.getElementById("intermediateDivSR").style.display = "none";
      document.getElementById("intermediateDivMemoTime").style.display = "none";
      document.getElementById("menuDiv").style.display = "block";
      document.getElementById("memoContentDiv").style.display = "block"

      if (skin.indexOf('analogue') > -1) {
        document.getElementById("analogueCardsMemoContentDiv").style.display = "block";
        document.getElementById("bottomRightTimerDiv").style.display = "block";
      }
      //the digital timer should be "shown" in changeSkin so that should be OK

      //ADD MOBILE EVENT HANDLER 
      if (mobilecheck()) {
        var el = document.getElementById("memoBox");
        if (el.addEventListener) {
          el.addEventListener("click", function (e) {
            e.preventDefault();
            moveNextInCurrentDiscipline();
          }, false);
        } else {
          el.attachEvent('onclick', function (e) {
            e.preventDefault();
            moveNextInCurrentDiscipline();
          });
        }
      }
      //Display relevant memo depending on discipline
      switch (currentDiscipline) {
        case "5N":
        case "15N":
        case "30N":
        case "60N":
        case "TN":
          startNumberMemo(test);
          break;
        case "5B":
        case "30B":
        case "TB":
          startBinaryMemo(test);
          break;
        case "10C":
        case "30C":
        case "60C":
        case "SC":
        case "TC":
          startCardMemo(test);
          break;
        case "D":
        case "TD":
          startDatesMemo(test);
          break;
        case "5F":
        case "15F":
        case "TF":
          startNamesMemo(test);
          break;
        case "5W":
        case "15W":
        case "TW":
          startWordsMemo(test);
          break;
        default:
          startImagesMemo(test);
      }
    }

    function setupGroupingsAndLoci() {
      if (resuming) {
        if (currentDiscipline.indexOf("B") > -1) {
          //Get binary grouping (NEW 2023)
          groupingH = Number(localStorage.getItem("groupingH"));
          groupingW = Number(localStorage.getItem("groupingW"));

          if (localStorage.getItem("separationsBin") !== "" && localStorage.getItem("separationsBin") != null) {
            separations = JSON.parse(localStorage.getItem("separationsBin"));
          } else {
            separations = [];
          }

        } else applyMiniGroupings();
      }
      if (currentDiscipline.indexOf("B") === -1) {
        if (miniGroupings.length == 0) {
          locusSize = grouping;
          miniGroupings.push(locusSize);
          localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
        } else {
          locusSize = miniGroupings.reduce((acc, val) => Number(acc) + Number(val));
        }

        //create the arrays of minigroup and locus starting points

        miniGroupStarts = [];
        locusStarts = [0];
        var counter = 0;
        curMiniGroup = 0;
        while (counter < amount) {
          miniGroupStarts.push(counter);
          counter += parseFloat(miniGroupings[curMiniGroup]);
          if (curMiniGroup == miniGroupings.length - 1) {
            locusStarts.push(counter);
            curMiniGroup = 0;
          } else {
            curMiniGroup = parseFloat(curMiniGroup) + 1 % miniGroupings.length;
          }
        }
        console.log(miniGroupStarts);
        console.log(locusStarts);
      }

    }

    function startNumberMemo(test) {

      //set ended to false
      ended = false;

      //in a sep function

      if (resuming) {
        blnFocusBox = localStorage.getItem("blnFocusBoxN");
        blnHighlightOn = localStorage.getItem("blnHighlightOnN") === 'true';
        applyMiniGroupings();
      } else {
        blnFocusBox = document.getElementById("chkFocusBox").checked;
        blnHighlightOn = document.getElementById("chkHighlightOn").checked;
        localStorage.setItem("blnFocusBoxN", blnFocusBox);
        localStorage.setItem("blnHighlightOnN", blnHighlightOn);
      }
      if (blnFocusBox && !blnHighlightOn) document.body.style.setProperty("--highlightColor", '');

      if (miniGroupings.length == 0) {
        locusSize = grouping;
        miniGroupings.push(locusSize);
        localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
      } else {
        locusSize = miniGroupings.reduce((acc, val) => Number(acc) + Number(val));
      }

      //create the arrays of minigroup and locus starting points

      miniGroupStarts = [];
      locusStarts = [0];
      var counter = 0;
      curMiniGroup = 0;
      while (counter < amount) {
        miniGroupStarts.push(counter);
        counter += parseFloat(miniGroupings[curMiniGroup]);
        if (curMiniGroup == miniGroupings.length - 1) {
          locusStarts.push(counter);
          curMiniGroup = 0;
        } else {
          curMiniGroup = parseFloat(curMiniGroup) + 1 % miniGroupings.length;
        }
      }
      console.log(miniGroupStarts);
      console.log(locusStarts);
      //end of sep fn

      //work out how many pages needed (480 digits per page)
      numberOfPages = Math.ceil(amount / numbersPerPage);
      curPos = 0;
      curLocus = 0;
      curMiniGroup = 0;
      curPage = 0;

      firstOfGroup = 0;

      //add the page menu if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusNumMemo(" + numbersPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/>";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }

      //add the memo content
      var numberMemoString = "";
      for (i = 0; i < numberOfPages; i++) {

        if (i < numberOfPages - 1) {
          numbersOnThisPage = numbersPerPage;
        }
        else {
          numbersOnThisPage = amount - i * numbersPerPage;
        }

        if (blnFocusBox) {
          numberMemoString += "<div id='page" + i + "'><div class='focusBox focusBoxNumbers'></div><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";
        } else {
          numberMemoString += "<div id='page" + i + "'><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";
        }
        for (j = 0; j < numbersOnThisPage; j++) {
          numberMemoString += "<td id='tdMemo" + (i * numbersPerPage + j) + "' class='" + skin + "numbersMemo' onclick='moveFocusNumMemo(" + (i * numbersPerPage + j) + ")'>" + numberList[i * numbersPerPage + j] + "</td>";
          if ((j + 1) % numbersPerRow == 0) {
            if (j + 1 == numbersOnThisPage) {
              numberMemoString += "</tr></table></div>";

            }
            else {

              numberMemoString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage + j) / numbersPerRow + 2) + "&nbsp;&nbsp;</td>";


            }
          }

        }

      }


      numberMemoString += "</div><br />";
      //removed memo finish buttons
      // numberMemoString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishMemo();'>Finish</button>";
      document.getElementById("memoContentDiv").innerHTML = numberMemoString;

      //add separations
      if (resuming) separations = JSON.parse(localStorage.getItem("separations"));

      if (separations.length > 0) {
        for (var i = 0; i < amount; i++) {
          if (separations.indexOf((i + 1) % locusSize) > -1 || (i + 1) % locusSize == 0) {
            document.getElementById("tdMemo" + i).classList.add("separation");
          }

        }
      }

      //set width of focus box
      const focusBoxes = document.getElementsByClassName("focusBox");
      for (let i = 0; i < focusBoxes.length; i++) {
        focusBoxes[i].style.width = locusSize * 40 + separations.length * 48 + 40 + "px"; //*** separations should be reduced if not used, otherwise end up with massive box
      }

      //go to first digits
      moveFocusNumMemo(0);

      //set current position
      curPos = 0;
      curPage = 0;

      r = document.getElementById(skin + 'MemoTimeInner');
      if (!test) {
        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);


          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {
            memoTimeTaken = memoTime * 1000;
            finishMemo();
          }
          //Otherwise repeat this function
          else {
            if (!ended) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {

        //If Enter is pressed
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            memoTimeTaken = Date.now() - memoStart;
            confirmFinishMemo(test);
          } else {
            finishMemo(test);
          }
        }



        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          e.preventDefault();
          moveNextNumMemo();
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          e.preventDefault();
          movePreviousNumMemo();
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveUpNumMemo();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveDownNumMemo();
        }


        //if [ is pressed, previous page
        if (e.key == ',' && !ended) {

          if (curPage > 0) moveFocusNumMemo(numbersPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < numberOfPages - 1) moveFocusNumMemo(numbersPerPage * (curPage + 1));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusNumMemo(0);
        }



      };

    }

    function moveNextNumMemo() {
      if (!ended) {

        //go to next group start if possible
        if (!(curLocus == locusStarts.length - 2 && curMiniGroup == miniGroupings.length - 1)) {

          //see if it's a new locus
          //	if ((curMiniGroup+1) % miniGroupings.length == 0) {
          if (curMiniGroup == miniGroupings.length - 1) {
            moveLocusNumMemo(curLocus + 1, 0);
          } else {
            moveLocusNumMemo(curLocus, curMiniGroup + 1);
          }

        }
      }
    }

    function movePreviousNumMemo() {

      if (!ended) {
        //go to previous group start if possible
        if (!(curLocus == 0 && curMiniGroup == 0)) {

          //see if it's a new locus
          if (curMiniGroup == 0) {
            moveLocusNumMemo(curLocus - 1, miniGroupings.length - 1);
          } else {
            moveLocusNumMemo(curLocus, curMiniGroup - 1);
          }

        }
      }
    }

    function moveUpNumMemo() {

      //if we are on first row, don't move

      if (curPos >= numbersPerRow) {


        moveFocusNumMemo(curPos - numbersPerRow);


      }
    }

    function moveDownNumMemo() {

      //if we are on last row, don't move

      if (curPos + numbersPerRow < amount) {


        moveFocusNumMemo(curPos + numbersPerRow);


      }
    }

    function moveLocusNumMemo(newLocus, newMiniGroup) {
      var firstOfLocus = locusStarts[curLocus];
      var newFirstOfLocus = locusStarts[newLocus];
      var newPos;

      //if moving locus, remove all highlights from curLocus and add highlight to newLocus
      if (curLocus != newLocus) {
        //remove highlights
        document.getElementById("tdMemo" + firstOfLocus).classList.remove(skin + "numbersSelected");
        document.getElementById("tdMemo" + firstOfLocus).style.backgroundColor = "";
        for (var i = 1; i < locusSize; i++) {
          if (firstOfLocus < numberList.length - i) {
            document.getElementById("tdMemo" + (firstOfLocus + i)).classList.remove(skin + "numbersSelected");
            document.getElementById("tdMemo" + (firstOfLocus + i)).style.backgroundColor = "";
          }
        }
      } else { //not moving locus
        //put selected minigroup back to skin+numbersInLocus
        for (var i = 0; i < miniGroupings[curMiniGroup]; i++) {
          document.getElementById("tdMemo" + (curPos + i)).classList.remove(skin + "numbersSelected");
          document.getElementById("tdMemo" + (curPos + i)).classList.add(skin + "numbersInLocus");
        }
      }

      //add highlights
      var totalSoFar = 0;
      for (i = 0; i < miniGroupings.length; i++) {

        //go through all digits in this miniGroup
        for (j = 0; j < miniGroupings[i]; j++) {
          var pos = newFirstOfLocus + totalSoFar + j;
          if (pos < numberList.length) {
            if (i == newMiniGroup) {
              if (j == 0) newPos = pos;
              document.getElementById("tdMemo" + pos).classList.add(skin + "numbersSelected");
            } else {
              document.getElementById("tdMemo" + pos).classList.add(skin + "numbersInLocus");
            }
          }
        }
        totalSoFar += parseFloat(miniGroupings[i]);
      }

      //update focus box:
      //get digits that go in box
      let dataInFocus = numberList.slice(newFirstOfLocus, newFirstOfLocus + parseInt(locusSize)).join("");
      let dataInFocusArray = [];
      let prevSeparation = 0;
      //add spaces at relevant points
      separations.forEach(separation => {
        dataInFocusArray.push(dataInFocus.slice(prevSeparation, separation));
        prevSeparation = separation;
      });
      if (prevSeparation < locusSize) dataInFocusArray.push(dataInFocus.slice(prevSeparation, dataInFocus.length));
      dataInFocus = dataInFocusArray.join("&nbsp;&nbsp;");

      const focusBoxes = document.getElementsByClassName("focusBox");
      for (let i = 0; i < focusBoxes.length; i++) {
        focusBoxes[i].innerHTML = dataInFocus;
      }

      //get new page if necessary
      var newPage = Math.floor(newPos / numbersPerPage);
      if (newPage != curPage || curPos == 0) {

        //show/hide correct pages
        for (var i = 0; i < numberOfPages; i++) {
          if (i == newPage) {
            document.getElementById("page" + i).style.display = "block";

            if (numberOfPages > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i).style.display = "none";
            if (numberOfPages > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelink";
            }
          }
        }
        curPage = newPage;
      }
      curPos = newPos;
      curLocus = newLocus;
      curMiniGroup = newMiniGroup;
    }

    function moveFocusNumMemo(newPos) {

      var newLocus = Math.floor(newPos / locusSize);
      var newFirstOfLocus = locusStarts[newLocus];

      var totalSoFar = 0;
      var newMiniGroup = 0;

      for (i = 0; i < miniGroupings.length; i++) {
        totalSoFar += parseFloat(miniGroupings[i]);
        if (newPos - newFirstOfLocus < totalSoFar) {

          newPos = Number(parseFloat(newFirstOfLocus) + parseFloat(totalSoFar) - parseFloat(miniGroupings[i]));
          newMiniGroup = i;
          break;
        }
      }

      moveLocusNumMemo(newLocus, newMiniGroup);


      /*
      //get current first of locus
      var firstOfLocus = curPos - (curPos % locusSize);
  	
  	
  	
       //remove highlight from existing locus
       document.getElementById("tdMemo" + firstOfLocus).className = skin + "numbersMemo";
          document.getElementById("tdMemo" + firstOfLocus).style.backgroundColor = "";
          for (var i = 1;i<locusSize;i++) {
          if (firstOfLocus < numberList.length - i) {
                  document.getElementById("tdMemo" + (firstOfLocus + i)).className = skin + "numbersMemo";
                  document.getElementById("tdMemo" + (firstOfLocus + i)).style.backgroundColor = "";
              }
          }*/


      /*
          //get first of grouping
          var firstOfGroup = curPos - (curPos % grouping);
  	
  	
              //remove highlight from existing grouping
          document.getElementById("tdMemo" + firstOfGroup).className = skin + "numbersMemo";
          document.getElementById("tdMemo" + firstOfGroup).style.backgroundColor = "";
          for (var i = 1;i<grouping;i++) {
          if (firstOfGroup < numberList.length - i) {
                  document.getElementById("tdMemo" + (firstOfGroup + i)).className = skin + "numbersMemo";
                  document.getElementById("tdMemo" + (firstOfGroup + i)).style.backgroundColor = "";
              }
  	
          }
      */

      /*
          //get new page
          var newPage = Math.floor(newPos/numbersPerPage);
          if (newPage != curPage || curPos == 0) {
  	
  	
          //show/hide correct pages
          for (var i = 0; i < numberOfPages; i++) {
              if (i == newPage) {
                  document.getElementById("page" + i).style.display = "block";
              	
              if (numberOfPages>1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
              }
              }
              else {
              document.getElementById("page" + i).style.display = "none";
              if (numberOfPages>1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelink";
              }
              }
          }
          curPage = newPage;
          }
  	
  	
              if (newPos < amount) {
  	
          //update firstOfLocus
          if ((newPos == 0) || (newPos % locusSize == 0)) {
  	
      firstOfLocus = newPos;
  	
      }
      else {
      firstOfLocus = newPos - (newPos % locusSize);
  	
      }
  	
      /*
              //update firstOfGroup
              if ((newPos == 0) || (newPos % grouping == 0)) {
  	
                  firstOfGroup = newPos;
  	
              }
              else {
                  firstOfGroup = newPos - (newPos % grouping);
  	
              }
      */

      /*
          //find actual newPos (it's the first in the minigroup)
          var totalSoFar = 0;
          var current = 0;
          var selGroup = 0;
  	
          for (i = 0; i < miniGroupings.length; i++) {
              totalSoFar += parseFloat(miniGroupings[i]);
              if (newPos-firstOfLocus < totalSoFar) {
      	
                  newPos = Number(parseFloat(firstOfLocus) + parseFloat(totalSoFar) - parseFloat(miniGroupings[i]));
                  selGroup = i;
                  break;
              } 
          }
  	
  	
      //for each digit, add skin+numbersInLocus class, unless this is within newPos+its own grouping, in which case add skin+NumbersSelected
      totalSoFar = 0;
      for (i = 0; i < miniGroupings.length; i++) {
      	
          //go through all digits in this miniGroup
          for (j = 0; j < miniGroupings[i]; j++) {
          	
          if (totalSoFar + j >= parseFloat(newPos)-firstOfLocus && totalSoFar + j < (newPos-firstOfLocus) + parseFloat(miniGroupings[selGroup])) {
          document.getElementById("tdMemo" + (Number(parseFloat(firstOfLocus) + parseFloat(totalSoFar) + parseFloat(j)))).className = skin + "numbersMemo " + skin + "numbersSelected";
          } else {
              document.getElementById("tdMemo" + (Number(parseFloat(firstOfLocus) + parseFloat(totalSoFar) + parseFloat(j)))).className = skin + "numbersMemo " + skin + "numbersInLocus";
          }
          }
          totalSoFar += parseFloat(miniGroupings[i]);
      }
  	
      //	newPos = firstOfGroup;
      //	document.getElementById("tdMemo" + (firstOfLocus)).className = skin + "numbersMemo " + skin + "numbersSelected";		
      	
          //set new pos to first in group - if user has clicked on a digit or new page, need to only highlight from first in group
          //add the selected skin to this digit
              /*
              newPos = firstOfGroup;
              document.getElementById("tdMemo" + (firstOfGroup)).className = skin + "numbersMemo " + skin + "numbersSelected";		
      */



      /*
	
      for (var i = 1;i<grouping;i++) {
      if (firstOfGroup < numberList.length - i) {
              document.getElementById("tdMemo" + (Number(firstOfGroup + i))).className = skin + "numbersMemo " + skin + "numbersSelected";
        
          }
      }
	
  */
      /*
          curPos = newPos;
          }
      */
    }


    function startBinaryMemo(test) {
      //set ended to false
      ended = false;

      if (resuming) {
        blnFocusBox = localStorage.getItem("blnFocusBoxB");
        blnHighlightOn = localStorage.getItem("blnHighlightOnB") === 'true';
      } else {
        blnFocusBox = document.getElementById("chkFocusBox").checked;
        blnHighlightOn = document.getElementById("chkHighlightOn").checked;
        localStorage.setItem("blnFocusBoxB", blnFocusBox);
        localStorage.setItem("blnHighlightOnB", blnHighlightOn);
      }
      if (blnFocusBox && !blnHighlightOn) document.body.style.setProperty("--highlightColor", '');

      //work out how many pages needed (360 digits per page)
      numberOfPages = Math.ceil(amount / binaryPerPage);
      curPos = 0;
      curPage = 0;
      firstOfGroup = 0;

      //work out number of levels
      var longLine = binaryPerRow;
      binLevels = 1;

      const highlightGroupSize = navGroupingsBin.reduce((acc, val) => acc + val);

      while (longLine % highlightGroupSize !== 0) {
        longLine += binaryPerRow;
        binLevels++;
      }

      //add the page menu if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusBinMemo(" + binaryPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/>";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }

      //add the memo content
      var binaryMemoString = "";
      for (i = 0; i < numberOfPages; i++) {
        if (i < numberOfPages - 1) {
          binaryOnThisPage = binaryPerPage;
        }
        else {
          binaryOnThisPage = amount - i * binaryPerPage;
        }

        if (blnFocusBox) {
          binaryMemoString += "<div id='page" + i + "'><div class='focusBox focusBoxBinary'></div><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";
        } else binaryMemoString += "<div id='page" + i + "'><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";

        //binaryMemoString += "<div id='page" + i + "'><div class='focusBox focusBoxBinary'></div><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";
        // binaryMemoString += "<div id='page" + i + "'><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";
        for (j = 0; j < binaryOnThisPage; j++) {
          binaryMemoString += "<td id='tdMemo" + (i * binaryPerPage + j) + "' class='" + skin + "binaryMemo' onclick='moveFocusBinMemo(" + (i * binaryPerPage + j) + ")'>" + binaryList[i * binaryPerPage + j] + "</td>";
          if ((j + 1) % binaryPerRow == 0) {
            if (j + 1 == binaryOnThisPage) {
              binaryMemoString += "</tr></table></div>";

            }
            else {

              binaryMemoString += "</tr>";

              //spacer row
              //	for (k = 0; k < binaryPerRow; k++) {
              //   binaryMemoString += "<td id='tdMemoSpacer" + (i*binaryPerPage+Math.floor(j/binaryPerRow)*binaryPerRow+k) + "' height=16></td>";

              // }

              binaryMemoString += "<tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage + j) / binaryPerRow + 2) + "&nbsp;&nbsp;</td>";


            }
          }

        }

      }


      binaryMemoString += "</div><br />";
      //removed finish button
      // binaryMemoString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishMemo();'>Finish</button>";
      document.getElementById("memoContentDiv").innerHTML = binaryMemoString;

      //add separations
      if (resuming) {
        separations = JSON.parse(localStorage.getItem("separationsBin"));
      }

      const getSeparationPointsBin = (separations, amount, groupingH, binaryPerRow) => {

        if (separations.length === 0) {
          return [];
        } else {

          let separationPoints = [];

          let separationIndex = 0; // Initialize the separation index
          let separationCountdown = separations[separationIndex]; // Initialize the separation countdown

          let storedSeparationIndex = 0;
          let storedSeparationCountdown = 0;

          for (var i = 0; i < amount; i++) {
            //if we reach the start of a row save counter settings if we are at row 0 of a big row
            //if this is NOT row 0 in the big row, set the counter settings to what they were at start of last row
            if (i % binaryPerRow === 0) {
              const rowNumber = Math.floor(i / binaryPerRow)
              const rowNumberInBigRow = rowNumber % groupingH;
              if (rowNumberInBigRow === 0) {
                storedSeparationIndex = separationIndex;
                storedSeparationCountdown = separationCountdown;
              } else {
                separationIndex = storedSeparationIndex;
                separationCountdown = storedSeparationCountdown;
              }

            }

            if (separationCountdown === 1) {
              separationPoints.push(i);
              // Increment the separation index
              separationIndex++;

              // If the separation index exceeds the separations array length, reset it
              if (separationIndex >= separations.length) {
                separationIndex = 0;
              }

              // Update the separation countdown based on the current separation index
              separationCountdown = separations[separationIndex];
            } else {
              // Decrement the separation countdown for the next iteration
              separationCountdown--;
            }

          }
          return separationPoints;
        }
      };


      //add separations
      separationPointsBin = getSeparationPointsBin(separations, amount, groupingH, binaryPerRow);  //at some point we can use this to add the separations and delete code below

      // if (separations.length > 0) {
      //     let separationIndex = 0; // Initialize the separation index
      //     let separationCountdown = separations[separationIndex]; // Initialize the separation countdown

      //     let storedSeparationIndex = 0;
      //     let storedSeparationCountdown = 0;

      //     for (var i = 0; i < amount; i++) {
      //         //if we reach the start of a row save counter settings if we are at row 0 of a big row
      //         //if this is NOT row 0 in the big row, set the counter settings to what they were at start of last row
      //         if (i % binaryPerRow === 0) {
      //             const rowNumber = Math.floor(i / binaryPerRow)
      //             const rowNumberInBigRow = rowNumber % groupingH;
      //             if (rowNumberInBigRow === 0) {
      //                 storedSeparationIndex = separationIndex;
      //                 storedSeparationCountdown = separationCountdown;
      //             } else {
      //                 separationIndex = storedSeparationIndex;
      //                 separationCountdown = storedSeparationCountdown;
      //             }

      //         }

      //         if (separationCountdown === 1) {
      //             document.getElementById("tdMemo" + i).classList.add("separation");
      //             // Increment the separation index
      //             separationIndex++;

      //             // If the separation index exceeds the separations array length, reset it
      //             if (separationIndex >= separations.length) {
      //                 separationIndex = 0;
      //             }

      //             // Update the separation countdown based on the current separation index
      //             separationCountdown = separations[separationIndex];
      //         } else {
      //             // Decrement the separation countdown for the next iteration
      //             separationCountdown--;
      //         }
      //     }
      // }

      for (let i = 0; i < amount; i++) {
        if (separationPointsBin.includes(i)) document.getElementById("tdMemo" + i).classList.add("separation");
      }

      //set width and height of focus box
      const focusBoxes = document.getElementsByClassName("focusBox");
      const totalWidth = Math.max(...navGroupingsBin);
      for (let i = 0; i < focusBoxes.length; i++) {
        focusBoxes[i].style.width = totalWidth * 55 + separations.length * 30 + "px";
        focusBoxes[i].style.height = groupingH * 80 + "px";
      }

      //go to first digits
      moveFocusBinMemo(0);



      //set current position
      curPos = 0;
      curPage = 0;

      r = document.getElementById(skin + 'MemoTimeInner');
      if (!test) {
        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);
          //ns=(((memoTime*1e3-memoTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
          //r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);


          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {


            memoTimeTaken = memoTime * 1000;

            finishMemo();
          }
          //Otherwise repeat this function
          else {
            if (!ended) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {
        //If Enter is pressed
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            memoTimeTaken = Date.now() - memoStart;
            confirmFinishMemo(test);
          } else {
            finishMemo(test);
          }

        }

        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          moveNextBinMemo();
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          movePreviousBinMemo();
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveUpBinMemo();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveDownBinMemo();
        }

        //if [ is pressed, previous page
        if (e.key == ',' && !ended) {

          if (curPage > 0) moveFocusBinMemo(binaryPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < numberOfPages - 1) moveFocusBinMemo(binaryPerPage * (curPage + 1));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusBinMemo(0);
        }


      };

    }

    //  const getCurrentWidth = (pos, navGroupingsBin) => {             

    //     //ATTEMPT 1
    //     // let totalWidth = 0;
    //         // for (let i = 0; i <= pos; i++) {
    //         //     totalWidth += navGroupingsBin[i % navGroupingsBin.length];
    //         // }
    //         // return navGroupingsBin[pos % navGroupingsBin.length];

    //         // var totalWidth = 0;
    //         // var index = 0;

    //         // while (pos >= 0) {
    //         //     totalWidth = navGroupingsBin[index % navGroupingsBin.length];
    //         //     pos -= totalWidth;
    //         //     index++;
    //         // }

    //         // return totalWidth;

    //         //calculate pos % highlightGroupsize and determine which one it falls in

    //         var highlightGroupSize = navGroupingsBin.reduce((acc, val) => Number(acc) + Number(val));

    //         var offsetFromHighlightGroupStart = pos % highlightGroupSize;

    //         let sum = 0;
    //         for (let i = 0; i < navGroupingsBin.length; i++) {
    //             sum += navGroupingsBin[i];
    //             if (offsetFromHighlightGroupStart < sum) {
    //             return navGroupingsBin[i];
    //             }
    //         }
    //         // If the value is greater than the sum of all elements in the array, return undefined
    //         return;

    //     }   

    function getCurrentWidth(position, groupingH, navGroupingsBin) {
      const highlightGroupSize = navGroupingsBin.reduce((a, b) => a + b, 0); //total size of highlight group, adding together navGroupingsBin

      value = value % highlightGroupSize;
      let cumulativeSum = 0;
      for (let i = 0; i < arr.length; i++) {
        cumulativeSum += arr[i];
        if (value < cumulativeSum) {
          return arr[i];
        }
      }
      return;
    }

    const rowNumber = Math.floor(position / binaryPerRow);
    const bigRowNumber = Math.floor(rowNumber / groupingH);
    const x = position % binaryPerRow;
    const adjustedPosition = bigRowNumber * binaryPerRow + x; //to take into account the groupingH
    const offsetFromHighlightGroupStart = adjustedPosition % highlightGroupSize;

    // Use findNumberInRange to determine the current width based on the adjusted position
    const currentWidth = findNumberInRange(navGroupingsBin, adjustedPosition);

    return currentWidth;
        }

    function getCurrentSeparationWidth(position, groupingH, navGroupingsBin) {
      const separationTotal = separations.reduce((a, b) => a + b, 0); //total size of separations group

      function findNumberInRange(arr, value) {
        value = value % separationTotal;
        let cumulativeSum = 0;
        for (let i = 0; i < arr.length; i++) {
          cumulativeSum += arr[i];
          if (value < cumulativeSum) {
            return arr[i];
          }
        }
        return;
      }

      const rowNumber = Math.floor(position / binaryPerRow);
      const bigRowNumber = Math.floor(rowNumber / groupingH);
      const x = position % binaryPerRow;
      const adjustedPosition = bigRowNumber * binaryPerRow + x; //to take into account the groupingH
      const offsetFromSeparationGroupStart = adjustedPosition % separationTotal;

      // Use findNumberInRange to determine the current width based on the adjusted position
      const currentSepWidth = findNumberInRange(navGroupingsBin, adjustedPosition);

      return currentSepWidth;
    }


    // const getCurrentWidth = (pos, navGroupingsBin) => {
    //     let totalWidth = 0;
    //     let index = 0;

    //     while (index < pos) {
    //         totalWidth = navGroupingsBin[index % navGroupingsBin.length];
    //         index++;
    //     }

    //     return totalWidth;
    // };

    //         const getCurrentWidth = (pos, navGroupingsBin) => {
    //   let totalWidth = 0;
    //   let currentIndex = 0;

    //   while (pos >= currentIndex) {
    //     totalWidth = navGroupingsBin[currentIndex % navGroupingsBin.length];
    //     currentIndex += totalWidth;
    //   }

    //   return totalWidth;
    // };

    // function getFirstOfHighlight(pos) {
    //     var x = pos % binaryPerRow; //x position of pos
    //     var y = Math.floor(pos / binaryPerRow); //y position of pos

    //     var currentLevel = Math.floor(y / groupingH) % binLevels;
    //     var easyX = currentLevel * binaryPerRow + x;           

    //     const currentWidth = getCurrentWidth(pos, navGroupingsBin);

    //     var newX = (easyX - (easyX % currentWidth)) % binaryPerRow;
    //     var newY = y - (y % groupingH);
    //     //in case this matrix is split over two "big" rows, subtract matrix height * number of big rows' difference between this position and start of matrix
    //     newY -= groupingH * (Math.floor(easyX / binaryPerRow) - Math.floor((easyX - (easyX % currentWidth)) / binaryPerRow));

    //     return newY * binaryPerRow + newX;
    // }

    function getFirstOfHighlight(pos) {

      if (navGroupingsBin.length === 1 && groupingH === 1) return Math.floor(pos / navGroupingsBin[0]) * navGroupingsBin[0] // works if it's a single element in navGroupingsBin

      var candidate = 0, newCandidate = 0;
      var navPatternIndex = 0;
      var currentRow = 0;

      const rowNumber = Math.floor(pos / binaryPerRow)
      const rowNumberInBigRow = rowNumber % groupingH;
      pos = pos - rowNumberInBigRow * binaryPerRow;

      while (candidate < pos) {
        newCandidate += navGroupingsBin[navPatternIndex];
        navPatternIndex = (navPatternIndex + 1) % navGroupingsBin.length;
        if (newCandidate >= (currentRow + 1) * binaryPerRow) {
          currentRow += groupingH;
          newCandidate += (binaryPerRow * (groupingH - 1));
        }
        if (newCandidate > pos) {
          return candidate;
        } else if (newCandidate === pos) {
          return pos;
        } else candidate = newCandidate;

      }
      return candidate;
    }

    function getFirstOfImage(pos) {
      //go to first of matrix and then go 'next' until we reach pos, every time we pass a separations barrier then we update proposedFirstOfImage until we reach pos

      // let firstOfMatrix = getFirstOfHighlight(pos);
      // let currentCandidate = firstOfMatrix;
      // let proposedFirstOfImage = currentCandidate;
      // let i = 0;
      // let currentSeparation = 0;

      // const currentWidth = getCurrentWidth(pos, groupingH, navGroupingsBin);
      // const xDiff = getHighlightPositionsBin(pos).indexOf(pos) % currentWidth;

      // while (i <= xDiff) {
      //     if (separations[currentSeparation] === i) {
      //         proposedFirstOfImage = currentCandidate;
      //         currentSeparation++;
      //         i++;
      //         //  i = 0;
      //     } else i++;
      //     if ((currentCandidate + 1) % binaryPerRow === 0) {                    
      //         currentCandidate += (groupingH - 1) * binaryPerRow + 1
      //     } else currentCandidate++; //don't just add 1, need to move to next level sometimes

      // }
      // return proposedFirstOfImage;
      if (separations.length === 0) return getFirstOfHighlight(pos);
      if (separations.length === 1 && groupingH === 1) return Math.floor(pos / separations[0]) * separations[0] // works if it's a single element in separations

      var candidate = 0, newCandidate = 0;
      var sepIndex = 0;
      var currentRow = 0;

      const rowNumber = Math.floor(pos / binaryPerRow)
      const rowNumberInBigRow = rowNumber % groupingH;
      pos = pos - rowNumberInBigRow * binaryPerRow;

      while (candidate < pos) {
        newCandidate += separations[sepIndex];
        sepIndex = (sepIndex + 1) % separations.length;
        if (newCandidate >= (currentRow + 1) * binaryPerRow) {
          currentRow += groupingH;
          newCandidate += (binaryPerRow * (groupingH - 1));
        }
        if (newCandidate > pos) {
          return candidate;
        } else if (newCandidate === pos) {
          return pos;
        } else candidate = newCandidate;

      }
      return candidate;
    }


    function getNextSquare(pos) {
      //For Binary recall. Gets the next recall square (small square)
      var positions = getImagePositions(pos); // if using complex width it does the whole highlight group, it should do this by separation anyway
      //find index of pos in positions
      var thisIndex = positions.indexOf(pos);
      //if it is highest then move to next image and return first
      if (thisIndex === positions.length - 1) {
        return getFirstOfImage(getNextImage(pos));
      }
      //else return position at thisIndex+1
      else {
        //check in case this is a truncated matrix
        if (positions[thisIndex + 1] >= amount) {
          return getFirstOfImage(getNextImage(pos));
        }
        //return next position in this matrix (USUAL CASE)
        return positions[thisIndex + 1];
      }
    }

    function getPreviousSquare(pos) {
      //For Binary recall
      const positions = getImagePositions(pos);
      //find index of pos in positions
      const thisIndex = positions.indexOf(pos);
      //if it is lowest then move to previous matrix and return last
      if (thisIndex === 0) {
        const prevImagePositions = getImagePositions(getPreviousImage(pos));
        let result = prevImagePositions[prevImagePositions.length - 1];
        let i = prevImagePositions.length - 1;
        while (result >= amount) {
          i--;
          result = prevImagePositions[i];
        }
        return result;
      }
      //else return position at thisIndex-1
      else {
        return positions[thisIndex - 1];
      }
    }

    // binary code originally by Lance
    function getHighlightPositionsBin(pos) {
      if (pos === -1) return [];  //I added this to stop infinite loop
      const firstOfHighlight = getFirstOfHighlight(pos);
      const x = firstOfHighlight % binaryPerRow; //the x position of the first of highlight
      const y = Math.floor(firstOfHighlight / binaryPerRow); //the y position of the first of highlight

      let positions = [];

      //loop through the height and width and add successive positions to the matrix, moving down as necessary
      for (let i = 0; i < groupingH; i++) {
        thisX = x;
        thisY = y + i;

        let currentWidth = getCurrentWidth(pos, groupingH, navGroupingsBin)

        for (var j = 0; j < currentWidth; j++) {
          positions.push(thisY * binaryPerRow + thisX);

          //if we have reached end of row, move back to beginning of row and move down by groupingH
          if (thisX + 1 === binaryPerRow) {
            thisX = 0;
            thisY += groupingH;
          }

          //else move along one to the right
          else {
            thisX++;
          }

        }
      }

      return positions;
    }

    function getImagePositions(pos) {
      //for binary recall (returns the positions of a separated block which we assume is a single image)

      // const firstOfImage = getFirstOfImage(pos);

      // const x = firstOfImage % binaryPerRow;
      // const y = Math.floor(firstOfImage / binaryPerRow);

      // //calculate what x-position this is within the highlight matrix
      // const currentWidth = getCurrentWidth(pos, groupingH, navGroupingsBin)
      // const xPositionInMatrix = getHighlightPositionsBin(pos).indexOf(pos) % currentWidth % binaryPerRow;

      // //calculate gap between separations (this is our imageWidth)
      // let imageW = 0;
      // //const separationsTotal = separations.reduce((acc, val) => acc + val, 0); //CHECK THIS WORKS WITH MORE COMPLEX STUFF AS I THINK IT IS ALREADY CUMULATIVE?
      // const separationsTotal = separations.length ? separations[separations.length - 1] : 0;
      // if (xPositionInMatrix >= separationsTotal) {
      //     imageW = currentWidth - separationsTotal; // case where it's higher than the separations we have
      // } else {
      //     let cumulativeTotal = separations[0];
      //     let separationIndex = 0;
      //     if (xPositionInMatrix < cumulativeTotal) {
      //         imageW = separations[separationIndex]
      //     } else {
      //         while (xPositionInMatrix >= cumulativeTotal) {
      //             separationIndex++;
      //             cumulativeTotal = separations[separationIndex];
      //             if (xPositionInMatrix < cumulativeTotal) imageW = separations[separationIndex] - separations[separationIndex - 1];
      //         }

      //     }
      // }


      // var positions = [];

      // //loop through the height and width and add successive positions to the matrix, moving down as necessary
      // for (var i = 0; i < groupingH; i++) {
      //     thisX = x;
      //     thisY = y + i;

      //     for (var j = 0; j < imageW; j++) {
      //         positions.push(thisY * binaryPerRow + thisX);

      //         //if we have reached end of row, move back to beginning of row and move down by groupingH
      //         if (thisX + 1 === binaryPerRow) {
      //             thisX = 0;
      //             thisY += groupingH;
      //         }

      //         //else move along one to the right
      //         else {
      //             thisX++;
      //         }

      //     }
      // }

      // return positions;

      if (pos === -1) return [];  //I added this to stop infinite loop

      if (separations.length === 0) return getHighlightPositionsBin(pos);
      const firstOfImage = getFirstOfImage(pos);
      const x = firstOfImage % binaryPerRow; //the x position of the first of highlight
      const y = Math.floor(firstOfImage / binaryPerRow); //the y position of the first of highlight

      let positions = [];

      //loop through the height and width and add successive positions to the matrix, moving down as necessary
      for (let i = 0; i < groupingH; i++) {
        thisX = x;
        thisY = y + i;

        let currentSeparationWidth = getCurrentSeparationWidth(pos, groupingH, separations)

        for (var j = 0; j < currentSeparationWidth; j++) {
          positions.push(thisY * binaryPerRow + thisX);

          //if we have reached end of row, move back to beginning of row and move down by groupingH
          if (thisX + 1 === binaryPerRow) {
            thisX = 0;
            thisY += groupingH;
          }

          //else move along one to the right
          else {
            thisX++;
          }

        }
      }

      return positions;

    }

    function getNextHighlightBin(pos) {
      // For binary memo. Gets first position of next highlight (navigation group)
      const firstOfCurrentHighlight = getFirstOfHighlight(pos)
      while (pos + 1 < amount) {
        pos++;
        if (getFirstOfHighlight(pos) > firstOfCurrentHighlight) {
          return getFirstOfHighlight(pos)
        }
      }
      return -1;
    }

    function getPreviousHighlightBin(pos) {
      // For binary memo. Gets first position of previous highlight (navigation group)
      const firstOfCurrentHighlight = getFirstOfHighlight(pos);
      while (pos - 1 >= 0) {
        pos--;
        if (getFirstOfHighlight(pos) < firstOfCurrentHighlight) {
          return getFirstOfHighlight(pos);
        }
      }
      return -1;
    }

    function getNextImage(pos) {
      // For binary recall. Gets next image (separations group). Should just go to first of next image.        

      //just keep going to next square along until the firstOfImage is different
      const firstOfImageCurrent = getFirstOfImage(pos);

      var candidate = pos;
      while (candidate < amount) {
        candidate = ((candidate + 1) % binaryPerRow === 0) ? candidate + 1 + binaryPerRow * (groupingH - 1) : candidate + 1 // next square along row
        if (getFirstOfImage(candidate) !== firstOfImageCurrent) return candidate;
        console.log(candidate, getFirstOfImage(candidate))
      }
      return pos;
    }



    function getFinalImageWidth(separations, groupingW) {
      if (separations.length === 0) {
        return groupingW;
      } else if (groupingW === separations[separations.length - 1]) {
        if (separations.length > 1) {
          return separations[separations.length - 1] - separations[separations.length - 2];
        } else {
          return separations[separations.length - 1];
        }
      } else if (groupingW > separations[separations.length - 1]) {
        return groupingW - separations[separations.length - 1];
      } else {
        return groupingW;
      }
    }

    function getPreviousImage(pos) {
      //For Binary Recall

      //     //calculate what x-position this is within the matrix
      //     const xPositionInMatrix = getHighlightPositionsBin(pos).indexOf(pos) % groupingW % binaryPerRow;

      //     //calculate gap between separations (this is our imageWidth)
      //     let prevImageW = 0;

      //    //if the xPosition is less than the first thing in the separations array, we know we need the final image of a locus
      //     if (separations.length === 0 || xPositionInMatrix < separations[0]) {
      //         const finalImageWidth = getFinalImageWidth(separations, groupingW);
      //         prevImageW = finalImageWidth;
      //     } else {

      //         //go through cumulative map and if we find an element that the xPositionInMatrix is greater than or equal to, then we know that is the width of the previous image
      //         for (let counter = separations.length - 1; counter >= 0; counter--) {
      //             if (xPositionInMatrix >= separations[counter]) {
      //                 prevImageW = separations[counter] - (counter > 0 ? separations[counter - 1] : 0);
      //                 counter = 0;
      //             }
      //         }
      //     }

      //     // For binary recall. Gets next image (separations group). Goes to same position next locus.
      //     var x = (pos - prevImageW) % binaryPerRow; // add groupingW onto pos, as long as we don't reach the end of a row
      //     var y = Math.floor(pos / binaryPerRow); //y (the row) should be the floor of pos/30


      //     if (pos - prevImageW < y * binaryPerRow) {  // if subtrating prevImageW from pos means we end up on the next row:
      //         y -= groupingH;   //  then we go up by groupingH
      //     }

      //     return y * binaryPerRow + x;

      //just keep going to previous square along until the firstOfImage is different
      const firstOfImageCurrent = getFirstOfImage(pos);

      var candidate = pos;
      while (candidate >= 0) {
        candidate = ((candidate - 1) % binaryPerRow === 0) ? candidate - 1 - binaryPerRow * (groupingH - 1) : candidate - 1 // previous square along row
        if (getFirstOfImage(candidate) !== firstOfImageCurrent) return candidate;
        console.log(candidate, getFirstOfImage(candidate))
      }
      return getFirstOfImage(candidate);

    }

    function moveNextBinMemo() {
      const nextHighlight = getNextHighlightBin(curPos)
      if (!ended && nextHighlight > -1 && nextHighlight < amount) {
        moveFocusBinMemo(nextHighlight);
      }
    }

    function movePreviousBinMemo() {
      const prevHighlight = getPreviousHighlightBin(curPos);
      if (!ended && prevHighlight >= 0) {
        moveFocusBinMemo(prevHighlight);
      }
    }

    function moveUpBinMemo() {

      //if we are on first row, don't move

      if (curPos >= binaryPerRow * groupingH) {


        moveFocusBinMemo(curPos - binaryPerRow * groupingH);


      }
    }

    function moveDownBinMemo() {

      //if we are on last row, don't move

      if (curPos + binaryPerRow * groupingH < amount) {


        moveFocusBinMemo(curPos + binaryPerRow * groupingH);


      }
    }


    function moveFocusBinMemo(newPos) {
      //get grouping
      const positions = getHighlightPositionsBin(curPos);

      //remove highlight from existing grouping
      for (var i = 0; i < positions.length; i++) {
        if (positions[i] < binaryList.length) {
          document.getElementById("tdMemo" + (positions[i])).classList.remove(skin + "binarySelected");
          document.getElementById("tdMemo" + (positions[i])).style.backgroundColor = "";
        }
      }

      //get new page
      const newPage = Math.floor(newPos / binaryPerPage);
      if (newPage != curPage || curPos == 0) {

        //show/hide correct pages
        for (var i = 0; i < numberOfPages; i++) {
          if (i == newPage) {
            document.getElementById("page" + i).style.display = "block";
            if (numberOfPages > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i).style.display = "none";
            if (numberOfPages > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelink";
            }
          }
        }
        curPage = newPage;
      }

      if (newPos < amount) {

        //get grouping
        var newPositions = getHighlightPositionsBin(newPos);

        firstOfGroup = newPositions[0];

        //set new pos to first in group - if user has clicked on a digit or new page, need to only highlight from first in group
        newPos = firstOfGroup;


        //add highlight to new grouping

        for (var i = 0; i < newPositions.length; i++) {
          if (newPositions[i] < binaryList.length) {
            document.getElementById("tdMemo" + (newPositions[i])).classList.add(skin + "binarySelected");
            //  document.getElementById("tdMemo" + (newPositions[i])).style.backgroundColor = this[hiColour];	 
          }

        }


        curPos = newPos;
      }

      //update focus box:
      //get digits that go in box

      let dataInFocusArray = newPositions.map(p => binaryList[p]);

      //get an array of where the separations fall here based on newPositions
      var sepPointsForThisFocusBox = [];
      //add separation markers
      for (let i = 0; i < newPositions.length; i++) {
        if (separationPointsBin.includes(newPositions[i])) {
          sepPointsForThisFocusBox.push(i);
        }
      }

      //split them into subarrays for each row (according to currentWidth)
      //i.e. if currentWidth is 3, split them into 3s
      const dataInFocusRows = dataInFocusArray.reduce((resultArray, item, index) => {
        const chunkIndex = Math.floor(index / getCurrentWidth(newPos, groupingH, navGroupingsBin))

        if (!resultArray[chunkIndex]) {
          resultArray[chunkIndex] = [] // start a new chunk
        }

        resultArray[chunkIndex].push(item)

        return resultArray
      }, []).map(el => el.join(""));

      console.log(dataInFocusRows);


      //now display them in a table:
      //each row:
      //for each digit from 0 to groupingW (provided pos < binaryList.length)
      //if digit+1 is in sep then add a space after
      //i.e. if first sep is 4 then add a space after digit 3

      //set up grid
      function createGrid(rows) {
        var dataInFocusDiv = document.createElement("div");
        dataInFocusDiv.className = 'focusBoxBinaryGrid';

        dataInFocusRows.forEach(row => {
          const gridRow = document.createElement("div");
          gridRow.classList.add("focusBoxBinaryGrid-row");
          for (let i = 0; i < row.length; i++) {
            const gridDigit = document.createElement("div");
            gridDigit.classList.add("focusBoxBinaryGrid-digit");
            gridDigit.textContent = row[i];
            gridRow.appendChild(gridDigit);
            if (sepPointsForThisFocusBox.includes(i) && i !== row.length - 1) {
              const gridSep = document.createElement("div");
              gridSep.classList.add("focusBoxBinaryGrid-sep");
              //gridSep.textContent = "";
              gridRow.appendChild(gridSep);
            }
          }
          dataInFocusDiv.appendChild(gridRow);
        });

        return dataInFocusDiv;
      }

      // dataInFocusDiv.style.display = 'grid';
      // dataInFocusDiv.style.gridTemplateColumns = separations.reduce((result, item, index) => {
      //     if (index === separations.length - 1) {
      //         result += '40px '.repeat(separations[index]);
      //     } else result += '40px '.repeat(separations[index]) + '10px ';
      // }, '')


      //add data to grid (NOT DONE YET ****)
      // dataInFocusDiv.innerHTML = dataInFocusRows.join("");
      // console.log("set up data in focus div");
      // console.log(dataInFocusDiv.innerHTML)

      // let dataInFocusArray = [];      
      // let prevSeparation = 0;
      // //add spaces at relevant points
      // separations.forEach(separation =>  {           
      //    dataInFocusArray.push(dataInFocus.slice(prevSeparation, separation));
      //    prevSeparation = separation;
      // });
      // if (prevSeparation < groupingW) dataInFocusArray.push(dataInFocus.slice(prevSeparation, dataInFocus.length));
      // //dataInFocus = dataInFocusArray.join("&nbsp;&nbsp;");


      // let dataInFocus = dataInFocusArray.map((d, i) => {
      // 					if ((i+1) % groupingW === 0) {
      // 						return d + "<br />"
      // 					} else return d + "&nbsp;&nbsp;"
      // }).join("");

      // NOT USING YET SO COMMENTED OUT
      const focusBoxes = document.getElementsByClassName("focusBox");
      for (var i = 0; i < focusBoxes.length; i++) {
        const dataInFocusDiv = createGrid(dataInFocusRows);
        focusBoxes[i].innerHTML = '';
        focusBoxes[i].appendChild(dataInFocusDiv);
      }

    }


    function startCardMemo(test) {
      if (currentDiscipline == "SC" || test) memoTimeNeeded = true;
      showingBlank = false;

      //card table if using analogue skin
      if (skin.indexOf("analogue") > -1) {
        $("#memoBox").addClass("analogue1boxGreen");
        $("#memoBox").removeClass("analogue1boxA");
        /*
            $("#memoBox").addClass("cardTable");
            $(".disciplineTitleMemo").addClass("textCardTable");
            $(".disciplineTitleMemo").removeClass("textNonCards");
            $(".digital1RecallTimeOuter").addClass("textCardTable");
            $(".digital1RecallTimeOuter").removeClass("textNonCards");*/
      }

      if (resuming) {
        //restore image list
        //	actualImageArray = JSON.parse(localStorage.getItem("imageArray")).map(el => { return { src: "IAM Images/" + el } });
        cardsLeftToRight = localStorage.getItem("cardsLeftToRight") === 'true';
        cardOffsetBig = localStorage.getItem("cardOffsetBig") || 22;
        cardsDblToEnd = localStorage.getItem("cardsDblToEnd");
      } else {

        cardsLeftToRight = document.getElementById("chkLeftToRight").checked;
        localStorage.setItem("cardsLeftToRight", cardsLeftToRight);

        startFromRight = document.getElementById("chkStartRecallRight").checked;
        localStorage.setItem("startFromRight", startFromRight);

        cardsDblToEnd = document.getElementById("chkDblToEnd").checked;
        localStorage.setItem("cardsDblToEnd", cardsDblToEnd);

        cardOffsetBig = document.getElementById("chkLargerGap").checked ? 42 : 22;
        localStorage.setItem("cardOffsetBig", cardOffsetBig);
      }


      //set ended to false
      ended = false;

      var cardsMemoString = "";
      curPos = 0;
      curPage = 0;
      firstOfGroup = 0;

      //add the page menu if >1 page
      if (amount > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < amount; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusCardsMemo(" + 52 * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/><br />";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }

      cardsMemoString += "<br /><br />";

      //add the memo content
      for (var i = 0; i < amount; i++) {

        cardsMemoString += "<div id='page" + i + "' style='position:relative'><div class='centred bigCards' style='position:relative;left:-" + (114.37 + (grouping - 1) * cardOffsetBig) / 2 + "' id='bigCards" + i + "''></div><br /><br />";
        /*cardsMemoString += "<div class='centred' style='position:relative;left:-" + (211+51*cardOffset)/2 + "'><span id='smallCardsBefore" + i + "'></span><span id='smallCardsAfter" + i + "''></span></div>";*/

        //adding extra fan
        cardsMemoString += "<div class='centred cardMemoFanDiv " + skin + "cardMemoFanDiv'>";
        //add cards to extra fan
        if (skin.indexOf("digital") > -1 && !cardsLeftToRight) {
          for (var j = 51; j >= 0; j--) {
            cardsMemoString += "<img src='Card images " + cardSet + "/" + cardList[i][j]["cs"] + getValueName(cardList[i][j]["cv"]) + ".png' class='cardMemoFan " + skin + "cardMemoFan' id='imgMemoFan" + (i * 52 + j) + "' onClick='moveFocusCardsMemo(" + (i * 52 + j) + ")'>";
          }

        } else {
          for (var j = 0; j < 52; j++) {
            cardsMemoString += "<img src='Card images " + cardSet + "/" + cardList[i][j]["cs"] + getValueName(cardList[i][j]["cv"]) + ".png' class='cardMemoFan " + skin + "cardMemoFan' id='imgMemoFan" + (i * 52 + j) + "' onClick='moveFocusCardsMemo(" + (i * 52 + j) + ")'>";
          }
        }

        cardsMemoString += "</div>";


        //
        cardsMemoString += "</div>";



      }

      if (skin.indexOf("analogue") > -1) {
        document.getElementById("analogueCardsMemoContentDiv").innerHTML = cardsMemoString
      } else {
        document.getElementById("memoContentDiv").innerHTML = cardsMemoString
      }
      //***USE THIS INSTEAD FOR FINISH BUTTON***
      //document.getElementById("memoContentDiv").innerHTML = cardsMemoString + "<br /><button class='btn btn-primary finishBtn' onclick='finishMemo();'>Finish</button>";





      //go to first digits
      moveFocusCardsMemo(0);

      //set current position
      curPos = 0;
      curPage = 0;

      ////fan cards out
      if (skin.indexOf("analogue") > -1) {
        console.log("analogue");
        //fan memo cards out
        var cardsMF = document.getElementsByClassName("cardMemoFan");



        for (let j = 0; j < cardsMF.length; j++) {

          cardsMF[j].style.transform = "rotate(0deg)";
        }

        if (cardsLeftToRight) {
          for (let j = 0; j < cardsMF.length; j++) {
            cardsMF[j].style.transform = "rotate(" + ((j % 52) * 1) + "deg)";
          }
        } else {
          for (let j = cardsMF.length - 1; j >= 0; j--) {
            cardsMF[cardsMF.length - 1 - j].style.transform = "rotate(" + ((j % 52) * 1) + "deg)";
            cardsMF[cardsMF.length - 1 - j].style.zIndex = j;
          }
        }
      } else {
        console.log("digital");
        var cardsM = document.getElementsByClassName("cardMemoFan");
        var w = document.getElementById("memoContentDiv").clientWidth;
        var offset = w / 52 + 30;
        console.log(offset);


        if (cardsLeftToRight) {
          for (let i = 0; i < cardsM.length; i++) {

            cardsM[i].style.transform = "translateX(-" + (offset * (i % 52) + 100) + "px)";

          }
        } else {
          //	var fanDivs = document.getElementsByClassName(skin + "cardMemoFanDiv");
          //	for (let i = 0; i < fanDivs.length; i++) {
          //		fanDivs[i].style.flexDirection = "row-reverse";
          //	}

          for (let i = cardsM.length - 1; i >= 0; i--) {
            //	cardsM[i].style.position = "absolute";
            //		cardsM[i].style.left = (offset*(cardsM.length-1-i % 52) + 100) + "px";
            cardsM[i].style.transform = "translateX(-" + (offset * (i % 52) + 100) + "px)";
            //	cardsM[i].style.transform = "translateX(-" + (offset * ((cardsM.length-1-i) % 52) + 100) + "px)";
            //	cardsM[51-i].style.zIndex = 51-i;
            //		cardsM[51-i].style.position = "absolute";
          }

          //				for (let i = 0; i < cardsM.length; i++) {

          //cardsM[51-i].style.transform = "";
          //cardsM[51-i].style.position  = "absolute";
          //cardsM[51-i].style.left = ((offset-2)*(i % 52) - 140) + "px";

          //}
        }


      }



      r = document.getElementById(skin + 'MemoTimeInner');

      if (!test) {

        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);


          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {
            memoTimeTaken = memoTime * 1000;
            finishMemo();
          }
          //Otherwise repeat this function
          else {
            if (!ended) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {
        //If Enter is pressed (in speed cards this is allowed even if we are in competition mode)
        if (e.key == "Enter" && !ended && (!competitionMode || currentDiscipline == "SC" || test)) {
          if (!test) memoTimeTaken = Date.now() - memoStart;
          //in speed cards we just finish memo without confirming
          if (currentDiscipline == "SC" || test) {
            finishMemo(test);
          } else {
            confirmFinishMemo(test);
          }
        }

        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          if (cardsLeftToRight) {
            moveNextCardsMemo();
          } else {
            movePreviousCardsMemo();
          }
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          if (cardsLeftToRight) {
            movePreviousCardsMemo();
          } else {

            moveNextCardsMemo();
          }
        }



        //if , is pressed, previous page
        if (e.key == ',' && !ended) {

          if (curPage > 0) {
            moveFocusCardsMemo(52 * (curPage - 1));
            //if (curPage>0) displayPage(curPage-1);
            doFlash();
          }
        }


        //if . is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < amount - 1) {
            moveFocusCardsMemo(52 * (curPage + 1));
            doFlash();
          }

        }

        //if up arrow is pressed, restart deck
        if (e.key == 'ArrowUp' && !ended) {

          moveFocusCardsMemo(52 * (curPage));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusCardsMemo(0);
        }
      };

    }

    function showBlank() {
      //remove cards from big cards area
      document.getElementById('bigCards' + curPage).innerHTML = "";

      //show previously hidden cards in fan
      var oldFirstOfGroup = curPos - (curPos % 52 % grouping)
      for (i = oldFirstOfGroup; i < oldFirstOfGroup + grouping; i++) {
        if (i < amount * 52) {
          document.getElementById("imgMemoFan" + i).style.visibility = "visible";
        }
      }

      //set flag
      showingBlank = true;
    }

    /*
    function doFlash() {
        if (skin.indexOf("analogue")>-1) {
            $('#memoBox').addClass('flash');
                    setTimeout(function() {
                        $('#memoBox').removeClass('flash');
                    }, 500);
        } else {
        $('#memoBox').addClass('flash');
                    setTimeout(function() {
                        $('#memoBox').removeClass('flash');
                    }, 500);
        }
    }*/

    function doFlash() {
      if (skin.indexOf("analogue") > -1) {
        $('#memoBox').addClass('flash');
        setTimeout(function () {
          $('#memoBox').removeClass('flash');
        }, 500);
      } else {
        $('#memoBox').addClass('bigflash');
        setTimeout(function () {
          $('#memoBox').removeClass('bigflash');
        }, 1000);
      }
    }


    function moveFocusCardsMemo(newPos) {

      //*show previously hidden cards in fan
      var oldFirstOfGroup = curPos - (curPos % 52 % grouping)
      for (i = oldFirstOfGroup; i < oldFirstOfGroup + grouping; i++) {
        if (i < amount * 52) {
          document.getElementById("imgMemoFan" + i).style.visibility = "visible";
        }
      }

      //get first of new grouping
      var firstOfGroup = newPos - (newPos % 52 % grouping);


      //get new page

      var newPage = Math.floor(newPos / 52);
      if (newPage != curPage || curPos == 0) {


        //show/hide correct pages
        for (var i = 0; i < amount; i++) {
          if (i == newPage) {
            document.getElementById("page" + i).style.display = "block";
            if (amount > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i).style.display = "none";
            if (amount > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelink";
            }
          }
        }
        curPage = newPage;
      }
      if (curPage <= amount) {

        //set new pos to first in group - if user has clicked on a card or new page, need to only highlight from first in group
        newPos = firstOfGroup;


        //Show group in bigCards
        var groupString = "";
        if (cardsLeftToRight) {
          for (var j = newPos % 52; j < newPos % 52 + grouping; j++) {
            if (j < 52) {
              //offset should increase by cardOffsetBig every time
              var offset = (j - newPos % 52) * cardOffsetBig;

              groupString += "<img src='Card images " + cardSet + "/" + cardList[curPage][j]["cs"] + getValueName(cardList[curPage][j]["cv"]) + ".png' class='" + skin + "cardImgBig'  style='left:50%;margin:0 0 0 " + offset + "px' id='imgMemo" + (curPage * 52 + j) + "' onClick='moveFocusCardsMemo(" + (curPage * 52 + j) + ")'>";
            }
          }
        } else {
          for (var j = newPos % 52 + grouping - 1; j >= newPos % 52; j--) {
            if (j < 52) {
              //offset should increase by cardOffsetBig every time
              var offset = -(j - (newPos % 52 + grouping - 1)) * cardOffsetBig;

              groupString += "<img src='Card images " + cardSet + "/" + cardList[curPage][j]["cs"] + getValueName(cardList[curPage][j]["cv"]) + ".png' class='" + skin + "cardImgBig'  style='z-index:" + (51 - j) + ";left:50%;margin:0 0 0 " + offset + "px' id='imgMemo" + (curPage * 52 + j) + "' onClick='moveFocusCardsMemo(" + (curPage * 52 + j) + ")'>";
            }
          }
        }
        document.getElementById('bigCards' + curPage).innerHTML = groupString;

        //*hide cards in fan
        for (i = firstOfGroup; i < firstOfGroup + grouping; i++) {
          if (i < amount * 52) {
            document.getElementById("imgMemoFan" + i).style.visibility = "hidden";
          }
        }


        curPos = newPos;
      }


    }

    function moveNextCardsMemo() {
      if (!ended) {

        if (curPos + grouping >= amount * 52) {
          //reached end
          //for speed cards, finish memo if "end on double click" is not selected
          if (currentDiscipline === "SC" && !document.getElementById("chkDblToEnd").checked) {
            memoTimeTaken = Date.now() - memoStart;
            finishMemo();
          }

          //for speed cards, if need double press, check for a double press					
          if (currentDiscipline === "SC" && document.getElementById("chkDblToEnd").checked) {
            thisPressTime = new Date();
            //   console.log("a press at: " + thisPressTime)
            //  console.log(thisPressTime - lastPressTime)
            if (thisPressTime - lastPressTime <= delta) {
              thisPressTime = 0;
              memoTimeTaken = Date.now() - memoStart;
              finishMemo();
            }
            lastPressTime = thisPressTime;
          }

        }
        else {
          if ((curPos + grouping) % 52 < curPos % 52) {
            //moving to next deck
            if (!showingBlank) {
              showBlank();
            } else {
              showingBlank = false;
              moveFocusCardsMemo(52 * (curPage + 1));
              doFlash();
            }

            //moveFocusCardsMemo(52 * (curPage + 1));
            //doFlash();
          } else {
            //just moving to next group
            moveFocusCardsMemo(curPos + grouping);
          }
        }
      }
    }

    function movePreviousCardsMemo() {
      if (!ended) {

        if (curPos - grouping >= 0) {
          if ((curPos - grouping) % 52 > curPos % 52) {
            moveFocusCardsMemo(52 * (curPage - 1));
            doFlash();
          } else {
            moveFocusCardsMemo(curPos - grouping);
          }
        } /*else {
				//DELETED BECAUSE WHEN WE HAVE RIGHT TO LEFT, IT'S STILL "NEXT" AND CURPOS IS NOT 0 AT EXTREME LEFT
	         	//reached end
				//for speed cards, finish memo if "end on double click" is not selected
				if (currentDiscipline === "SC" && !cardsLefToRight && !document.getElementById("chkDblToEnd").checked) {
					memoTimeTaken = Date.now() - memoStart;
					finishMemo();
				}


			}*/
      }
    }


    function getValueName(strValue) {
      var strValueName = "";

      switch (strValue) {
        case "A":
          strValueName = "01";
          break;
        case "J":
          strValueName = "11";
          break;
        case "Q":
          strValueName = "12";
          break;
        case "K":
          strValueName = "13";
          break;
        default:
          strValueName = strValue;
          if (strValueName.length == 1) {
            strValueName = "0" + strValueName;
          }
      }


      return strValueName;

    }

    function startImagesMemo(test) {


      if (resuming) {
        //restore image list
        actualImageArray = JSON.parse(localStorage.getItem("preloadedData")).map(el => {return {src: "IAM Images/" + el}});
        imageArray = JSON.parse(localStorage.getItem("preloadedData"));
        answerArray = JSON.parse(localStorage.getItem("answerArray"));
        blnImageSkip = localStorage.getItem("blnImageSkip");
      } else {

        blnImageSkip = document.getElementById("chkSkipFinalImage").checked;
        localStorage.setItem("blnImageSkip", blnImageSkip);
      }
      //set ended to false
      ended = false;

      var imagesMemoString = "";
      curPos = 0;
      curPage = 0;

      //work out how many pages needed (480 digits per page)
      numberOfPages = Math.ceil(amount / imagesPerPage);


      //add the page menu if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusImagesMemo(" + imagesPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/><br />";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }



      //add the memo content
      for (var i = 0; i < numberOfPages; i++) {

        imagesMemoString += "<div id='page" + i + "'><table class='imageTable' id='memoTable" + i + "'>";
        var spacer;



        for (var j = 0; j < imagesPerPage; j++) {
          //if we haven't reached the end
          if (i * imagesPerPage + j < amount) {
            //add row num if needed
            if (j % 5 == 0) {
              imagesMemoString += "<tr><td class='imageRowNumCell'>" + (Math.floor((i * imagesPerPage / 5) + j / 5) + 1) + "</td>";
            }


            //add the next image and a number below it
            //	imagesMemoString += "<td id='tdMemo" + Number(i*imagesPerPage+j) + "'><table><tr><td><img class='imageClass' id='imgMemo" + Number(i*imagesPerPage+j) + "'  src='IAM Images/" + imageArray[i*imagesPerPage+j] + "' height=80></td></tr><tr><td class='imageNum'>" + ((j % 5 )+ 1) + "</td></tr></table></td>";

            //imagesMemoString += "<td id='tdMemo" + Number(i*imagesPerPage+j) + "'><span class='imageNum'>" + ((j % 5 )+ 1) + "&nbsp;</span><img class='imageClass' id='imgMemo" + Number(i*imagesPerPage+j) + "'  onclick='moveFocusImagesMemo(" + Number(i*imagesPerPage+j) + ")' src='" + actualImageArray[i*imagesPerPage+j].src + "' height=80></td>";
            //we no longer want image num next to image ***
            imagesMemoString += "<td id='tdMemo" + Number(i * imagesPerPage + j) + "'><img class='imageClass' id='imgMemo" + Number(i * imagesPerPage + j) + "'  onclick='moveFocusImagesMemo(" + Number(i * imagesPerPage + j) + ")' src='" + actualImageArray[i * imagesPerPage + j].src + "' height=80></td>";

            //close the row if needed
            if ((j + 1) % 5 == 0) {
              imagesMemoString += "</tr><tr><td colspan='6' height='20px'></td></tr>";
            }
          }
        }
        imagesMemoString += "</table></div>";
      }

      document.getElementById("memoContentDiv").innerHTML = imagesMemoString



      //go to first image
      moveFocusImagesMemo(0);

      //set current position
      curPos = 0;
      curPage = 0;

      r = document.getElementById(skin + 'MemoTimeInner');

      if (!test) {
        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);


          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {
            memoTimeTaken = memoTime * 1000;
            finishMemo();
          }
          //Otherwise repeat this function
          else {
            if (!ended) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {
        //If Enter is pressed 
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            memoTimeTaken = Date.now() - memoStart;
            confirmFinishMemo(test);
          } else {
            finishMemo(test);
          }


        }

        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          moveNextImagesMemo();
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          movePreviousImagesMemo();
        }


        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveUpImagesMemo();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveDownImagesMemo();
        }

        //if [ is pressed, previous page
        if (e.key == ',' && !ended) {

          if (curPage > 0) moveFocusImagesMemo(imagesPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < numberOfPages - 1) moveFocusImagesMemo(imagesPerPage * (curPage + 1));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusImagesMemo(0);
        }
      };

    }


    function moveNextImagesMemo() {
      //check if skipping and if this is the final image
      if (curPos + 1 < amount) {
        if (blnImageSkip && ((curPos + 2) % 5 == 0)) {
          moveFocusImagesMemo(curPos + 2);
        } else {
          moveFocusImagesMemo(curPos + 1);
        }
      }

    }

    function movePreviousImagesMemo() {
      //check if skipping and if this is the final image
      if (curPos > 0) {
        if (blnImageSkip && ((curPos) % 5 == 0)) {
          moveFocusImagesMemo(curPos - 2);
        } else {
          moveFocusImagesMemo(curPos - 1);
        }
      }
    }

    function moveUpImagesMemo() {
      //check if skipping and if this is the final image
      if (curPos >= 5) {

        moveFocusImagesMemo(curPos - 5);

      }
    }

    function moveDownImagesMemo() {
      //check if skipping and if this is the final image
      if (curPos + 5 < amount) {

        moveFocusImagesMemo(curPos + 5);

      }
    }

    function moveFocusImagesMemo(newPos) {
      //get new page
      var newPage = Math.floor(newPos / imagesPerPage);
      if (newPage != curPage || curPos == 0) {



        //show/hide correct pages
        for (var i = 0; i < numberOfPages; i++) {
          if (i == newPage) {
            document.getElementById("page" + i).style.display = "block";
            if (numberOfPages > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i).style.display = "none";
            if (numberOfPages > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelink";
            }
          }
        }
        curPage = newPage;
      }

      if (newPos < amount) {
        document.getElementById("imgMemo" + (curPos)).classList.remove(skin + "imagesSelected");

        document.getElementById("imgMemo" + (newPos)).className = skin + "imagesSelected";


        curPos = newPos;
      }

    }


    function startWordsMemo(test) {
      if (test) wordsLanguage = "";
      ended = false;

      if (resuming) {
        //restore word list
        wordList = JSON.parse(localStorage.getItem("correctAnswers"));
        blnFocusBox = localStorage.getItem("blnFocusBoxW");
        blnHighlightOn = localStorage.getItem("blnHighlightOnW") === 'true';
      } else {
        blnFocusBox = document.getElementById("chkFocusBox").checked;
        localStorage.setItem("blnFocusBoxW", blnFocusBox);
        blnHighlightOn = document.getElementById("chkHighlightOn").checked;
        localStorage.setItem("blnHighlightOnW", blnHighlightOn);
      }
      if (blnFocusBox && !blnHighlightOn) document.body.style.setProperty("--highlightColor", '');

      wordsPerPage = wordsPerColumn * wordColumnsPerPage;

      curPos = 0;
      curPage = 0;

      //work out how many pages needed (480 digits per page)
      numberOfPages = Math.ceil(amount / wordsPerPage);


      //add the page menu if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusWordsMemo(" + wordsPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul>";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }


      //add the memo content
      for (var i = 0; i < numberOfPages; i++) {
        //create a new page that can be hidden or shown
        var pageDiv = document.createElement("div");
        pageDiv.setAttribute("id", "page" + i);

        //create and add focus box
        if (blnFocusBox) {
          var thisPageFocusBox = document.createElement("div");
          thisPageFocusBox.className = 'focusBox focusBoxWords';
          pageDiv.appendChild(thisPageFocusBox);
        }
        //add table to hold the words
        var thisPageTable = document.createElement("table");

        if (wordsLanguageIsRToL()) {
          thisPageTable.setAttribute("class", "wordsTable tableRToL")
        } else {
          thisPageTable.setAttribute("class", "wordsTable");
        }

        //add rows with cells
        for (j = 0; j < wordsPerColumn; j++) {
          var row = document.createElement("tr");
          if (wordsLanguageIsRToL()) {

            for (k = wordColumnsPerPage - 1; k >= 0; k--) {

              var wordCell = document.createElement("td");
              var numberCell = document.createElement("td");
              var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

              if (thisIndex < wordList.length) {
                wordCell.innerHTML = wordList[thisIndex];
                numberCell.innerHTML = "&nbsp;&nbsp;." + Number(thisIndex + 1);
                numberCell.setAttribute("class", skin + "wordsNum");
                wordCell.setAttribute("id", "tdMemo" + thisIndex);
                wordCell.setAttribute("class", skin + "wordsMemo");
                wordCell.setAttribute("onclick", "moveFocusWordsMemo(" + thisIndex + ")");
              }

              row.appendChild(wordCell);
              row.appendChild(numberCell);


            }
          } else {


            for (k = 0; k < wordColumnsPerPage; k++) {
              var wordCell = document.createElement("td");
              var numberCell = document.createElement("td");
              var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

              if (thisIndex < wordList.length) {
                wordCell.innerHTML = wordList[thisIndex];
                numberCell.innerHTML = Number(thisIndex + 1) + ".&nbsp;&nbsp;";
                numberCell.setAttribute("class", skin + "wordsNum");
                wordCell.setAttribute("id", "tdMemo" + thisIndex);
                wordCell.setAttribute("class", skin + "wordsMemo");
                wordCell.setAttribute("onclick", "moveFocusWordsMemo(" + thisIndex + ")");
              }

              row.appendChild(numberCell);
              row.appendChild(wordCell);

            }
          }
          thisPageTable.appendChild(row);
        }

        pageDiv.appendChild(thisPageTable);

        document.getElementById("memoContentDiv").appendChild(pageDiv);

        //set width and height of focus box
        const focusBoxes = document.getElementsByClassName("focusBox");
        for (let i = 0; i < focusBoxes.length; i++) {
          focusBoxes[i].style.width = "100%";
          focusBoxes[i].style.height = grouping * 80 + "px";
        }
      }

      //go to first word
      moveFocusWordsMemo(0);

      //set current position
      curPos = 0;
      curPage = 0;

      //set the timer
      var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

      r = document.getElementById(skin + 'MemoTimeInner')
      if (!test) {
        //set the timer
        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);


          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {
            memoTimeTaken = memoTime * 1000;
            finishMemo();
          }
          //Otherwise repeat this function
          else if (!ended) {
            myTimer = setTimeout(f, 1000);
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
        /*	$('#overlayDiv').html('<span id="alert">Press Enter to exit test</span>');
            $("#overlayDiv").css("zIndex",2);
            $('#alert').fadeOut(2500, "linear", ()=>$("#overlayDiv").css("zIndex",-2));*/
      }

      document.onkeydown = function (e) {
        //If Enter is pressed in speed cards (during testing - for any event)
        //  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            memoTimeTaken = Date.now() - memoStart;
            confirmFinishMemo(test);
          } else {
            finishMemo(test);
          }
        }

        //if right arrow or tab pressed, move on
        if ((e.key == "ArrowRight" || (e.key == "Tab" && !e.shift.Key)) && !ended) {
          e.preventDefault();
          moveNextWordsMemo();
        }

        //if left arrow or shift-tab is pressed to go back
        if ((e.key == "ArrowLeft" || e.shiftKey && e.key == "Tab") && !ended) {
          e.preventDefault();
          movePreviousWordsMemo();
        }

        //if up arrow pressed, move up (previous)
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          movePreviousWordsMemo();
        }

        //if down arrow pressed, move down (next)
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveNextWordsMemo();
        }

        //if [ is pressed, previous page
        if (e.key == ',' && !ended) {
          if (curPage > 0) moveFocusWordsMemo(wordsPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < numberOfPages - 1) moveFocusWordsMemo(wordsPerPage * (curPage + 1));

        }


        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusWordsMemo(0);
        }
      };


    }


    /*
        function openWordsFile() {
    
            if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
                xmlhttp = new XMLHttpRequest();
            }
            else {// code for IE6, IE5
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
            xmlhttp.open("GET", "Training data/words.xml", false);
            xmlhttp.send();
            fobWordsDoc = xmlhttp.responseXML;
    
        }
    
    */

    function startDatesMemo(test) {
      if (test) datesLanguage = "";

      ended = false;
      if (!isAnalogue()) {
        document.getElementById("memoBox").classList.remove(skin + "memoHeight");
        document.getElementById("memoBox").classList.add(skin + "memoHeightDates");
      }

      if (resuming) {
        //restore date list
        dateList = JSON.parse(localStorage.getItem("correctAnswers"));
        shuffledDateList = JSON.parse(localStorage.getItem("shuffledDateList"));

      } else if (!competitionMode) {

        //	openDatesFile();
        //		generateDatesList();

        //save date list in storage
        //	localStorage.setItem("correctAnswers", JSON.stringify(dateList));
      }

      curPos = 0;
      curPage = 0;
      //work out how many pages needed (480 digits per page)
      numberOfPages = Math.ceil(amount / datesPerPage);


      //add the page menu if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusDatesMemo(" + datesPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/>";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }


      //add the memo content
      for (var i = 0; i < numberOfPages; i++) {
        //create a new page that can be hidden or shown
        var pageDiv = document.createElement("div");
        pageDiv.setAttribute("id", "page" + i);

        //add table to hold the dates
        var thisPageTable = document.createElement("table");
        if (datesLanguageIsRToL()) {
          thisPageTable.setAttribute("class", "datesTable tableRToL");
        } else {
          thisPageTable.setAttribute("class", "datesTable");
        }

        //add rows with cells
        for (j = 0; j < datesPerPage; j++) {
          var row = document.createElement("tr");

          var yearCell = document.createElement("td");
          var eventCell = document.createElement("td");
          var thisIndex = i * datesPerPage + j;

          if (thisIndex < dateList.length) {
            yearCell.innerHTML = dateList[thisIndex].year;
            eventCell.innerHTML = dateList[thisIndex].event;
            yearCell.setAttribute("class", skin + "datesYearMemo");
            eventCell.setAttribute("class", skin + "datesMemo");
            row.setAttribute("id", "trMemo" + thisIndex);

          }
          if (datesLanguageIsRToL()) {
            row.appendChild(eventCell);
            row.appendChild(yearCell);
          } else {
            row.appendChild(yearCell);
            row.appendChild(eventCell);
          }

          thisPageTable.appendChild(row);
        }

        pageDiv.appendChild(thisPageTable);

        document.getElementById("memoContentDiv").appendChild(pageDiv);
      }

      //go to first word
      moveFocusDatesMemo(0);

      //set current position
      curPos = 0;
      curPage = 0;

      r = document.getElementById(skin + 'MemoTimeInner')

      if (!test) {
        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);

          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {



            memoTimeTaken = memoTime * 1000;

            finishMemo();
          }
          //Otherwise repeat this function
          else if (!ended) {
            myTimer = setTimeout(f, 1000);
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {
        //If Enter is pressed in speed cards (during testing - for any event)
        //  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            memoTimeTaken = Date.now() - memoStart;
            confirmFinishMemo(test);
          } else {
            finishMemo(test);
          }
        }

        //if right or down arrow or tab pressed, move on
        if ((e.key == "ArrowRight" || e.key == "ArrowDown" || (e.key == "Tab" && !e.shiftKey)) && !ended) {
          e.preventDefault();

          moveNextDatesMemo();
        }


        //if left or up arrow or shift-tab is pressed to go back
        if ((e.key == "ArrowLeft" || e.key == "ArrowUp" || e.shiftKey && e.key == "Tab") && !ended) {
          e.preventDefault();
          movePreviousDatesMemo();
        }


        //if [ is pressed, previous page
        if (e.key == ',' && !ended) {

          if (curPage > 0) moveFocusDatesMemo(datesPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < numberOfPages - 1) moveFocusDatesMemo(datesPerPage * (curPage + 1));

        }


        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusDatesMemo(0);
        }
      };

    }

    /*
 
    function openDatesFile(language) {
 
        if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
            xmlhttp = new XMLHttpRequest();
        }
        else {// code for IE6, IE5
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        xmlhttp.open("GET", "Training data/dates-" + language + "-training.xml", false);
        xmlhttp.send();
        fobDatesDoc = xmlhttp.responseXML;
 
    }*/


    function removeFullStop(str) {
      if (str.endsWith('.')) {
        return str.slice(0, -1);
      }
      return str;
    }

    function addYearsForDates() {
      //Alert if not enough in our database
      if (dateList.length < amount) {
        alert("not enough dates in database");
        return;
      }

      var years = [];

      //add all years to an array
      for (var i = 1000; i <= 2099; i++) {
        years.push(i);
      }

      //shuffle
      shuffle(years);

      //add years to the existing events array
      for (var i = 0; i < amount; i++) {
        dateList[i].year = years[i];
      }

      //truncate to right amount
      dateList = dateList.splice(0, amount);

      //shuffle again
      shuffle(dateList);
    }


    /*
        function generateDatesList() {
            dateList = [];
            var date_events = SelectNodes(fobDatesDoc, "//date_event");
    
            //Alert if not enough in our database
            if (date_events.length < amount) {
                alert("not enough dates in database");
                return;
            }
    
            //add all years to the array
            for (var i = 1000; i <= 2099; i++) {
                dateList.push({ year: i });
            }
    
            //shuffle
            shuffle(dateList);
    
            //add events to the array
            for (var i = 0; i < amount; i++) {
                dateList[i].event = date_events[i].textContent;
            }
    
            //truncate to right amount
            dateList = dateList.splice(0, amount);
    
            //shuffle again
            shuffle(dateList);
        }
    */
    function preloadDatesLanguages() {
      var rawFile = new XMLHttpRequest();
      var cacheBuster = new Date().getTime(); // Creates a unique timestamp

      if (competitionMode && !competitionTestMode) {
        rawFile.open("GET", "Data_" + compName + "/Dates/dates_languages.txt?v=" + cacheBuster, false);
      } else {
        rawFile.open("GET", "Training data/Dates/dates_languages.txt?v=" + cacheBuster, false);
      }

      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var datesLangText = rawFile.responseText;
            datesLangText.trim();
            var txtArray = datesLangText.split('\n');

            for (var i = 0; i < txtArray.length; i++) {
              if (txtArray[i] !== "") {
                var sel = document.getElementById("selDatesLanguage");
                var option = document.createElement("option");
                option.value = txtArray[i];
                option.text = txtArray[i];
                sel.add(option);
              }
            }

            datesLanguagesPreloaded = true;
          }
        }
      }
      rawFile.send(null);
    }

    function preloadWordsLanguages() {

      var rawFile = new XMLHttpRequest();
      if (competitionMode && !competitionTestMode) {
        rawFile.open("GET", "Data_" + compName + "/Words/words_languages.txt", false);
      } else {
        rawFile.open("GET", "Training data/Words/words_languages.txt", false);
      }
      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var wordsLangText = rawFile.responseText;
            wordsLangText.trim();
            var txtArray = wordsLangText.split(/\r?\n/);

            for (var i = 0; i < txtArray.length; i++) {
              if (txtArray[i] !== "") {
                var sel = document.getElementById("selWordsLanguage");
                var option = document.createElement("option");
                option.value = txtArray[i];
                option.text = txtArray[i];
                sel.add(option);
              }
            }

            wordsLanguagesPreloaded = true;
          }
        }
      }
      rawFile.send(null);





    }


    function preloadNamesCharsets() {

      $('#selNamesCharset')
        .find('option')
        .remove()
        .end()

      var rawFile = new XMLHttpRequest();
      rawFile.open("GET", "Data_" + compName + "/Names/names_charsets.txt", false);
      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var namesCharsetText = rawFile.responseText;
            namesCharsetText.trim();
            var txtArray = namesCharsetText.split('\n');

            for (var i = 0; i < txtArray.length; i++) {
              if (txtArray[i] !== "") {
                var sel = document.getElementById("selNamesCharset");
                var option = document.createElement("option");
                option.value = txtArray[i];
                option.text = txtArray[i];
                sel.add(option);
              }
            }
          }

          namesCharsetsPreloaded = true;
        }
      }
      rawFile.send(null);





    }


    function readDatesFile(language, test = false) {
      var cacheBuster = new Date().getTime(); // Creates a unique timestamp

      document.getElementById("btnStartMemoCountdown").innerText = "Loading data... Please wait";
      var rawFile = new XMLHttpRequest();
      if (competitionMode && !test && !competitionTestMode) {
        rawFile.open("GET", "Data_" + compName + "/Dates/dates_" + language + ".txt?v=" + cacheBuster, true);
      } else {
        rawFile.open("GET", "Training data/Dates/dates_" + language + ".txt?v=" + cacheBuster, false);
      }

      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var datesText = rawFile.responseText;
            datesText.trim();
            var txtArray = datesText.split('\n');
            console.log(txtArray);
            dateList = [];
            for (var i = 0; i < txtArray.length; i++) {
              if (txtArray[i] !== "") {
                if (competitionMode && !test && !competitionTestMode) {
                  if (txtArray[i][0] == '[') {

                    //The last item is the shuffle order
                    shuffledDateList = [];
                    var shuffleOrder = JSON.parse(txtArray[i]);
                    //*** error point if there is no shuffleOrder in the file or if shuffleOrder has too many entries

                    //if no shuffleOrder or it's too short, make one on the spot
                    if (shuffleOrder.length == 0 || shuffleOrder.length < i) {
                      var j = 0, len = i, next;
                      //make a (memo) sort order for the events
                      while (j < len) shuffleOrder[j] = j++; //[0,1,2...]
                      shuffleOrder.sort(function () {return Math.random() - .5});

                    }

                    //if shuffleOrder too long, remove items equal to i or higher
                    if (shuffleOrder.length > i) {
                      shuffleOrder = shuffleOrder.filter(el => el < i);
                    }



                    //Make a shuffled date list object by arranging dateList in that order				

                    for (i = 0; i < shuffleOrder.length; i++) {
                      next = shuffleOrder[i];
                      shuffledDateList.push(dateList[next]);
                    }

                    //save it
                    localStorage.setItem("shuffledDateList", JSON.stringify(shuffledDateList));

                    break;
                  }

                  elements = txtArray[i].split('\t');
                  dateList.push({year: elements[0].trim(), event: elements[1].trim()});




                } else {
                  dateList.push({event: txtArray[i].trim()});
                }

              }
            }

            //if organiser didn't provide enough dates, change the amount
            if (competitionMode && !test) amount = dateList.length;

            //Remove full stops
            dateList = dateList.map(el => ({...el, event: removeFullStop(el.event)}));


            //shuffle if we are in training mode or test
            if (!competitionMode || test || competitionTestMode) shuffle(dateList);

            console.log(dateList);

            //maybe call these few lines function donePreloading()
            if (competitionMode && !test) {
              document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
              document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
              document.getElementById("btnStartMemoCountdown").innerText = "Start";

              document.getElementById("btnPreload").innerText = "Preload data";
            }

            if (!test) {
              localStorage.setItem("preloadedData", JSON.stringify(dateList));
              localStorage.setItem("correctAnswers", JSON.stringify(dateList));
              preloaded = true;
            }
          }
        }
      }
      rawFile.send(null);




    }

    function readWordsFile(language, test = false) {
      document.getElementById("btnStartMemoCountdown").innerText = "Loading data... Please wait";
      var rawFile = new XMLHttpRequest();
      if (competitionMode && !test && !competitionTestMode) {
        rawFile.open("GET", "Data_" + compName + "/Words/words_" + language + ".txt", true);
      } else {
        rawFile.open("GET", "Training data/Words/words_" + language + ".txt", false);
      }
      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var wordsText = rawFile.responseText;
            wordsText.trim();
            var txtArray = wordsText
              .split(/\r\n|\n|\r/)   // Split on any line ending: \r\n, \n, or \r
              .map(word => word.trim()) // Remove extra whitespace around each word
              .filter(word => word !== ""); // Remove any empty lines
            wordList = [];
            wordList = [];
            for (var i = 0; i < txtArray.length; i++) {


              if (txtArray[i] !== "") {
                if (!competitionMode || test || competitionTestMode) {
                  elements = txtArray[i].split('\t');
                  if (elements.length < 2) {
                    console.log(elements)
                  } else wordList.push({word: elements[0].trim(), type: elements[1].trim()});
                } else {
                  wordList.push(txtArray[i].trim());
                }

              }
            }

            //if organiser didn't provide enough words, change the amount
            if (competitionMode && !test && !competitionTestMode) amount = wordList.length;


            document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
            document.getElementById("btnStartMemoCountdown").innerText = "Start";

            document.getElementById("btnPreload").innerText = "Preload data";

            if (!test) {
              localStorage.setItem("preloadedData", JSON.stringify(wordList));
              localStorage.setItem("correctAnswers", JSON.stringify(wordList));
              preloaded = true;
            }
          }
        }
      }
      rawFile.send(null);




    }

    function readNamesFile(charset) {
      //This function is used in competition when we are reading in the names file for a specific language

      //Disable Start button and remove glow
      document.getElementById("btnStartMemoCountdown").innerText = "Loading images... Please wait";
      document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");

      //Open the names file for the selected character set
      var rawFile = new XMLHttpRequest();
      rawFile.open("GET", "Data_" + compName + "/Names/names_" + charset + ".txt", true);




      rawFile.onload = function () {
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status == 0) {
            var namesText = rawFile.responseText;

            namesText.trim();
            var namesArray = JSON.parse(namesText);
            nameList = namesArray[0];


            //The last item is the shuffle order
            shuffledNameList = [];
            var shuffleOrder = namesArray[1];


            //Make a shuffled name list object by arranging nameList in that order				
            //shuffledNameList = shuffle(nameList);
            for (i = 0; i < shuffleOrder.length; i++) {
              nameList[i].imageURL = "Data_" + compName + "/Names/" + nameList[i].imageURL;
              next = shuffleOrder[i];
              shuffledNameList.push(nameList[next]);
            }

            //save it
            localStorage.setItem("shuffledNameList", JSON.stringify(shuffledNameList));



          }

          //truncate names list if it exceeds the specified amount for the discipline
          amount = lookupProperty(currentDiscipline, "amount");
          facesAmount = Math.ceil(amount / 2);

          //Alert if not enough in our database
          //if (nameList.length < facesAmount) {
          //allowed a slightly lower amount to be used in competitions
          //		alert("not enough names in database");
          //				goToSettings();
          //			}

          if (nameList.length > facesAmount) {
            //Truncate array to just amount required (to take into account the odd one or two left over from Math.ceil because cannot divide exactly by 6)
            nameList = nameList.splice(0, facesAmount);
          }


          //if organiser didn't provide enough faces, change the amount
          if (nameList.length < facesAmount) {
            amount = nameList.length * 2;
            facesAmount = Math.ceil(amount / 2);
          }

          //save this preloadedData in case we are going to look at test page
          localStorage.setItem("preloadedData", JSON.stringify(nameList));

          //preload face images					
          var imagesLoaded = 0;
          actualImages = [];

          for (let im = 0; im < nameList.length; im++) {

            actualImages[im] = new Image();
            actualImages[im].onload = function () {
              console.log("images loaded: " + ++imagesLoaded);
              if (imagesLoaded == nameList.length) {

                document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
                document.getElementById("btnStartMemoCountdown").innerText = "Start";
                document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

                document.getElementById("btnPreload").innerText = "Preload data";

                preloaded = true;
              }
            };


            setTimeout(function () {
              actualImages[im].src = nameList[im].imageURL;
            }, 500);


          }

        }

      }


      rawFile.send(null);




    }


    function moveFocusDatesMemo(newPos) {
      if (newPos < amount) {
        //remove highlight from existing date
        document.getElementById("trMemo" + curPos).classList.remove(skin + "datesSelected");


        //get new page
        var newPage = Math.floor(newPos / datesPerPage);
        if (newPage != curPage || curPos == 0) {



          //show/hide correct pages
          for (var i = 0; i < numberOfPages; i++) {
            if (i == newPage) {
              document.getElementById("page" + i).style.display = "block";
              if (numberOfPages > 1) {
                //highlight this page tab
                document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
              }
            }
            else {
              document.getElementById("page" + i).style.display = "none";
              if (numberOfPages > 1) {
                //un-highlight this page tab
                document.getElementById("page" + i + "tablink").className = skin + "pagelink";
              }
            }
          }
          curPage = newPage;
        }
        document.getElementById("trMemo" + newPos).classList.add(skin + "datesSelected");

        curPos = newPos;
      }
    }

    function moveNextDatesMemo() {
      if (!ended && curPos < amount - 1) {
        moveFocusDatesMemo(curPos + 1);
      }
    }

    function movePreviousDatesMemo() {
      if (curPos > 0 && !ended) {
        moveFocusDatesMemo(curPos - 1);
      }
    }


    function startDatesRecall() {
      ended = false;

      if (!isAnalogue()) {
        document.getElementById("recallBox").classList.remove(skin + "memoHeight");
        document.getElementById("recallBox").classList.add(skin + "memoHeightDates");
      }

      if (resuming) {
        amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
        numberOfPages = Math.ceil(amount / datesPerPage); //added in case went straight to recall

        //restore data
        dateList = JSON.parse(localStorage.getItem("correctAnswers"));
        datesLanguage = localStorage.getItem("datesLanguage")
        shuffledDateList = JSON.parse(localStorage.getItem("shuffledDateList"));
      } else {
        if (!competitionMode || competitionTestMode) {
          //   shuffledDateList = shuffle(dateList.slice());
          shuffledDateList = shuffle(dateList); //  changed for WMC23, check this
          localStorage.setItem("shuffledDateList", JSON.stringify(shuffledDateList));
        }
      }
      //add the page links if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusDatesRecall(" + datesPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br /><br />";
        document.getElementById("menuRecallDiv").innerHTML = menuString //+ "<span id='spanShift'><span onclick='shiftDataForward()'>+</span>&nbsp;<span onclick='shiftDataBackward()'>-</span></span>";

      } else {
        document.getElementById("menuRecallDiv").innerHTML = "";
      }


      //add the recall content
      for (i = 0; i < numberOfPages; i++) {
        //create a new page that can be hidden or shown
        var pageDiv = document.createElement("div");
        pageDiv.setAttribute("id", "page" + i + "Recall");
        //add table to hold the words
        var thisPageTable = document.createElement("table");

        if (datesLanguageIsRToL()) {
          thisPageTable.setAttribute("class", "datesRecallTable tableRToL");
        } else {
          thisPageTable.setAttribute("class", "datesRecallTable");
        }
        //add rows with cells
        for (j = 0; j < datesPerPage; j++) {
          var row = document.createElement("tr");
          var thisIndex = i * datesPerPage + j;

          if (thisIndex < dateList.length) {
            var yearCell = document.createElement("td");
            var yearInput = document.createElement("input");
            var eventCell = document.createElement("td");
            yearInput.setAttribute("id", "inpRecall" + thisIndex);
            yearInput.setAttribute("size", 4);
            yearInput.setAttribute("maxlength", 4);
            eventCell.innerHTML = shuffledDateList[thisIndex].event;
            row.setAttribute("id", "trRecall" + thisIndex);
            yearInput.setAttribute("class", skin + "datesYearRecall");
            yearCell.setAttribute("class", skin + "datesRecallTD");
            eventCell.setAttribute("class", skin + "datesEventRecall");
            yearInput.thisIndex = thisIndex;
            yearInput.addEventListener("click", function (e) {
              moveFocusDatesRecall(e.target.thisIndex);
            });
            yearInput.addEventListener("dblclick", function (e) {
              toggleMark(e.target);
            });
            yearCell.appendChild(yearInput);

            if (datesLanguageIsRToL()) {

              row.appendChild(eventCell);
              row.appendChild(yearCell);
            } else {
              row.appendChild(yearCell);
              row.appendChild(eventCell);
            }
          }
          thisPageTable.appendChild(row);
        }
        pageDiv.appendChild(thisPageTable);
        document.getElementById("recallContentDiv").appendChild(pageDiv);
      }

      //***FINISH BUTTON kEpT fOr ReCall
      var button = document.createElement("button");
      button.setAttribute("class", "btnDigital finishBtn");
      button.addEventListener("click", confirmFinishRecall);
      button.innerText = "Finish";
      $("#finishBtnDiv").empty();
      document.getElementById("finishBtnDiv").appendChild(button);

      //restore data if resuming
      if (resuming) {

        restoreDatesData();

      }


      //go to first digits
      setTimeout(function () {
        moveFocusDatesRecall(0);
      }, 40);


      //display memo time
      if (memoTimeNeeded) displayMemoTime();

      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }


      //set the timer
      var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

      recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
      (function f() {
        recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
        r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
        //ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
        //r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

        //every 10 seconds, save
        if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
          saveDatesData();
        }

        //save the elapsed time every second
        localStorage.setItem("timeElapsed", recallTimeDiff);


        //When timer reaches 0, go to score display
        if (recallTimeDiff / 1e3 >= recallTime) {

          finishRecall();
        }
        //Otherwise repeat this function
        else {
          if (!ended || intermediate) {
            myTimer = setTimeout(f, 1000);
          }
        }
      })();


      document.onkeydown = function (e) {

        //If Enter is pressed
        if (e.key == "Enter" && !ended && (!competitionMode)) {
          confirmFinishRecall();
        }

        //if tab (NOT RIGHT) is pressed, move on
        if (e.key == "Tab" && !e.shiftKey && !ended) {
          e.preventDefault();
          moveNextDatesRecall();
        }


        //if shift-tab is pressed to go back (NOT LEFT) ***shift-tab not working here or memo
        if (e.shiftKey && e.key == "Tab" && !ended) {
          e.preventDefault();
          movePreviousDatesRecall();
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          movePreviousDatesRecall();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveNextDatesRecall();
        }

        //if backspace (8) is pressed and nothing in this box, go backwards
        /*
        if ((e.key == "Backspace") && !ended && document.getElementById("inpRecall" + curPos).value.length == 0) {
            e.preventDefault();
            movePreviousDatesRecall();
            document.getElementById("inpRecall" + curPos).focus();
        }
*/
        //if left arrow pressed, move left through word or (if at beginning) to previous box
        if (e.key == "ArrowLeft" && !ended) {
          //e.preventDefault();
          if (getCaretPosition(e.target) == 0) {
            e.preventDefault();
            movePreviousDatesRecall();
          }
        }


        //if right arrow pressed, move right through word or (if at end) to next box
        if (e.key == "ArrowRight" && !ended) {
          //ERROR OCCURRED HERE NOV 2023 BUT COULDN'T REPRODUCE, ADDED '?' TO VALUE IN CASE
          if (getCaretPosition(e.target) == e.target.value?.length) {
            e.preventDefault();
            if (e.target.id.indexOf("F") == -1) {
              moveNextDatesRecall();
            }
          }
        }


        //if [ is pressed, previous page
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusDatesRecall(datesPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.') {
          e.preventDefault();
          if (curPage < numberOfPages - 1) moveFocusDatesRecall(datesPerPage * (curPage + 1));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusDatesRecall(0);
        }

      };

    }


    function moveFocusDatesRecall(newPos) {

      if (newPos < amount) {
        //get current page
        curPage = Math.floor(newPos / datesPerPage);

        //show/hide correct pages
        for (var i = 0; i < numberOfPages; i++) {
          if (i == curPage) {
            document.getElementById("page" + i + "Recall").style.display = "block";
            if (numberOfPages > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i + "Recall").style.display = "none";
            if (numberOfPages > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
            }
          }
        }




      }

      if (!ended && newPos < amount) {
        document.getElementById("inpRecall" + newPos).focus();
        //	document.getElementById("inpRecall" + newPos).select();

        //un-highlight current date
        document.getElementById("inpRecall" + curPos).classList.remove(skin + "datesSelectedRecall");

        //highlight selected date

        document.getElementById("inpRecall" + newPos).classList.add(skin + "datesSelectedRecall");
      }

      curPos = newPos;

    }

    function moveNextDatesRecall() {

      //if we have reached end of list, don't move


      if (curPos < (amount - 1)) {



        moveFocusDatesRecall(curPos + 1);


      }
    }

    function movePreviousDatesRecall() {

      //if we are at start of list, don't move

      if (curPos > 0) {

        moveFocusDatesRecall(curPos - 1);


      }
    }

    const saveFaceFormatPref = () => {
      const faceFormat = document.getElementById("selFacesFormat").value;
      localStorage.setItem("facesFormat", faceFormat);
    }


    const getFacesFormat = () => {
      return document.getElementById("selFacesFormat").value || localStorage.getItem("facesFormat");
    }

    function startNamesMemo(test) {

      ended = false;

      if (resuming) {
        //restore name list
        nameList = JSON.parse(localStorage.getItem("nameList"));
        namesCharset = localStorage.getItem("namesCharset");
        facesAmount = Math.ceil(amount / 2);
      } else {
        if (!competitionMode || test || competitionTestMode) {
          assignFaceImages();
        }
        localStorage.setItem("nameList", JSON.stringify(nameList));
      }



      namesPerPage = namesPerRow * nameRowsPerPage;
      curPos = 0;

      //work out how many pages needed 
      numberOfPages = Math.ceil(facesAmount / namesPerPage);


      //add the page menu if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusNamesMemo(" + namesPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/>";
        document.getElementById("menuDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuDiv").innerHTML = "";
      }


      //add the memo content
      for (var i = 0; i < numberOfPages; i++) {
        //create a new page that can be hidden or shown
        var pageDiv = document.createElement("div");
        pageDiv.setAttribute("id", "page" + i);

        //add table to hold the names
        var thisPageTable = document.createElement("table");
        thisPageTable.setAttribute("class", "nameTable");

        //add rows with cells
        for (var j = 0; j < nameRowsPerPage; j++) {
          var faceRow = document.createElement("tr");
          var nameRow = document.createElement("tr");

          for (var k = 0; k < namesPerRow; k++) {

            var thisIndex = i * namesPerPage + j * nameRowsPerPage + k;
            console.log("adding index " + thisIndex + " to row " + j);
            var faceCell = document.createElement("td");
            var nameCell = document.createElement("td");

            if (thisIndex < nameList.length) {
              console.log("adding a face");

              faceCell.classList.add("faceMemo");
              var faceImg = document.createElement("img");
              //**debug
              if (!nameList[thisIndex]) console.log(thisIndex);
              //						faceImg.setAttribute("src", actualImages[thisIndex].src);
              faceImg.setAttribute("src", nameList[thisIndex].imageURL);

              const facesFormat = getFacesFormat();

              if (competitionMode || facesFormat === 'square') {
                //normal non-oval face settings
                faceImg.setAttribute("height", "128");
                faceImg.setAttribute("width", "128");
                //specially for GMO 2019
                //	faceImg.setAttribute("height", "137");
                //	faceImg.setAttribute("width", "114");
              } else {
                //oval face settings
                faceImg.setAttribute("height", "128");
                faceImg.setAttribute("width", "101.5");

              }


              if (namesCharset.includes("Chinese")) {
                nameCell.innerHTML = nameList[thisIndex].surname + " &nbsp;&nbsp;" + nameList[thisIndex].firstname;
              } else {
                nameCell.innerHTML = nameList[thisIndex].firstname + " " + nameList[thisIndex].surname;
              }

              nameCell.classList.add("nameMemo");
              nameCell.classList.add(skin + "nameMemo");

              faceCell.appendChild(faceImg);
              faceCell.setAttribute("id", "tdFace" + thisIndex);
              nameCell.setAttribute("id", "tdMemo" + thisIndex);

            }
            nameRow.appendChild(nameCell);
            faceRow.appendChild(faceCell);
            //the second facerow does have both faces here

          }
          thisPageTable.appendChild(faceRow);

          thisPageTable.appendChild(nameRow);
        }

        pageDiv.appendChild(thisPageTable);

        document.getElementById("memoContentDiv").appendChild(pageDiv);
      }

      //go to first word
      moveFocusNamesMemo(0);

      //set current position
      curPos = 0;



      r = document.getElementById(skin + 'MemoTimeInner');
      if (!test) {
        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
        memoStart = Date.now();
        (function f() {
          memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
          r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", memoTimeDiff);

          //When timer reaches 0, go to recall
          if (memoTimeDiff / 1e3 >= memoTime) {
            memoTimeTaken = memoTime * 1000;
            finishMemo();
          }
          //Otherwise repeat this function
          else {
            if (!ended) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
        //		$('#overlayDiv').html('<span id="alert">Press Enter to exit test</span>');
        //			$('#alert').fadeOut(2500, "linear");
      }

      document.onkeydown = function (e) {
        //If Enter is pressed{
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            memoTimeTaken = Date.now() - memoStart;
            confirmFinishMemo(test);
          } else {
            finishMemo(test);
          }
        }

        //if right arrow or tab pressed, move on
        if ((e.key == "ArrowRight" || (e.key == "Tab" && !e.shiftKey)) && !ended) {
          e.preventDefault();
          moveNextNamesMemo();
        }


        //if left arrow or shift-tab is pressed to go back
        if ((e.key == "ArrowLeft" || (e.shiftKey && e.key == "Tab")) && !ended) {
          e.preventDefault();
          movePreviousNamesMemo();
        }


        //if up arrow pressed, move back namesPerRow
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveFocusNamesMemo(curPos - namesPerRow);
        }

        //if down arrow pressed, move forward namesPerRow
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveFocusNamesMemo(curPos + namesPerRow);
        }


        //if [ is pressed, previous page
        if (e.key == ',') {

          if (curPage > 0) moveFocusNamesMemo(namesPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < numberOfPages - 1) moveFocusNamesMemo(namesPerPage * (curPage + 1));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusNamesMemo(0);
        }
      };

    }

    function openNamesFile() {

      if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp = new XMLHttpRequest();

      }
      else {// code for IE6, IE5
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
      }

      xmlhttp.open("GET", "Training data/names-" + namesCharset + ".xml", false);
      xmlhttp.setRequestHeader('Cache-Control', 'no-cache, no-store, max-age=0');
      xmlhttp.setRequestHeader('Expires', 'Thu, 1 Jan 1970 00:00:00 GMT');
      xmlhttp.setRequestHeader('Pragma', 'no-cache');
      //xmlhttp.open("GET", "Training data/names-Latin.xml", false);

      xmlhttp.send();
      fobNamesDoc = xmlhttp.responseXML;

    }

    function accent_fold(s) {
      if (!s) {return '';}
      var ret = '';
      for (var i = 0; i < s.length; i++) {
        ret += accentMap[s.charAt(i)] || s.charAt(i);
      }
      return ret;
    }

    function words_fold(s) {
      if (!s) {return '';}
      var ret = '';
      for (var i = 0; i < s.length; i++) {
        if (competitionMode && !competitionTestMode) {
          ret += wordsMap[s.charAt(i)] || s.charAt(i);
        } else {
          ret += trainingWordsMap[s.charAt(i)] || s.charAt(i);
        }
      }
      return ret;
    }

    function generateNamesandFaces(test = false) {

      nameList = [];
      if (amount % 2 != 0) amount++;
      facesAmount = Math.ceil(amount / 2);
      var regions = [
        ['English', 'Welsh', 'Scottish', 'Scottish Gaelic', 'Manx', 'American'], // region 0
        ['Albanian', 'Breton', 'Croatian', 'Czech', 'Danish', 'Dutch', 'Estonian', 'Finnish', 'French', 'German', 'Greek', 'Hungarian', 'Icelandic', 'Irish', 'Italian', 'Latvian', 'Lithuanian', 'Macedonian', 'Norwegian', 'Polish', 'Romanian', 'Russian', 'Serbian', 'Slovak', 'Slovenian', 'Swedish', 'Ukrainian'], //region 1
        ['Arabic', 'Hebrew', 'Jewish', 'Israeli', 'Persian', 'Pashto', 'Turkish', 'Egyptian'], //region 2
        ['Chinese', 'Japanese', 'Korean', 'Chinese (HK)', 'Chinese (Taiwan)', 'Manchu'], //region 3
        ['Aboriginal', 'Fijian', 'Chinese (Singapore)', 'Indonesian', 'Maori', 'Thai', 'Cambodian', 'Vietnamese', 'Filipino', 'Polynesian', 'Hawaiian', 'Malaysian', 'Samoan'], //region 4
        ['Indian', 'Indian (Kashmir)', 'Gujarati', 'Indian (Maratha)', 'Telugu', 'Armenian', 'Azerbaijani', 'Georgian', 'Nepali', 'Nepalese', 'Bengali', 'Mongolian', 'Tibetan', 'Urdu'],		//region 5
        ['African', 'Hausa', 'Yoruba', 'Kenyan', 'Nigerian', 'Igbo', 'Wolof', 'West African', 'Akan', 'Central African', 'Serer', 'Tiv', 'Ethiopian', 'Afrikaans', 'South African', 'Nguni', 'Ghanaian', 'Swahili', 'Tanzanian'], //region 6
        ['Spanish', 'Portuguese', 'Valencian', 'Basque', 'Catalan'] //region 7
      ]
      var maleNodes;
      var femaleNodes;
      var surnameNodes;
      males = [];
      females = [];
      surnames = [];
      var maleNodesFromRegion;
      var femaleNodesFromRegion;
      var surnameNodesRegion;
      var malesFromRegion;
      var femalesFromRegion;
      var surnamesFromRegion;
      var longMales = 0;
      var longFemales = 0;
      var longSurnames = 0;
      var longMalesFromRegion = [];
      var longFemalesFromRegion = [];
      var longSurnamesFromRegion = [];
      numberOfMales = Math.ceil(facesAmount / 2);
      numberOfFemales = facesAmount - numberOfMales;
      const longNameLength = namesCharset === 'Japanese' ? 5 : 8
      const facesFormat = getFacesFormat();
      const numberOfTrainingMales = facesFormat === 'square' ? numberOfTrainingMalesSquare : numberOfTrainingMalesOval;
      const numberOfTrainingFemales = facesFormat === 'square' ? numberOfTrainingFemalesSquare : numberOfTrainingFemalesOval;

      numberOfMalesFromRegion = Math.ceil(facesAmount / regions.length / 2);//Math.ceil(amount/12); //for 6 regions and then half of that		
      numberOfFemalesFromRegion = numberOfMalesFromRegion;
      numberOfSurnamesFromRegion = Math.ceil(facesAmount / regions.length);// Math.ceil(amount/6); //for 6 regions

      var longNames = (currentDiscipline == '5F') ? 12 : 24;

      //distribute long names
      for (i = 0; i < longNames; i++) {
        switch (Math.floor(Math.random() * 3)) {
          case 0:
            longMales++;
            break;
          case 1:
            longFemales++;
            break;
          case 2:
            longSurnames++;
        }
      }

      function getRegionString(num) {
        var str = "(";
        regions[num].forEach(function (el) {
          str += "nationality ='" + el + "' or ";
        });
        return str.slice(0, str.length - 4) + ")";
      }

      //do random numbers to decide what region each of the longMales, longFemales and longSurnames will be from
      var longFemaleRegions = new Array(regions.length).fill(0);
      var longMaleRegions = new Array(regions.length).fill(0);
      var longSurnameRegions = new Array(regions.length).fill(0);


      for (let i = 0; i < longMales; i++) {
        longMaleRegions[Math.floor(Math.random() * regions.length)]++;
      }
      for (let i = 0; i < longFemales; i++) {
        longFemaleRegions[Math.floor(Math.random() * regions.length)]++;
      }
      for (let i = 0; i < longSurnames; i++) {
        longSurnameRegions[Math.floor(Math.random() * regions.length)]++;
      }

      for (let i = 0; i < regions.length; i++) {
        //get names from regions
        maleNodesFromRegion = SelectNodes(fobNamesDoc, "//name[type = 'm' and " + getRegionString(i) + "]");
        console.log(maleNodesFromRegion.length);
        malesFromRegion = maleNodesFromRegion.map(function (x) {
          return bunchup(GetChildNodeValueIfExists(x, "nametext"));
        }).filter(el => el && el !== '' && el !== '\n').map(el => el.replace(/\n/g, ""));
        shuffle(malesFromRegion);
        console.log(malesFromRegion);

        //filter out long males - remove from malesFromRegion and, if longregions[i]>0, save in a new array
        console.log(malesFromRegion.length + " males from region " + i);
        malesFromRegion = malesFromRegion.filter(function (x) {
          if (longMaleRegions[i] > 0 && x.length >= longNameLength) {
            longMalesFromRegion.push(x);
          }
          return x.length < longNameLength;
        });
        console.log(malesFromRegion.length + " short males from region");

        console.log(longMalesFromRegion);
        //for 1 to longMaleRegions[i], add one (at the start) from longMalesFromRegion  and remove it from list of long names
        for (let l = 0; l < longMaleRegions[i]; l++) {
          var longMaleIndex = Math.floor(Math.random() * longMalesFromRegion.length);
          malesFromRegion.unshift(longMalesFromRegion[longMaleIndex]);
          longMalesFromRegion.splice(longMaleIndex, 1)
        }
        longMalesFromRegion = [];
        console.log(malesFromRegion.length + " final males from region " + i);
        //end of filtering part

        malesFromRegion = malesFromRegion.splice(0, numberOfMalesFromRegion);
        males = males.concat(malesFromRegion);

        femaleNodesFromRegion = SelectNodes(fobNamesDoc, "//name[type = 'f' and " + getRegionString(i) + "]");
        console.log(femaleNodesFromRegion.length);
        femalesFromRegion = femaleNodesFromRegion.map(function (x) {
          return bunchup(GetChildNodeValueIfExists(x, "nametext"));
        }).filter(el => el && el !== '' && el !== '\n').map(el => el.replace(/\n/g, ""));
        shuffle(femalesFromRegion);
        console.log(femalesFromRegion);

        //filter out long females - remove from femalesFromRegion and, if longregions[i]>0, save in a new array
        console.log(femalesFromRegion.length + " females from region " + i);
        femalesFromRegion = femalesFromRegion.filter(function (x) {
          if (longFemaleRegions[i] > 0 && x.length >= longNameLength) {
            longFemalesFromRegion.push(x);
          }
          return x.length < longNameLength;
        });

        console.log(femalesFromRegion.length + " short females from region " + i);

        console.log(longFemalesFromRegion);
        if (longFemaleRegions[i] > 0 && longFemalesFromRegion.length == 0) {
          alert("not enough long females in region " + i);
        }
        //for 1 to longFemaleRegions[i], add one (at the start) from longFemalesFromRegion  and remove it from list of long names
        for (let l = 0; l < longFemaleRegions[i]; l++) {
          var longFemaleIndex = Math.floor(Math.random() * longFemalesFromRegion.length);
          femalesFromRegion.unshift(longFemalesFromRegion[longFemaleIndex]);
          longFemalesFromRegion.splice(longFemaleIndex, 1)

        }
        longFemalesFromRegion = [];
        console.log(femalesFromRegion.length + " final females from region " + i);
        //end of filtering part

        femalesFromRegion = femalesFromRegion.splice(0, numberOfFemalesFromRegion);
        females = females.concat(femalesFromRegion);

        surnameNodesFromRegion = SelectNodes(fobNamesDoc, "//name[type = 's' and  " + getRegionString(i) + "]");
        console.log(surnameNodesFromRegion.length);
        surnamesFromRegion = surnameNodesFromRegion.map(function (x) {
          return bunchup(GetChildNodeValueIfExists(x, "nametext"));
        }).filter(el => el && el !== '' && el !== '\n').map(el => el.replace(/\n/g, ""));
        shuffle(surnamesFromRegion);
        console.log(surnamesFromRegion);

        //filter out long surnames - remove from surnamesFromRegion and, if longregions[i]>0, save in a new array
        console.log(surnamesFromRegion.length + " surnames from region " + i);
        surnamesFromRegion = surnamesFromRegion.filter(function (x) {
          if (longSurnameRegions[i] > 0 && x.length >= longNameLength) {
            longSurnamesFromRegion.push(x);
          }
          return x.length < longNameLength;
        });

        console.log(surnamesFromRegion.length + " short surnames from region " + i);

        console.log(longSurnamesFromRegion);
        //for 1 to longSurnameRegions[i], add one (at the start) from longSurnamesFromRegion, and remove it from list of long names
        for (let l = 0; l < longSurnameRegions[i]; l++) {
          var longSurnameIndex = Math.floor(Math.random() * longSurnamesFromRegion.length);
          surnamesFromRegion.unshift(longSurnamesFromRegion[longSurnameIndex]);
          longSurnamesFromRegion.splice(longSurnameIndex, 1)

        }
        longSurnamesFromRegion = [];
        console.log(surnamesFromRegion.length + " final surnames from region " + i);
        //end of filtering part

        surnamesFromRegion = surnamesFromRegion.splice(0, numberOfSurnamesFromRegion);
        surnames = surnames.concat(surnamesFromRegion);
      }
      //Western Europe
      //'English','Swedish','Basque','Spanish','Portuguese','Dutch','Italian','French','German','Catalan','Valencian','Danish','Icelandic','Norwegian','Irish','Welsh','Breton','Scottish','Scottish Gaelic','Manx'

      //Eastern Europe
      //Russian, Lithuanian, Hungarian, Greek, Finnish, Czech, Slovak, Croatian, Polish, Macedonian, Albanian, Estonian, Serbian, Slovenian, Romanian, Ukrainian

      //Africa
      //Yoruba, Kenyan, Nigerian, Igbo

      //Middle East
      //Arabic, Hebrew, Jewish, Israeli, Persian/Farsi, Pashto, Turkish

      //South-east Asia/Oceania
      //Fijian, Aboriginal, Chinese (Singapore), Indonesian, Thai, Cambodian, Vietnamese

      //Western Asia (Indo-Iranian and others)
      //Indian, Indian (Kashmir), Indian (Maratha), Mongolian, Armenian, Azerbaijani, Georgian, Nepalese

      //East Asia
      //Chinese, Japanese, Korean, Chinese (HK), Chinese (Taiwan)

      shuffle(males);
      shuffle(females);
      shuffle(surnames);

      males = facesAmount % 2 == 0 ? males.splice(0, facesAmount / 2) : males.splice(0, (facesAmount + 1) / 2);
      females = facesAmount % 2 == 0 ? females.splice(0, facesAmount / 2) : females.splice(0, (facesAmount - 1) / 2);
      surnames = surnames.splice(0, facesAmount);


      for (i = 0; i < numberOfMales; i++) {

        nameList[i] = new nameObject();
        nameList[i].imageURL = "";
        nameList[i].firstname = males[i].trim();
        nameList[i].gender = "male";

      }

      for (i = numberOfMales; i < numberOfMales + numberOfFemales; i++) {

        nameList[i] = new nameObject();
        nameList[i].imageURL = "";
        nameList[i].firstname = females[i - males.length].trim();
        nameList[i].gender = "female";

      }

      //Alert if not enough in our database
      if (nameList.length < facesAmount) {
        alert("not enough names in database");
        return;
      }


      shuffle(nameList);

      //Truncate array to just amount required (to take into account the odd one or two left over from Math.ceil because cannot divide exactly by 6)
      nameList = nameList.splice(0, facesAmount);

      //Add surnames 
      for (i = 0; i < nameList.length; i++) {


        nameList[i].surname = surnames[i].trim();


      }



      //Get numberOfMales and numberOfFemales from folder
      maleImageArray = [];
      femaleImageArray = [];
      var proposedImage;

      //Get males
      for (var i = 0; i < numberOfMales; i++) {
        proposedImage = Math.floor(Math.random() * numberOfTrainingMales) + 1;
        while (maleImageArray.indexOf(proposedImage) > -1) {
          proposedImage = Math.floor(Math.random() * numberOfTrainingMales) + 1;
        }
        maleImageArray.push(proposedImage);
      }

      console.log(maleImageArray);

      //Get females
      for (var i = 0; i < numberOfFemales; i++) {
        proposedImage = Math.floor(Math.random() * numberOfTrainingFemales) + 1;
        while (femaleImageArray.indexOf(proposedImage) > -1) {
          proposedImage = Math.floor(Math.random() * numberOfTrainingFemales) + 1;
        }
        femaleImageArray.push(proposedImage);
      }

      console.log(femaleImageArray);

      const facesFolderFemale = facesFormat === 'square' ? 'new f' : 'f';
      const facesFolderMale = facesFormat === 'square' ? 'new m' : 'm';

      const facesFileFormat = facesFormat === 'square' ? 'png' : 'jpg';

      //preload images
      var imagesLoaded = 0;
      actualImages = [];
      for (let im = 0; im < femaleImageArray.length; im++) {

        actualImages[im] = new Image();
        actualImages[im].src = "Training data/" + facesFolderFemale + "/Females (" + femaleImageArray[im] + ")." + facesFileFormat + "?" + new Date().getTime();
        //actualImageArray[im].onload = function() {console.log(imagesLoaded++)};
        actualImages[im].onload = function () {
          console.log(++imagesLoaded);
          document.getElementById("btnStartMemoCountdown").innerText = "Loading images: " + (imagesLoaded + 1) + " of " + nameList.length;
          if (!test && imagesLoaded >= nameList.length) {
            if (competitionTestMode) {
              document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
              document.getElementById("btnStartMemoCountdown").innerText = "Start";
              document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

            } else startMemoCountdown();

          }
        };
      }

      for (let im = actualImages.length; im < femaleImageArray.length + maleImageArray.length; im++) {

        actualImages[im] = new Image();
        actualImages[im].src = "Training data/" + facesFolderMale + "/Males (" + maleImageArray[im - femaleImageArray.length] + ")." + facesFileFormat + "?" + new Date().getTime();
        //actualImageArray[im].onload = function() {console.log(imagesLoaded++)};
        actualImages[im].onload = function () {
          console.log(++imagesLoaded);
          document.getElementById("btnStartMemoCountdown").innerText = "Loading images: " + (imagesLoaded + 1) + " of " + nameList.length;
          if (!test && imagesLoaded == nameList.length) {

            if (competitionTestMode) {
              document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
              document.getElementById("btnStartMemoCountdown").innerText = "Start";
              document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

            } else startMemoCountdown();

          }
        };
      }




      //Shuffle again for memo
      shuffle(nameList);


    }

    function isImageOK(img) {
      if (img.complete && img.naturalWidth == 0) {
        return false;
      }
      return true;
    }

    function bunchup(name) {
      name = name.replace(/\s\w|-\w/g, function (l) {
        return l.charAt(1).toUpperCase() + l.slice(2);
      }).replace(/[-'`~!@#$%^&*()_|+=?;:'",.<>\{\}\[\]\\\/]/gi, '');
      return name;
    }


    function assignFaceImages() {

      maleImageIndex = 0;
      femaleImageIndex = 0;

      //there are actually 32 objects in nameList with "female" but only 31 in female array, so it used first male image!

      for (i = 0; i < nameList.length; i++) {
        if (nameList[i].gender == "male") {
          nameList[i].imageURL = actualImages[femaleImageArray.length + maleImageIndex].src;
          maleImageIndex++;

        }
        else {
          nameList[i].imageURL = actualImages[femaleImageIndex].src;
          femaleImageIndex++;

        }
      }


    }

    function nameObject() {
      this.imageURL = "";
      this.firstname = "";
      this.surname = "";
      this.gender = "";
    }


    function moveFocusNamesMemo(newPos) {
      if (newPos < facesAmount && newPos >= 0) {
        //remove highlight from existing face
        //	document.getElementById("tdMemo" + curPos).classList.remove(skin + "namesSelected");
        document.getElementById("tdMemo" + curPos).classList.remove(skin + "namesSelectedRecall");
        document.getElementById("tdFace" + curPos).classList.remove(skin + "namesSelectedRecall");

        //get new page
        var newPage = Math.floor(newPos / namesPerPage);
        if (newPage != curPage || curPos == 0) {


          //show/hide correct pages
          for (var i = 0; i < numberOfPages; i++) {
            if (i == newPage) {
              document.getElementById("page" + i).style.display = "block";
              if (numberOfPages > 1) {
                //highlight this page tab
                document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
              }
            }
            else {
              document.getElementById("page" + i).style.display = "none";
              if (numberOfPages > 1) {
                //un-highlight this page tab
                document.getElementById("page" + i + "tablink").className = skin + "pagelink";
              }
            }
          }
          curPage = newPage;
        }

        document.getElementById("tdMemo" + newPos).classList.add(skin + "namesSelectedRecall");
        document.getElementById("tdFace" + newPos).classList.add(skin + "namesSelectedRecall");
        curPos = newPos;
      }
    }

    function moveNextNamesMemo() {
      if (!ended && curPos < facesAmount - 1) {
        moveFocusNamesMemo(curPos + 1);
      }
    }

    function movePreviousNamesMemo() {
      if (curPos > 0 && !ended) {
        moveFocusNamesMemo(curPos - 1);
      }
    }

    function GetChildNodeValueIfExists(pNode, pNodeName) {
      if (NodeExists(pNode, pNodeName)) {

        return pNode.getElementsByTagName(pNodeName)[0].innerHTML;
      } else {
        return "";
      }
    }

    function NodeExists(pNode, pChildNodeName) {

      for (var i = 0; i < pNode.childNodes.length; i++) {

        if (pNode.childNodes[i].nodeName == pChildNodeName) {
          return true;
        }
      }
      return false;
    }

    function SelectNodes(xmlDoc, elementPath) {
      if (document.implementation && document.implementation.createDocument) {

        var nodes = xmlDoc.evaluate(elementPath, xmlDoc, null, XPathResult.ANY_TYPE, null);
        //var results=nodes.iterateNext();

        var arrResults = [];
        var theResult = nodes.iterateNext();

        while (theResult) {
          arrResults.push(theResult);
          theResult = nodes.iterateNext();
        }
        return arrResults;
      }
    }

    function SelectSingleNode(xmlDoc, xmlNode, elementPath) {
      if (document.implementation && document.implementation.createDocument) {

        var nodes = xmlDoc.evaluate(elementPath, xmlNode, null, XPathResult.ANY_TYPE, null);
        var results = nodes.iterateNext();

        return results;
      }
    }


    function generateWordList() {

      //Set up new array
      var wordListForUse = [];

      var numberOfCNs = Math.ceil((percOfCNs / 100) * amount);
      var numberOfANs = Math.ceil((percOfANs / 100) * amount);
      var numberOfVs = Math.ceil((percOfVs / 100) * amount);

      //Get the concrete nouns
      var allnodes = wordList.slice().filter((el) => el.type.indexOf("c") > -1);
      shuffle(allnodes);
      var nodes = allnodes.slice(0, numberOfCNs);

      nodes.forEach((el) => wordListForUse.push(el.word));



      //Get the abstract nouns
      allnodes = wordList.slice().filter((el) => el.type.indexOf("a") > -1);

      shuffle(allnodes);

      counter = numberOfANs;

      //loop through nodes and add to wordList array
      for (i = 0; i < allnodes.length && counter > 0; i++) {
        var thisWord = allnodes[i].word;
        //check not already there		
        if (wordListForUse.indexOf(thisWord) == -1) {
          wordListForUse.push(thisWord);
          counter--;
        }

      }



      //Get the verbs
      allnodes = wordList.slice().filter((el) => el.type.indexOf("v") > -1);
      shuffle(allnodes);

      counter = numberOfVs;

      //loop through nodes and add to wordList array
      for (i = 0; i < allnodes.length && counter > 0; i++) {
        var thisWord = allnodes[i].word;
        //check not already there		
        if (wordListForUse.indexOf(thisWord) == -1) {
          wordListForUse.push(thisWord);
          counter--;
        }

      }


      shuffle(wordListForUse);
      wordList = wordListForUse.slice(0, amount);

    }


    /*
    function generateWordListOld() {
    
            //Clear wordList array
            wordList = [];
        	
            var databaseString = " and source='TR'";
            var numberOfCNs = Math.ceil((percOfCNs / 100) * amount);
            var numberOfANs = Math.ceil((percOfANs / 100) * amount);
            var numberOfVs = Math.ceil((percOfVs / 100) * amount);
    
            //Get the concrete nouns
            var allnodes = SelectNodes(fobWordsDoc, "//word[type='c' " + databaseString + "]");
            shuffle(allnodes);
            var nodes = allnodes.slice(0, numberOfCNs);
            //loop through nodes and add to wordList array
            for (i = 0; i < nodes.length; i++) {
                wordList.push(GetChildNodeValueIfExists(nodes[i], "wordtext"));
            }
    	
            //Get the abstract nouns
            allnodes = SelectNodes(fobWordsDoc, "//word[type='a'" + databaseString + "]");
            shuffle(allnodes);
            nodes = allnodes.slice(0, numberOfANs);
            //loop through nodes and add to wordList array
            for (i = 0; i < nodes.length; i++) {
                var thisWord = GetChildNodeValueIfExists(nodes[i], "wordtext")
                //check not already there
                var counter = numberOfANs;
                while (wordList.indexOf(thisWord) > -1) {
                    thisWord = GetChildNodeValueIfExists(allnodes[counter], "wordtext");
                    counter++;
                    if (counter == allnodes.length - 1) {
                        break;
                    }
                }
                wordList.push(thisWord);
            }
    
            //Get the verbs
            allnodes = SelectNodes(fobWordsDoc, "//word[type='v'" + databaseString + "]");
            shuffle(allnodes);
            nodes = allnodes.slice(0, numberOfVs);
            //loop through nodes and add to wordList array
            for (i = 0; i < nodes.length; i++) {
                var thisWord = GetChildNodeValueIfExists(nodes[i], "wordtext")
                //check not already there
                var counter = numberOfVs;
                while (wordList.indexOf(thisWord) > -1) {
                    thisWord = GetChildNodeValueIfExists(allnodes[counter], "wordtext");
                    counter++;
                    if (counter == allnodes.length - 1) {
                        break;
                    }
                }
                wordList.push(thisWord);
            }
    
    
            shuffle(wordList);
            wordList = wordList.slice(0, amount);
    
        }
    
    */

    function getWordList(array) {
      var wordString = "";

      document.getElementById("wordListView").style = "font-family: 'Arial', serif";
      wordString = "<table>";

      for (i = 0; i < wordList.length; i++) {
        wordString += "<tr><td>" + (i + 1) + ". " + wordList[i] + "</td></tr>";
      }
      wordString += "</table>";
      return wordString;
    }




    function moveFocusWordsMemo(newPos) {
      //get first of grouping
      var firstOfGroup = curPos - (curPos % grouping);


      //remove highlight from existing grouping
      document.getElementById("tdMemo" + firstOfGroup).className = skin + "wordsMemo";
      document.getElementById("tdMemo" + firstOfGroup).style.backgroundColor = "";
      for (var i = 1; i < grouping; i++) {
        if (firstOfGroup < wordList.length - i) {
          document.getElementById("tdMemo" + (firstOfGroup + i)).className = skin + "wordsMemo";
          document.getElementById("tdMemo" + (firstOfGroup + i)).style.backgroundColor = "";
        }

      }

      //update focus box:
      //get words that go in box
      let dataInFocus = wordList.slice(newPos, newPos + parseInt(grouping)).join("<br />");

      const focusBoxes = document.getElementsByClassName("focusBox");
      for (let i = 0; i < focusBoxes.length; i++) {
        focusBoxes[i].innerHTML = dataInFocus;
      }


      //get new page
      var newPage = Math.floor(newPos / wordsPerPage);
      if (newPage != curPage || curPos == 0) {


        //show/hide correct pages
        for (var i = 0; i < numberOfPages; i++) {
          if (i == newPage) {
            document.getElementById("page" + i).style.display = "block";
            if (numberOfPages > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i).style.display = "none";
            if (numberOfPages > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablink").className = skin + "pagelink";
            }
          }
        }
        curPage = newPage;
      }
      if (newPos < amount) {

        //update firstOfGroup
        if ((newPos == 0) || (newPos % grouping == 0)) {

          firstOfGroup = newPos;

        }
        else {
          firstOfGroup = newPos - (newPos % grouping);

        }

        //set new pos to first in group - if user has clicked on a digit or new page, need to only highlight from first in group
        newPos = firstOfGroup;



        document.getElementById("tdMemo" + (firstOfGroup)).className = skin + "wordsMemo " + skin + "wordsSelected";
        // document.getElementById("tdMemo" + (firstOfGroup)).style.backgroundColor = this[hiColour];

        for (var i = 1; i < grouping; i++) {
          if (firstOfGroup < wordList.length - i) {
            document.getElementById("tdMemo" + (Number(firstOfGroup + i))).className = skin + "wordsMemo " + skin + "wordsSelected";
            //  document.getElementById("tdMemo" + (Number(firstOfGroup + i))).style.backgroundColor = this[hiColour];
          }
        }

        curPos = newPos;
      }
    }



    function moveNextWordsMemo() {
      if (!ended && curPos + grouping < amount) {
        moveFocusWordsMemo(curPos + grouping);
      }
    }

    function movePreviousWordsMemo() {
      if (curPos >= grouping && !ended) {
        moveFocusWordsMemo(curPos - grouping);
      }
    }




    function startWordsRecall() {
      ended = false;


      if (resuming) {
        amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
        wordsPerPage = wordsPerColumn * wordColumnsPerPage;
        numberOfPages = Math.ceil(amount / wordsPerPage); //added in case went straight to recall

        //restore data
        wordList = JSON.parse(localStorage.getItem("correctAnswers"));
        wordsLanguage = localStorage.getItem("wordsLanguage")
      }

      //get colour back if switched off
      if (blnFocusBox && !blnHighlightOn) {
        hiColour = localStorage.getItem("hiColour");
        document.body.style.setProperty("--highlightColor", this[hiColour]);
      }

      //add the page links if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusWordsRecall(" + wordsPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        //  menuString += "</ul><br /><br /><br />";
        menuString += "</ul>"; //changed for WMC 2023, check
        document.getElementById("menuRecallDiv").innerHTML = menuString //+ "<span id='spanShift'><span onclick='shiftDataForward()'>+</span>&nbsp;<span onclick='shiftDataBackward()'>-</span></span>";

      } else {
        document.getElementById("menuRecallDiv").innerHTML = "";
      }


      //add the recall content
      for (i = 0; i < numberOfPages; i++) {


        //create a new page that can be hidden or shown
        var pageDiv = document.createElement("div");
        pageDiv.setAttribute("id", "page" + i + "Recall");

        //add table to hold the words
        var thisPageTable = document.createElement("table");

        if (wordsLanguageIsRToL()) {
          thisPageTable.setAttribute("class", "wordsRecallTable tableRToL")
        } else {
          thisPageTable.setAttribute("class", "wordsRecallTable");
        }

        //add rows with cells
        for (j = 0; j < wordsPerColumn; j++) {
          var row = document.createElement("tr");
          if (wordsLanguageIsRToL()) {


            for (k = wordColumnsPerPage - 1; k >= 0; k--) {
              var wordCell = document.createElement("td");
              var wordInput = document.createElement("input");

              var numberCell = document.createElement("td");
              var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

              if (thisIndex < wordList.length) {
                numberCell.innerHTML = "&nbsp;&nbsp;." + Number(thisIndex + 1);
                numberCell.setAttribute("class", skin + "wordsNum");
                wordInput.setAttribute("id", "inpRecall" + thisIndex);
                wordInput.setAttribute("class", skin + "wordsRecall");
                wordInput.thisIndex = thisIndex;
                wordInput.addEventListener("click", function (e) {
                  moveFocusWordsRecall(e.target.thisIndex);
                });
                wordInput.addEventListener("dblclick", function (e) {
                  toggleMark(e.target);
                });

                wordCell.setAttribute("class", skin + "wordsRecallTD");
                wordCell.setAttribute("id", "tdRecall" + thisIndex);
                wordCell.appendChild(wordInput);
              }


              row.appendChild(wordCell);
              row.appendChild(numberCell);

            }

          } else {

            for (k = 0; k < wordColumnsPerPage; k++) {
              var wordCell = document.createElement("td");
              var wordInput = document.createElement("input");

              var numberCell = document.createElement("td");
              var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

              if (thisIndex < wordList.length) {
                numberCell.innerHTML = Number(thisIndex + 1) + ".&nbsp;&nbsp;";
                numberCell.setAttribute("class", skin + "wordsNum");
                wordInput.setAttribute("id", "inpRecall" + thisIndex);
                wordInput.setAttribute("class", skin + "wordsRecall");
                wordInput.thisIndex = thisIndex;
                wordInput.addEventListener("click", function (e) {
                  moveFocusWordsRecall(e.target.thisIndex);
                });
                wordInput.addEventListener("dblclick", function (e) {
                  toggleMark(e.target);
                });

                wordCell.setAttribute("class", skin + "wordsRecallTD");
                wordCell.setAttribute("id", "tdRecall" + thisIndex);
                wordCell.appendChild(wordInput);
              }


              row.appendChild(numberCell);
              row.appendChild(wordCell);
            }
          }
          thisPageTable.appendChild(row);
        }

        pageDiv.appendChild(thisPageTable);

        document.getElementById("recallContentDiv").appendChild(pageDiv);

      }


      //***FINISH BUTTON kEpT fOr ReCall
      var button = document.createElement("button");
      button.setAttribute("class", "btnDigital finishBtn");
      button.addEventListener("click", confirmFinishRecall);
      button.innerText = "Finish";
      $("#finishBtnDiv").empty();
      document.getElementById("finishBtnDiv").appendChild(button);


      //restore data if resuming
      if (resuming) {

        restoreWordsData();
        restoreMarks();
      }

      //go to first digits


      setTimeout(function () {
        moveFocusWordsRecall(0);
      }, 40);


      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }


      //set the timer
      var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

      recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
      (function f() {
        recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
        r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
        //ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
        //r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

        //every 10 seconds, save
        if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
          saveWordsData();
        }

        //save the elapsed time every second
        localStorage.setItem("timeElapsed", recallTimeDiff);

        //When timer reaches 0, go to score display
        if (recallTimeDiff / 1e3 >= recallTime) {
          finishRecall();

        }
        //Otherwise repeat this function
        else {
          if (!ended || intermediate) {
            myTimer = setTimeout(f, 1000);
          }
        }
      })();


      //display memo time
      if (memoTimeNeeded) displayMemoTime();

      document.onkeydown = function (e) {

        //If Enter is pressed
        if (e.key == "Enter" && !ended && !competitionMode) {
          confirmFinishRecall();


        }

        //if tab is pressed (NOT RIGHT), move on
        if (e.key == "Tab" && !ended && !e.shiftKey) {
          e.preventDefault();
          moveNextWordsRecall();
        }


        //if shift-tab is pressed (NOT LEFT) to go back ***shift-tab not working here or memo
        if (e.shiftKey && e.key == "Tab" && !ended) {
          e.preventDefault();
          movePreviousWordsRecall();
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          movePreviousWordsRecall();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveNextWordsRecall();
        }

        //if backspace (8) is pressed and nothing in this box, go backwards
        /*	if ((e.key == "Backspace") && !ended && document.getElementById("inpRecall" + curPos).value.length == 0) {
                e.preventDefault();
                movePreviousWordsRecall();
                document.getElementById("inpRecall" + curPos).focus();
            }*/

        //If + is pressed
        if ((e.key == '+' || e.key == '=') && !ended) {
          e.preventDefault();
          shiftWordsForward();

        }

        //If - is pressed
        if ((e.key == '-' || e.key == '-') && !ended) {

          e.preventDefault();
          shiftWordsBackward();

        }


        //if left arrow pressed, move left through word or (if at beginning) to previous box
        if (e.key == "ArrowLeft" && !ended) {
          //e.preventDefault();
          if (getCaretPosition(e.target) == 0) {
            e.preventDefault();
            movePreviousWordsRecall();
          }
        }


        //if right arrow pressed, move right through word or (if at end) to next box
        if (e.key == "ArrowRight" && !ended) {

          if (getCaretPosition(e.target) == e.target.value.length) {
            e.preventDefault();
            if (e.target.id.indexOf("F") == -1) {
              moveNextWordsRecall();
            }
          }
        }


        //if [ is pressed, previous page
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusWordsRecall(wordsPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.') {
          e.preventDefault();
          if (curPage < numberOfPages - 1) moveFocusWordsRecall(wordsPerPage * (curPage + 1));

        }

        //if space is pressed, return to start (REMOVED THIS AS SOME LANGUAGES HAVE SPACES)
        // if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
        //     e.preventDefault();
        //     moveFocusWordsRecall(0);
        // }

      };


    }

    function moveFocusWordsRecall(newPos) {

      //get current page
      curPage = Math.floor(newPos / wordsPerPage);


      //show/hide correct pages
      for (var i = 0; i < numberOfPages; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + "Recall").style.display = "block";
          if (numberOfPages > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
          if (numberOfPages > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
          }
        }
      }


      if (!ended) {
        //get first of grouping
        var firstOfGroup = curPos - (curPos % grouping);


        if (newPos < amount) {
          document.getElementById("inpRecall" + newPos).focus();
          //document.getElementById("inpRecall" + newPos).select();

          //un-highlight current group
          document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
          document.getElementById("inpRecall" + firstOfGroup).classList.remove(skin + "wordsSelectedRecall");
          document.getElementById("inpRecall" + firstOfGroup).classList.remove(skin + "wordsInGroup");
          for (var i = 1; i < grouping; i++) {
            if (firstOfGroup < amount - i) {
              document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
              document.getElementById("inpRecall" + (firstOfGroup + i)).classList.remove(skin + "wordsSelectedRecall");
              document.getElementById("inpRecall" + (firstOfGroup + i)).classList.remove(skin + "wordsInGroup");
            }
          }

          //update firstOfGroup

          firstOfGroup = newPos - (newPos % grouping);

          //highlight selected word and also other words in group (different colour)


          document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
          document.getElementById("inpRecall" + (firstOfGroup)).classList.add(skin + "wordsInGroup");
          for (var i = 1; i < grouping; i++) {
            if (firstOfGroup < amount - i) {
              document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
              document.getElementById("inpRecall" + (firstOfGroup + i)).classList.add(skin + "wordsInGroup");
            }
          }

          document.getElementById("inpRecall" + newPos).classList.add(skin + "wordsSelectedRecall");
        }
      }



      curPos = newPos;





    }

    function moveNextWordsRecall() {

      //if we have reached end of list, don't move

      if (curPos < (amount - 1)) {



        moveFocusWordsRecall(curPos + 1);


      }
    }

    function movePreviousWordsRecall() {

      //if we are at start of list, don't move

      if (curPos > 0) {

        moveFocusWordsRecall(curPos - 1);


      }
    }


    function shiftWordsForward() {

      for (var i = amount - 1; i >= curPos + 1; i--) {
        document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
        if (document.getElementById("inpRecall" + Number(i - 1)).classList.contains("markOther")) {
          document.getElementById("inpRecall" + Number(i - 1)).classList.remove("markOther");
          document.getElementById("inpRecall" + i).classList.add("markOther");
        } else {
          document.getElementById("inpRecall" + i).classList.remove("markOther");
        }
      }


      document.getElementById("inpRecall" + (curPos)).value = "";
      document.getElementById("inpRecall" + (curPos)).classList.remove("markOther");


    }

    function shiftWordsBackward() {
      document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + Number(curPos + 1)).value;
      if (document.getElementById("inpRecall" + Number(curPos + 1)).classList.contains("markOther")) {
        document.getElementById("inpRecall" + Number(curPos + 1)).classList.remove("markOther");
        document.getElementById("inpRecall" + curPos).classList.add("markOther");
      }


      for (var i = curPos + 1; i < amount - 1; i++) {

        document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
        if (document.getElementById("inpRecall" + Number(i + 1)).classList.contains("markOther")) {
          document.getElementById("inpRecall" + Number(i + 1)).classList.remove("markOther");
          document.getElementById("inpRecall" + i).classList.add("markOther");
        }

      }
      document.getElementById("inpRecall" + (amount - 1)).value = "";
      document.getElementById("inpRecall" + (amount - 1)).classList.remove("markOther");

    }


    function startNamesRecall() {
      ended = false;

      //in dates it's just hidden
      //document.getElementById("spanShift").style.display = "none";

      if (resuming) {
        amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
        facesAmount = Math.ceil(amount / 2);
        namesPerPage = namesPerRow * nameRowsPerPage;
        numberOfPages = Math.ceil(facesAmount / namesPerPage); //added in case went straight to recall
        //restore data		
        nameList = JSON.parse(localStorage.getItem("nameList"));
        shuffledNameList = JSON.parse(localStorage.getItem("shuffledNameList"));
      } else {
        //if this is a competition, we import the shuffle order and create the shuffledNameList at the start of memo
        if (!competitionMode || competitionTestMode) {
          shuffledNameList = shuffle(nameList);
          //save it
          localStorage.setItem("shuffledNameList", JSON.stringify(shuffledNameList));
        }
      }

      //add the page links if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNamesRecall(" + namesPerPage * i + ",true)'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br />";
        document.getElementById("menuRecallDiv").innerHTML = menuString

      } else {
        document.getElementById("menuRecallDiv").innerHTML = "";
      }


      //add the recall content

      for (i = 0; i < numberOfPages; i++) {

        //create a new page that can be hidden or shown
        var pageDiv = document.createElement("div");
        pageDiv.setAttribute("id", "page" + i + "Recall");
        //add table to hold the names
        var thisPageTable = document.createElement("table");
        thisPageTable.setAttribute("class", "nameTable");

        //add rows with cells
        for (j = 0; j < nameRowsPerPage; j++) {
          var faceRow = document.createElement("tr");
          var nameRow = document.createElement("tr");

          for (k = 0; k < namesPerRow; k++) {
            var thisIndex = i * namesPerPage + j * nameRowsPerPage + k;
            if (thisIndex < nameList.length) {
              var faceCell = document.createElement("td");
              faceCell.classList.add("faceMemo");
              var faceImg = document.createElement("img");

              faceImg.setAttribute("src", shuffledNameList[thisIndex].imageURL);

              const facesFormat = getFacesFormat();

              if (competitionMode || facesFormat === 'square') {
                //oval face settings
                faceImg.setAttribute("height", "128");
                faceImg.setAttribute("width", "128");

                //specially for GMO 2019
                //		faceImg.setAttribute("height", "137");
                //			faceImg.setAttribute("width", "114");
              } else {
                faceImg.setAttribute("height", "128");
                faceImg.setAttribute("width", "101.5");
              }

              var nameCell = document.createElement("td");

              // nameCell.classList.add("nameRecallTD");
              // nameCell.classList.add(skin + "nameRecallTD");

              var nameInputFCell = document.createElement("input");
              nameInputFCell.classList.add("nameRecall");
              nameInputFCell.classList.add(skin + "nameRecall");
              nameInputFCell.setAttribute("id", "inpRecallF" + thisIndex);
              nameInputFCell.thisIndex = thisIndex;
              nameInputFCell.addEventListener("click", function (e) {
                moveFocusNamesRecall(e.target.thisIndex, true);
              });
              nameInputFCell.addEventListener("dblclick", function (e) {
                toggleMark(e.target);
              });

              var nameInputSCell = document.createElement("input");
              nameInputSCell.classList.add("nameRecall");
              nameInputSCell.classList.add(skin + "nameRecall");
              nameInputSCell.setAttribute("id", "inpRecallS" + thisIndex);
              nameInputSCell.thisIndex = thisIndex;
              nameInputSCell.addEventListener("click", function (e) {
                moveFocusNamesRecall(e.target.thisIndex, false);
              });
              nameInputSCell.addEventListener("dblclick", function (e) {
                toggleMark(e.target);
              });
              faceCell.appendChild(faceImg);
              faceCell.setAttribute("id", "tdFace" + thisIndex);


              nameCell.setAttribute("id", "tdRecall" + thisIndex);

            }

            if (namesCharsetIsRToL() || namesCharset.includes("Chinese")) {
              nameCell.appendChild(nameInputSCell);
              nameCell.appendChild(nameInputFCell);
            } else {
              nameCell.appendChild(nameInputFCell);
              nameCell.appendChild(nameInputSCell);
            }

            nameRow.appendChild(nameCell);
            faceRow.appendChild(faceCell);
          }
          thisPageTable.appendChild(faceRow);
          thisPageTable.appendChild(nameRow);
        }

        pageDiv.appendChild(thisPageTable);

        document.getElementById("recallContentDiv").appendChild(pageDiv);



      }

      //***FINISH BUTTON kEpT fOr ReCall
      var button = document.createElement("button");
      button.setAttribute("class", "btnDigital finishBtn");
      button.addEventListener("click", confirmFinishRecall);
      button.innerText = "Finish";
      $("#finishBtnDiv").empty();
      document.getElementById("finishBtnDiv").appendChild(button);

      //restore data if resuming
      if (resuming) {
        restoreNamesData();
        restoreMarks();
      }


      //display memo time
      if (memoTimeNeeded) displayMemoTime();

      //go to first digits
      setTimeout(function () {
        moveFocusNamesRecall(0, true);
      }, 40);


      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }



      //set current position
      curPos = 0;

      //set the timer
      var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
      recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
      (function f() {
        recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
        r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
        //ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
        //r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

        //every 10 seconds, save
        if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
          saveNamesData();
        }

        //save the elapsed time every second
        localStorage.setItem("timeElapsed", recallTimeDiff);


        //When timer reaches 0, go to score display
        if (recallTimeDiff / 1e3 >= recallTime) {

          finishRecall();
        }
        //Otherwise repeat this function
        else {
          if (!ended || intermediate) {
            myTimer = setTimeout(f, 1000);
          }
        }
      })();


      document.onkeydown = function (e) {

        //If Enter is pressed
        if (e.key == "Enter" && !ended && !competitionMode) {
          confirmFinishRecall();
        }

        //if  tab is pressed, move on
        if (e.key == "Tab" && !e.shiftKey && !ended) {
          e.preventDefault();
          console.log(e.target.id);
          if (e.target.id.indexOf("F") == -1) {
            moveNextNamesRecall();
          } else {
            //	document.getElementById("inpRecallS" + curPos).focus)();
            moveFocusNamesRecall(curPos, false);
          }
        }


        //if  shifttab is pressed to go back ***shift-tab not working here or memo
        if ((e.shiftKey && e.key == "Tab") && !ended) {
          e.preventDefault();
          if (e.target.id.indexOf("F") > -1) {

            movePreviousNamesRecall();
          } else {

            moveFocusNamesRecall(curPos, true);
          }
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveFocusNamesRecall(curPos - namesPerRow, true);
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveFocusNamesRecall(curPos + namesPerRow, true);
        }

        //if left arrow pressed, move left through word or (if at beginning) to previous box
        if (e.key == "ArrowLeft" && !ended) {
          //e.preventDefault();
          if (getCaretPosition(e.target) == 0) {
            e.preventDefault();
            if (e.target.id.indexOf("F") > -1) {
              moveFocusNamesRecall(curPos - 1, false);
            } else {


              moveFocusNamesRecall(curPos, true);
            }
          }
        }

        //if right arrow pressed, move right through word or (if at end) to next box
        if (e.key == "ArrowRight" && !ended) {

          if (getCaretPosition(e.target) == e.target.value.length) {
            e.preventDefault();
            if (e.target.id.indexOf("F") == -1) {
              moveNextNamesRecall();
            } else {
              //	document.getElementById("inpRecallS" + curPos).focus)();
              moveFocusNamesRecall(curPos, false);
            }
          }
        }

        //if [ is pressed, previous page
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusNamesRecall(namesPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.') {
          e.preventDefault();
          if (curPage < numberOfPages - 1) moveFocusNamesRecall(namesPerPage * (curPage + 1));

        }


        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusNamesRecall(0);
        }

        /*
                    //if backspace (8) is pressed and nothing in this box, go backwards
                    if (e.key == "Backspace" && !ended && document.getElementById("inpRecallF" + curPos).value.length == 0) {
                        e.preventDefault();
                        if (e.target.id.indexOf("F") > -1) {
                            movePreviousNamesRecall();
        
                        } else {
                            //	document.getElementById("inpRecallF" + curPos).focus();
                        	
                            moveFocusNamesRecall(curPos, true);
                        }
                    }
        
        */

      };


    }


    function moveFocusNamesRecall(newPos, isFirstname = true) {
      if (!ended) {
        if (newPos < amount) {


          //un-highlight current name

          document.getElementById("inpRecallF" + curPos).classList.remove(skin + "namesSelectedRecall");
          document.getElementById("inpRecallS" + curPos).classList.remove(skin + "namesSelectedRecall");

          //highlight new one
          if (isFirstname) {
            document.getElementById("inpRecallF" + newPos).classList.add(skin + "namesSelectedRecall");
          } else {
            document.getElementById("inpRecallS" + newPos).classList.add(skin + "namesSelectedRecall");
          }
        }

      }
      //get current page
      curPage = Math.floor(newPos / namesPerPage);


      //show/hide correct pages
      for (var i = 0; i < numberOfPages; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + "Recall").style.display = "block";
          if (numberOfPages > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
          if (numberOfPages > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
          }
        }


        curPos = newPos;
        if (isFirstname) {
          document.getElementById("inpRecallF" + newPos).focus();
          //	document.getElementById("inpRecallF" + newPos).select();
        } else {
          document.getElementById("inpRecallS" + newPos).focus();
          //	document.getElementById("inpRecallS" + newPos).select();
        }

      }




    }

    function moveNextNamesRecall() {

      //if we have reached end of list, don't move

      if (curPos < (amount - 1)) {



        moveFocusNamesRecall(curPos + 1, true);


      }
    }

    function movePreviousNamesRecall() {

      //if we are at start of list, don't move

      if (curPos > 0) {

        moveFocusNamesRecall(curPos - 1, false);


      }
    }





    function finishMemo(test = false) {
      if (test) {
        goToSettings(true);
        return;
      }

      //Clear display
      document.getElementById("memoRow").style.display = "none";

      //set ended to true
      ended = true;
      clearTimeout(myTimer);
      resuming = false;

      localStorage.setItem("phase", "recall");
      localStorage.setItem("timeElapsed", "0");
      //Recall


      if (competitionMode) {
        intermediateScreenSR();
      } else {
        startRecallCountdown();
      }


    }

    function startRecallCountdown(test = false) {

      document.getElementById("memoRow").style.display = "none";

      //save amount if Spoken
      if (currentDiscipline.indexOf("K") > -1) {

        if (test) {
          //if test, use officialamount
          amount = lookupProperty(currentDiscipline, "amount");
        } else {
          localStorage.setItem("amount", amount);
          //amount may not correspond to official amounts				
          setupGroupingsAndLoci();
          if (resuming) {
            //restore number list
            numberList = JSON.parse(localStorage.getItem("correctAnswers"));
          } else {
            //save number list in storage			
            if (!test) localStorage.setItem("correctAnswers", JSON.stringify(numberList));
          }
        }
      }

      //if numbers or binary, set up the groupings and loci
      if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("B") > -1) setupGroupingsAndLoci();

      //save amount if Speed Cards recall
      if (currentDiscipline.indexOf("XC") > -1) {
        localStorage.setItem("amount", amount);
        amount = lookupProperty(currentDiscipline, "amount");
        //no need to save or restore card list as there is no list - this is just recall
      }

      //clear vignette
      //$('#hiddenDiv').fadeOut(1500);
      //$('#darkenVignette').fadeOut(1500);
      //document.getElementById("hiddenDiv").style.opacity = 0;
      //document.getElementById("darkenVignette").style.opacity = 0;
      $('#hiddenDiv').animate({opacity: 0}, 1500);

      if (skin.indexOf("analogue") > -1 && currentDiscipline.indexOf("C") > -1) {

        $("#countdownBox").addClass("analogue1boxGreen");
        $("#countdownBox").removeClass("analogue1boxB");
      }

      //display correct sections
      document.getElementById("logoRow").style = "display:none";
      document.getElementById("topMargin").style = "display:block";
      document.getElementById("btnBackToSelection2").style = "display:none";

      /*
          //Show logo row if digital1
          if (skin.indexOf("analogue")===-1) {
                  document.getElementById("logoRow").style="display:block";
                  document.getElementById("topMargin").style="display:none";
          }
          else {
              document.getElementById("logoRow").style="display:none";
              document.getElementById("topMargin").style="display:block";
          }*/

      //Display countdown section only
      document.getElementById("selectionRow").style = "display:none";	//added in case we are resuming and go straight from selection to countdown
      document.getElementById("settingsRow0").style = "display:none"; //added in case we are doing spoken (straight from settings to recall)
      document.getElementById("countdownTable").style.display = 'none';
      document.getElementById("countdownRecallTable").style = "display:inline";
      document.getElementById("countdownRecallText").innerHTML = "";
      document.getElementById("countdownRecallTime").innerHTML = "";
      document.getElementById("countdownRow").style = "display:block";
      document.getElementById("memoRow").style = "display:none";
      // document.getElementById("countdownDisciplineTitle").innerHTML = lookupProperty(currentDiscipline,"label");

      //Get recall time
      if (!freeTraining()) {
        if (currentDiscipline.indexOf("K") > -1) {
          recallTime = amount * 3;
          if (amount > 500) recallTime = 1500;
          //recallTime = lookupProperty(currentDiscipline, "recallTime");
          //amount = lookupProperty(currentDiscipline, "amount");			
        } else {
          recallTime = lookupProperty(currentDiscipline, "recallTime");
        }
      }



      if (resuming || currentDiscipline.indexOf("K") > -1) {
        var titleElements = document.getElementsByClassName("countdownDisciplineTitle");
        var title = lookupProperty(currentDiscipline, "label");
        for (var i = 0; i < titleElements.length; i++) {
          titleElements[i].innerHTML = title;
        }
      }

      //Display countdown clock
      if (resuming) {
        countSeconds = -4
      } else if (test) {
        countSeconds = -2;
      } else if (currentDiscipline.indexOf("K") > -1 || currentDiscipline.indexOf("XC") > -1) {
        countSeconds = 0;
      } else if (currentDiscipline.indexOf("SC") > -1) {
        countSeconds = countdownRecallSeconds;
      } else {
        countSeconds = countdownRecallSeconds;
      }

      //countSeconds = (test||resuming) ? -2 : ((currentDiscipline.indexOf("K")>-1 || currentDiscipline.indexOf("XC")>-1) ? 0 : countdownRecallSeconds);

      cint = setInterval(showSecondsR, 1000);
    }

    function showSecondsR() {
      document.getElementById("countdownRecallText").innerHTML = "Recall starts in: ";
      document.getElementById("countdownRecallTime").innerHTML = countSeconds;
      countSeconds--;
      if (countSeconds <= -1) {
        clearInterval(cint);
        startRecall(countSeconds == -3);
        //localStorage.setItem("phase","recall");
      }

    }

    function startRecall(test = false) {
      localStorage.setItem("phase", "recall");

      //Display recall section only
      document.getElementById("countdownRow").style = "display:none";
      document.getElementById("recallRow").style = "display:block";
      document.getElementById("menuRecallDiv").style.display = "block";

      //Display relevant memo depending on discipline
      switch (currentDiscipline) {
        case "5N":
        case "15N":
        case "30N":
        case "60N":
        case "TN":
          startNumberRecall(false);
          break;
        case "K1":
        case "K2":
        case "K3":
          startNumberRecall(test);
          break;
        case "5B":
        case "30B":
        case "TB":
          startBinaryRecall();
          break;
        case "10C":
        case "30C":
        case "60C":
        case "SC":
        case "SXC":
        case "TXC":
        case "TC":
          startCardRecall(test);
          break;
        case "D":
        case "TD":
          startDatesRecall();
          break;
        case "5F":
        case "15F":
        case "TF":
          startNamesRecall();
          break;
        case "5W":
        case "15W":
        case "TW":
          startWordsRecall();
          break;

        default:
          startImagesRecall();
      }
    }

    function startNumberRecall(test = false) {

      ended = false;

      if (resuming) amount = Number(localStorage.getItem("amount")); //added in case going straight to recall


      if (resuming) {
        miniGroupings = localStorage.getItem("miniGroupings") ? JSON.parse(localStorage.getItem("miniGroupings")) : [1];

        //restore data
        numberList = JSON.parse(localStorage.getItem("correctAnswers"));

        //create the arrays of minigroup and locus starting points
        miniGroupStarts = [];
        locusStarts = [0];
        var counter = 0;
        curMiniGroup = 0;
        while (counter < amount) {
          miniGroupStarts.push(counter);
          counter += parseFloat(miniGroupings[curMiniGroup]);
          if (curMiniGroup == miniGroupings.length - 1) {
            locusStarts.push(counter);
            curMiniGroup = 0;
          } else {
            curMiniGroup = parseFloat(curMiniGroup) + 1 % miniGroupings.length;
          }
        }
      }


      numberOfPages = Math.ceil(amount / numbersPerPage); //added in case went straight to recall

      curPos = 0;
      curLocus = 0;
      curMiniGroup = 0;
      curPage = 0;
      var numberRecallString = "";

      //get colour back if switched off
      if (blnFocusBox && !blnHighlightOn) {
        hiColour = localStorage.getItem("hiColour");
        document.body.style.setProperty("--highlightColor", this[hiColour]);
      }

      //add the page links if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNumRecall(" + numbersPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }

        menuString += "</ul><br /><br /><br />";
        document.getElementById("menuRecallDiv").innerHTML = menuString;


        /*
        //new menu 
        for (var i=0;i<numberOfPages;i++) {
                var menuItem = document.createElement("a");
                menuItem.setAttribute("href","#");
                menuItem.setAttribute("id","page" + i + "tablinkRecall");
                menuItem.classList.add(skin + "pagelink");
                menuItem.classList.add("menu");
                menuItem.innerHTML = (i+1) + "";
                document.getElementById("menuRecallDiv").appendChild(menuItem);
                //+= "<li><a href='#' id='page"+ i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNumRecall(" + numbersPerPage*i + ")'>" + (i+1) + "</a></li>";
            }
            */
      } else {
        document.getElementById("menuRecallDiv").innerHTML = "";
      }



      //add the recall content
      for (i = 0; i < numberOfPages; i++) {
        if (i < numberOfPages - 1) {
          numbersOnThisPage = numbersPerPage;
        }
        else {
          numbersOnThisPage = amount - i * numbersPerPage;
        }

        numberRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";

        for (j = 0; j < numbersOnThisPage; j++) {

          numberRecallString += "<td id='tdRecall" + (i * numbersPerPage + j) + "' class='" + skin + "numbersRecallTD'><input ondblclick='toggleMark(this)' class='" + skin + "numbersRecall' id='inpRecall" + (i * numbersPerPage + j) + "' maxlength='1'	  onclick='moveFocusNumRecall(" + (i * numbersPerPage + j) + ")' oninput='checkMoveLocusNumRecall(" + (i * numbersPerPage + j + 1) + ")'></input><span style='height:10px' class='slash'><sup class='digitMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";


          if ((j + 1) % numbersPerRow == 0) {
            if (j + 1 == numbersOnThisPage) {
              numberRecallString += "</tr></table></div>";

            }

            else {

              numberRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage + j) / numbersPerRow + 2) + "&nbsp;&nbsp;</td>";



            }

          }

        }

      }


      //***FINISH BUTTON kEpT fOr ReCall
      //numberRecallString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button>";
      document.getElementById("recallContentDiv").innerHTML = numberRecallString;

      if (!test) {
        var button = document.createElement("button");
        button.setAttribute("class", "btnDigital finishBtn");
        button.addEventListener("click", confirmFinishRecall);
        button.innerText = "Finish";
        $("#finishBtnDiv").empty();
        document.getElementById("finishBtnDiv").appendChild(button);

      }

      //add separations
      if (separations.length > 0) {
        for (var i = 0; i < amount; i++) {
          if (separations.indexOf((i + 1) % locusSize) > -1 || (i + 1) % locusSize == 0) {
            document.getElementById("tdRecall" + i).classList.add("separation");
          }

        }
      }



      if (skin.indexOf('analogue') > -1 && !resuming) {
        var fontSizeArray = dualFontRandomizer(fontReenieBeanie, fontShadowsIntoLight);
        for (var i = 0; i < amount; i++) {
          document.getElementById("inpRecall" + i).style.fontSize = fontSizeArray[i][1];
          document.getElementById("inpRecall" + i).style.fontFamily = fontSizeArray[i][0];
        }
      }

      //restore data if resuming
      if (resuming) {

        restoreNumbersData();
        restoreMarks();
      }

      if (memoTimeNeeded) displayMemoTime();

      //go to first digits

      setTimeout(function () {
        moveLocusNumRecall(0, 0, 0);
      }, 40);


      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }

      r = document.getElementById(skin + 'RecallTimeInner');
      if (!test) {

        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;


        recallStart = Date.now();

        (function f() {
          recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
          r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
          //ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
          //r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

          //every 10 seconds, save
          if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
            saveNumbersData();
          }

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", recallTimeDiff);

          //When timer reaches 0, go to score display
          if (recallTimeDiff / 1e3 >= recallTime) {

            finishRecall();
          }
          //Otherwise repeat this function
          else {
            if (!ended || intermediate) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();

      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {

        //If Enter is pressed
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            confirmFinishRecall();
          } else {
            finishRecall(test);
          }


        }

        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          e.preventDefault();
          moveNextNumbersRecall();
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          e.preventDefault();
          movePreviousNumbersRecall();
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveUpNumbersRecall();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveDownNumbersRecall();
        }

        //if backspace (8) is pressed, 

        if (e.key == "Backspace" && !ended) {
          e.preventDefault();
          if (document.getElementById("inpRecall" + curPos).value == "") {
            //if nothing in this box, delete the number in previous box and move back to that space
            movePreviousNumbersRecall();
            document.getElementById("inpRecall" + curPos).value = "";
          } else {
            //else delete what's in this box
            document.getElementById("inpRecall" + curPos).value = "";
          }
        }
        //If + is pressed
        if ((e.key == '+' || e.key == '=') && !ended) {
          e.preventDefault();
          shiftNumbersForward();

        }

        //If - is pressed
        if ((e.key == '-' || e.key == '-') && !ended) {
          e.preventDefault();

          shiftNumbersBackward();

        }

        //if [ is pressed, previous page
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusNumRecall(numbersPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {
          e.preventDefault();
          if (curPage < numberOfPages - 1) moveFocusNumRecall(numbersPerPage * (curPage + 1));

        }


        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusNumRecall(0);
        }

      };





    }

    function moveNextNumbersRecall() {

      //if we have reached end of list, don't move

      if (curPos < (amount - 1)) {

        if (locusStarts.indexOf(curPos + 1) > -1) {
          moveLocusNumRecall(curLocus + 1, 0, curPos + 1);
        } else {
          if (miniGroupStarts.indexOf(curPos + 1) > -1) {
            moveLocusNumRecall(curLocus, curMiniGroup + 1, curPos + 1);
          } else {
            moveLocusNumRecall(curLocus, curMiniGroup, curPos + 1);
          }
        }

        //	moveFocusNumRecall(curPos+1);

      }
    }

    function movePreviousNumbersRecall() {

      //if we are at start of list, don't move

      if (curPos > 0) {

        moveFocusNumRecall(curPos - 1);


      }
    }

    function moveUpNumbersRecall() {

      //if we are on first row, don't move

      if (curPos >= numbersPerRow) {


        moveFocusNumRecall(curPos - numbersPerRow);


      }
    }

    function moveDownNumbersRecall() {

      //if we are on last row, don't move

      if (curPos + numbersPerRow < amount) {


        moveFocusNumRecall(curPos + numbersPerRow);


      }
    }

    function saveNumbersData() {

      console.log("saving data");
      chosenAnswers = [];
      //save data
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many digits on page
        if (j < numberOfPages - 1) {
          numberOfDigits = numbersPerPage;
        }
        else {
          numberOfDigits = amount - j * numbersPerPage;
        }
        //loop through the digits on the page

        for (var i = 0; i < numberOfDigits; i++) {
          //get the chosen answer for the digit
          chosenAnswers.push(document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).value);
        }
      }
      localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

    }

    function saveBinaryData() {

      console.log("saving data");
      chosenAnswers = [];
      //save data
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many digits on page
        if (j < numberOfPages - 1) {
          numberOfDigits = binaryPerPage;
        }
        else {
          numberOfDigits = amount - j * binaryPerPage;
        }
        //loop through the digits on the page

        for (var i = 0; i < numberOfDigits && (j * binaryPerPage) + i < binaryList.length; i++) {
          //get the chosen answer for the digit
          chosenAnswers.push(document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).value);
        }
      }
      localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

    }

    function saveCardsData() {

      console.log("saving data");
      chosenAnswers = [];
      localStorage.setItem("chosen", JSON.stringify(boneyardArray));

    }

    function saveWordsData() {

      console.log("saving data");
      chosenAnswers = [];
      //save data
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many words on page
        if (j < numberOfPages - 1) {
          numberOfWords = wordsPerPage;
        }
        else {
          numberOfWords = amount - j * wordsPerPage;
        }
        //loop through the words on the page

        for (var i = 0; i < numberOfWords; i++) {
          //get the chosen answer for the word
          chosenAnswers.push(document.getElementById("inpRecall" + ((j * wordsPerPage) + i)).value);
        }
      }
      localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

    }

    function saveDatesData() {

      console.log("saving data");
      chosenAnswers = [];
      //save data
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many dates on page
        if (j < numberOfPages - 1) {
          numberOfDates = datesPerPage;
        }
        else {
          numberOfDates = amount - j * datesPerPage;
        }
        //loop through the dates on the page

        for (var i = 0; i < numberOfDates; i++) {
          //get the chosen answer for the date
          chosenAnswers.push(document.getElementById("inpRecall" + ((j * datesPerPage) + i)).value);
        }
      }
      localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

    }

    function saveImagesData() {

      console.log("saving data");
      chosenAnswers = [];
      //save data
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many dates on page
        if (j < numberOfPages - 1) {
          numberOfImages = imagesPerPage;
        }
        else {
          numberOfImages = amount - j * imagesPerPage;
        }
        //loop through the images on the page

        for (var i = 0; i < numberOfImages; i++) {
          //get the chosen answer for the image
          chosenAnswers.push(document.getElementById("inpRecall" + ((j * imagesPerPage) + i)).value);
        }
      }
      localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

    }

    function saveNamesData() {

      console.log("saving data");
      chosenFirstNames = [];
      chosenSurnames = [];
      var numberOfFaces;
      //save data
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many faces on page
        if (j < numberOfPages - 1) {
          numberOfFaces = namesPerPage;
        }
        else {
          numberOfFaces = facesAmount - j * namesPerPage;
        }
        //loop through the faces on the page
        console.log(numberOfFaces + " " + j);
        for (var i = 0; i < numberOfFaces; i++) {
          //get the chosen first name
          chosenFirstNames.push(document.getElementById("inpRecallF" + ((j * namesPerPage) + i)).value);
          //get the chosen surname
          chosenSurnames.push(document.getElementById("inpRecallS" + ((j * namesPerPage) + i)).value);

        }
      }
      localStorage.setItem("chosenFirstNames", JSON.stringify(chosenFirstNames));
      localStorage.setItem("chosenSurnames", JSON.stringify(chosenSurnames));

    }



    function restoreNumbersData() {
      console.log("restoring data");
      chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
      console.log("chosen answers: ");
      if (chosenAnswers.length > 0) {
        //get data
        for (var j = 0; j < numberOfPages; j++) {
          //calculate how many digits on page
          if (j < numberOfPages - 1) {
            numberOfDigits = numbersPerPage;
          }
          else {
            numberOfDigits = amount - j * numbersPerPage;
          }
          //loop through the digits on the page

          for (var i = 0; i < numberOfDigits; i++) {
            //get the chosen answer for the digit, provided it's a number
            if (!isNaN(chosenAnswers[(j * numbersPerPage) + i])) document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).value = chosenAnswers[(j * numbersPerPage) + i];
          }
        }
      }
    }

    function restoreBinaryData() {
      console.log("restoring data");
      chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
      if (chosenAnswers.length > 0) {
        //get data
        for (var j = 0; j < numberOfPages; j++) {
          //calculate how many digits on page
          if (j < numberOfPages - 1) {
            numberOfDigits = binaryPerPage;
          }
          else {
            numberOfDigits = amount - j * binaryPerPage;
          }
          //loop through the digits on the page

          for (var i = 0; i < numberOfDigits; i++) {
            //get the chosen answer for the digit, provided it's a number
            if (!isNaN(chosenAnswers[(j * binaryPerPage) + i])) document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).value = chosenAnswers[(j * binaryPerPage) + i];
          }
        }
      }
    }

    function restoreCardsData() {
      console.log("restoring data");
      chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
      if (chosenAnswers.length > 0) {
        //get data
        for (var j = 0; j < amount * 52; j++) {
          //loop through boneyard

          for (var i = 0; i < chosenAnswers[j].recallPos.length; i++) {
            curPos = chosenAnswers[j].recallPos[i];
            chooseFromBoneyard(j);
          }
        }
      }
    }


    function restoreWordsData() {
      console.log("restoring data");

      chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
      console.log(chosenAnswers);
      if (chosenAnswers.length > 0) {
        //get data
        for (var j = 0; j < numberOfPages; j++) {
          //calculate how many words on page
          if (j < numberOfPages - 1) {
            numberOfWords = wordsPerPage;
          }
          else {
            numberOfWords = amount - j * wordsPerPage;
          }
          //loop through the words on the page

          for (var i = 0; i < numberOfWords; i++) {
            //get the chosen answer for the word
            if (chosenAnswers[(j * wordsPerPage) + i] != "") document.getElementById("inpRecall" + ((j * wordsPerPage) + i)).value = chosenAnswers[(j * wordsPerPage) + i];
          }
        }
      }
    }

    function restoreDatesData() {
      console.log("restoring data");

      chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
      console.log(chosenAnswers);
      if (chosenAnswers.length > 0) {
        //get data
        for (var j = 0; j < numberOfPages; j++) {
          //calculate how many words on page
          if (j < numberOfPages - 1) {
            numberOfDates = datesPerPage;
          }
          else {
            numberOfDates = amount - j * datesPerPage;
          }
          //loop through the dates on the page

          for (var i = 0; i < numberOfDates; i++) {
            //get the chosen answer for the word
            if (chosenAnswers[(j * datesPerPage) + i] != "") document.getElementById("inpRecall" + ((j * datesPerPage) + i)).value = chosenAnswers[(j * datesPerPage) + i];
          }
        }
      }
    }

    function restoreImagesData() {
      console.log("restoring data");

      chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
      console.log(chosenAnswers);
      if (chosenAnswers.length > 0) {
        //get data
        for (var j = 0; j < numberOfPages; j++) {
          //calculate how many images on page
          if (j < numberOfPages - 1) {
            numberOfImages = imagesPerPage;
          }
          else {
            numberOfImages = amount - j * imagesPerPage;
          }
          //loop through the images on the page

          for (var i = 0; i < numberOfImages; i++) {
            //get the chosen answer for the word
            if (chosenAnswers[(j * imagesPerPage) + i] != "") document.getElementById("inpRecall" + ((j * imagesPerPage) + i)).value = chosenAnswers[(j * imagesPerPage) + i];
          }
        }
      }
    }


    function restoreNamesData() {
      console.log("restoring data");

      chosenFirstNames = JSON.parse(localStorage.getItem("chosenFirstNames"));
      chosenSurnames = JSON.parse(localStorage.getItem("chosenSurnames"));

      if (chosenFirstNames.length > 0 || chosenSurnames.length > 0) {
        //get data
        for (var j = 0; j < numberOfPages; j++) {
          //calculate how many images on page
          if (j < numberOfPages - 1) {
            var numberOfFaces = namesPerPage;
          }
          else {
            var numberOfFaces = facesAmount - j * namesPerPage;
          }
          //loop through the names on the page

          for (var i = 0; i < numberOfFaces; i++) {
            //get the chosen first name
            if (chosenFirstNames[(j * namesPerPage) + i] != "") document.getElementById("inpRecallF" + ((j * namesPerPage) + i)).value = chosenFirstNames[(j * namesPerPage) + i];
            //get the chosen surname
            if (chosenSurnames[(j * namesPerPage) + i] != "") document.getElementById("inpRecallS" + ((j * namesPerPage) + i)).value = chosenSurnames[(j * namesPerPage) + i];

          }
        }
      }
    }

    function checkMoveLocusNumRecall(newPos) {
      var blnMoving = true;
      if (document.getElementById("inpRecall" + curPos).value === "-" || newPos >= amount) {
        blnMoving = false;
      }

      //check current position's input and ensure only digits
      document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + curPos).value.replace(/[^/\d]/, '');

      if (blnMoving) {
        var newLocus = Math.floor(newPos / locusSize);
        var newFirstOfLocus = locusStarts[newLocus];

        var totalSoFar = 0;
        var newMiniGroup = 0;

        for (i = 0; i < miniGroupings.length; i++) {
          totalSoFar += parseFloat(miniGroupings[i]);
          if (newPos - newFirstOfLocus < totalSoFar) {

            //	newPos = Number(parseFloat(newFirstOfLocus) + parseFloat(totalSoFar) - parseFloat(miniGroupings[i]));
            newMiniGroup = i;
            break;
          }
        }


        moveLocusNumRecall(newLocus, newMiniGroup, newPos);
      }
    }

    function moveFocusImagesRecall(newPos) {
      //get current page
      curPage = Math.floor(newPos / imagesPerPage);



      //show/hide correct pages
      for (var i = 0; i < numberOfPages; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + "Recall").style.display = "block";
          if (numberOfPages > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
          if (numberOfPages > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
          }
        }
      }

      if (!ended) {

        if (newPos < amount) {
          document.getElementById("imgRecall" + (curPos)).classList.remove(skin + "imagesSelected");

          document.getElementById("imgRecall" + (newPos)).className = skin + "imagesSelected";
          document.getElementById("inpRecall" + newPos).focus();
          document.getElementById("inpRecall" + newPos).select();

          curPos = newPos;
        }
      }
    }


    function checkMoveFocusImagesRecall(pos) {
      var blnMoving = true;

      //check current position's input and ensure only digits
      document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + curPos).value.replace(/[^/\d]/, '');

      if (blnMoving) {
        moveFocusImagesRecall(pos);
      }
    }

    function checkMoveFocusBinRecall(pos) {
      var blnMoving = true;
      if ((document.getElementById("inpRecall" + curPos).value === "-") || (document.getElementById("inpRecall" + curPos).value === "=")) {
        blnMoving = false;
      }

      //check current position's input and ensure only digits
      document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + curPos).value.replace(/[^0-1]/, '');

      if (blnMoving) {
        moveFocusBinRecall(pos);
      }
    }

    function moveLocusNumRecall(newLocus, newMiniGroup, newPos) {
      if (!ended) {
        var firstOfLocus = locusStarts[curLocus];
        var newFirstOfLocus = locusStarts[newLocus];

        //if moving locus, remove all highlights from curLocus and add highlight to newLocus
        if (curLocus != newLocus) {
          //remove highlights
          document.getElementById("inpRecall" + firstOfLocus).classList.remove(skin + "numbersSelectedRecall");
          document.getElementById("inpRecall" + firstOfLocus).classList.remove(skin + "numbersInGroup");
          document.getElementById("inpRecall" + firstOfLocus).classList.remove(skin + "numbersInLocus");
          document.getElementById("inpRecall" + firstOfLocus).style.backgroundColor = "";
          for (var i = 1; i < locusSize; i++) {
            if (firstOfLocus < amount - i) {
              document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersSelectedRecall");
              document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersInGroup");
              document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersInLocus");
              document.getElementById("inpRecall" + (firstOfLocus + i)).style.backgroundColor = "";
            }
          }
        } else { //not moving locus
          //put selected minigroup back to skin+numbersInLocus
          //*** Could also check if moving miniGroup and if not then just change which is selected

          if (curMiniGroup == newMiniGroup) {
            document.getElementById("inpRecall" + curPos).classList.remove(skin + "numbersSelectedRecall");
          } else {

            //** Really just need to deal with current minigroup (not whole locus) but might take longer to calculate the firstOfMiniGroup? maybe store this
            for (var i = 0; i < locusSize; i++) {
              if (firstOfLocus < amount - i) {
                document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersSelectedRecall");
                document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersInGroup");
                document.getElementById("inpRecall" + (firstOfLocus + i)).classList.add(skin + "numbersInLocus");
              }
            }
          }
        }

        //add highlights
        var totalSoFar = 0;
        for (i = 0; i < miniGroupings.length; i++) {

          //go through all digits in this miniGroup
          for (j = 0; j < miniGroupings[i]; j++) {
            var pos = newFirstOfLocus + totalSoFar + j;
            if (pos < amount) {
              if (i == newMiniGroup) {
                document.getElementById("inpRecall" + pos).classList.add(skin + "numbersInGroup");
              } else {
                document.getElementById("inpRecall" + pos).classList.add(skin + "numbersInLocus");
              }
            }
          }
          totalSoFar += parseFloat(miniGroupings[i]);
        }

        document.getElementById("inpRecall" + newPos).classList.add(skin + "numbersSelectedRecall");

        //get new page if necessary
        var newPage = Math.floor(newPos / numbersPerPage);

        if (newPage != curPage || curPos == 0) {

          //show/hide correct pages
          for (var i = 0; i < numberOfPages; i++) {
            if (i == newPage) {
              document.getElementById("page" + i + "Recall").style.display = "block";

              if (numberOfPages > 1) {
                //highlight this page tab
                document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
              }
            }
            else {
              document.getElementById("page" + i + "Recall").style.display = "none";
              if (numberOfPages > 1) {
                //un-highlight this page tab
                document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
              }
            }
          }
          curPage = newPage;
        }
        curPos = newPos;
        curLocus = newLocus;
        curMiniGroup = newMiniGroup;
        document.getElementById("inpRecall" + newPos).focus();
        document.getElementById("inpRecall" + newPos).select();
      }
    }


    function moveFocusNumRecall(newPos) {

      if (!ended) {
        var newLocus = Math.floor(newPos / locusSize);
        var newFirstOfLocus = locusStarts[newLocus];


        var totalSoFar = 0;
        var newMiniGroup = 0;

        for (i = 0; i < miniGroupings.length; i++) {
          totalSoFar += parseFloat(miniGroupings[i]);
          if (newPos - newFirstOfLocus < totalSoFar) {
            newMiniGroup = i;
            break;
          }
        }


        moveLocusNumRecall(newLocus, newMiniGroup, newPos);

        /*
            //get first of grouping
            var firstOfGroup = curPos - (curPos % grouping);
    	
            if (newPos < amount) {
            //un-highlight current group
            document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
            document.getElementById("inpRecall" + firstOfGroup).className = skin + "numbersRecall";
            for (var i = 1; i < grouping; i++) {
            if (firstOfGroup < amount - i) {
                document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
                    document.getElementById("inpRecall" + (firstOfGroup + i)).className = skin + "numbersRecall";
                }
            }
    	
            //update firstOfGroup
    	
            firstOfGroup = newPos - (newPos % grouping);
    	
    	
            //highlight selected digit and also other digits in group (different colour)
        	
             document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
            document.getElementById("inpRecall" + (firstOfGroup)).className = skin + "numbersInGroup";
            for (var i = 1; i < grouping; i++) {
            if (firstOfGroup < amount - i) {
                document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
                    document.getElementById("inpRecall" + (firstOfGroup + i)).className = skin + "numbersInGroup";
                }
            }
    	
            document.getElementById("inpRecall" + newPos).className = skin + "numbersSelectedRecall";
    	
    	
            //get new page
            var newPage = Math.floor(newPos/numbersPerPage);
            if (newPage != curPage || curPos == 0) {
    	
    	
            //show/hide correct pages
            for (var i = 0; i < numberOfPages; i++) {
                if (i == newPage) {
                    document.getElementById("page" + i + "Recall").style.display = "block";
                	
                if (numberOfPages>1) {
                //highlight this page tab
                document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
                }
                }
                else {
                document.getElementById("page" + i + "Recall").style.display = "none";
                if (numberOfPages>1) {
                //un-highlight this page tab
                document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
                }
                }
            }
            curPage = newPage;
    	
        }
    	
            document.getElementById("inpRecall" + newPos).focus();
            document.getElementById("inpRecall" + newPos).select();
            curPos = newPos;
    	
        }*/
      }

    }

    function shiftNumbersForward() {
      for (var i = amount - 1; i >= curPos + 1; i--) {
        document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
        if (document.getElementById("inpRecall" + Number(i - 1)).classList.contains("markOther")) {
          document.getElementById("inpRecall" + Number(i - 1)).classList.remove("markOther");
          document.getElementById("inpRecall" + i).classList.add("markOther");
        } else {
          document.getElementById("inpRecall" + i).classList.remove("markOther");
        }
      }


      document.getElementById("inpRecall" + curPos).value = "";
      document.getElementById("inpRecall" + curPos).classList.remove("markOther");
    }

    function shiftNumbersBackward() {
      document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + Number(curPos + 1)).value;
      if (document.getElementById("inpRecall" + Number(curPos + 1)).classList.contains("markOther")) {
        document.getElementById("inpRecall" + curPos).classList.add("markOther");
        document.getElementById("inpRecall" + Number(curPos + 1)).classList.remove("markOther");
      }

      for (var i = curPos + 1; i < amount - 1; i++) {

        document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
        if (document.getElementById("inpRecall" + Number(i + 1)).classList.contains("markOther")) {
          document.getElementById("inpRecall" + Number(i + 1)).classList.remove("markOther");
          document.getElementById("inpRecall" + i).classList.add("markOther");
        }

      }
      document.getElementById("inpRecall" + (amount - 1)).value = "";
      document.getElementById("inpRecall" + (amount - 1)).classList.remove("markOther");
      //  movePreviousNumMemo();
      //when you do backwards arrow it doesn't highlighted
      //if text is highlighted or cell is blank then it goes too far to right and deletes current, need to do prev again?!
    }

    /*
    function shiftDataForward() {
        if (currentDiscipline.indexOf("B")>-1) {
            shiftBinForward()		
        }
        else if (currentDiscipline.indexOf("C")>-1) {
            shiftCardsForward()
        } else {
            shiftNumbersForward()
        }
    }
	
    function shiftDataBackward() {
        if (currentDiscipline.indexOf("B")>-1) {
            shiftBinBackward()		
        }
        else if (currentDiscipline.indexOf("C")>-1) {
            shiftCardsBackward()
        } else {
            shiftNumbersBackward()
        }
    }
    */

    //returns the middle (average) font size
    function normalize(fontArray) {
      return Math.floor((fontArray[2] - fontArray[1]) / 2) + fontArray[1];
    }

    //takes in a fontArray in the form ['Font Name', minimumFontSize, maximumFontSize]
    function fontSizeRandomizer(fontArray) {
      var range = fontArray[2] - fontArray[1];
      var randomNumber = Math.random();



      //if the current font size === minimumFontSize, increment font size 75% of the time.
      if (fontSizeNow === fontArray[1]) {
        if (randomNumber < .2) {
          fontSizeNow++;
        } else if (randomNumber < .35) {
          fontSizeNow += 2;
        } else if (randomNumber < .65) {
          fontSizeNow += 3;
        } else if (randomNumber < .75) {
          fontSizeNow += 4;
        } else if (randomNumber < .85) {
          fontSizeNow += 5;
        } else if (randomNumber < .93) {
          fontSizeNow += 6;
        }
        //if the current font size === maximumFontSize, decrement font size 75% of the time.
      } else if (fontSizeNow === fontArray[2]) {
        if (randomNumber < .2) {
          fontSizeNow--;
        } else if (randomNumber < .35) {
          fontSizeNow -= 2;
        } else if (randomNumber < .65) {
          fontSizeNow -= 3;
        } else if (randomNumber < .75) {
          fontSizeNow -= 4;
        } else if (randomNumber < .85) {
          fontSizeNow -= 5;
        } else if (randomNumber < .93) {
          fontSizeNow -= 6;
        }
        //if current font size is neither max nor min, increment 35% of the time, decrement 35% of the time, stay th same 30% of time

      } else if (fontArray[2] - fontSizeNow == -2 || fontArray[1] - fontSizeNow == 2) {
        if (randomNumber > .5) {
          fontSizeNow += 2;
        } else {
          fontSizeNow -= 2;
        }
      } else {
        if (randomNumber > .9) {
          fontSizeNow += 5;
        } else if (randomNumber > .8) {
          fontSizeNow++;
        } else if (randomNumber > .6) {
          fontSizeNow += 3;
        } else if (randomNumber > .4) {
          fontSizeNow -= 3;
        } else if (randomNumber > .2) {
          fontSizeNow -= 5;
        } else if (randomNumber > .1) {
          fontSizeNow--;
        }
      }
      //return [fontName, newFontSize];
      if (fontSizeNow > fontArray[2]) {
        fontSizeNow = fontArray[2];
      } else if (fontSizeNow < fontArray[1]) {
        fontSizeNow = fontArray[1]
      }
      return [fontArray[0], fontSizeNow];
    }

    //Helper function to switch from one font to another while retaining relative font size (somewhat);
    function fontSwitch(fontArray1, fontArray2) {
      if (fontNow === fontArray1) {
        fontNow = fontArray2;

        //if the font is at its minimum for fontA, set it to the minimum for fontB
        if (fontSizeNow === fontArray1[1]) {
          fontSizeNow = fontArray2[1];

          //if the font is at its maximum for fontA, set it to the maximum for fontB
        } else if (fontSizeNow === fontArray1[2]) {
          fontSizeNow = fontArray2[2];

          //if the font is neither max nor min for fontA, set it to the normalized val for fontB
        } else {
          fontSizeNow = normalize(fontArray2);
        }
        return fontSizeRandomizer(fontArray2);
      } else {

        //same stuff going from B to A
        fontNow = fontArray1;

        if (fontSizeNow === fontArray2[1]) {
          fontSizeNow = fontArray1[1];
        } else if (fontSizeNow === fontArray2[2]) {
          fontSizeNow = fontArray1[2];
        } else {
          fontSizeNow = normalize(fontArray1);
        }

        return fontSizeRandomizer(fontArray1);
      }

    }

    function dualFontRandomizer(fontArray1, fontArray2) {
      var fontSizeArray = [];
      //The first digit will always be [fontArray1[0], fontArrayNormalized]
      fontNow = fontArray1;
      fontSizeNow = normalize(fontArray1);
      fontSizeArray.push([fontNow[0], fontSizeNow]);

      //on every even iteration, let there be a chance to switch fonts.  Here that is 67% (changed to 33%)
      for (var r = 1; r < amount; r++) {
        if (r % 2 === 0) {
          if (Math.random() < 0.33) {
            //if fontSwitch activates
            fontSizeArray.push(fontSwitch(fontArray1, fontArray2));

          } else {
            fontSizeArray.push(fontSizeRandomizer(fontNow));
          }
        } else {
          fontSizeArray.push(fontSizeRandomizer(fontNow));
        }
      }
      return fontSizeArray;
    }

    function startBinaryRecall() {

      if (resuming) {
        amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
        separations = JSON.parse(localStorage.getItem("separationsBin"));
        navGroupingsBin = JSON.parse(localStorage.getItem("navGroupingsBin"));
        numberOfPages = Math.ceil(amount / binaryPerPage); //added in case went straight to recall

        //work out number of levels
        var longLine = binaryPerRow;
        binLevels = 1;

        while (longLine % groupingW !== 0) {
          longLine += binaryPerRow;
          binLevels++;
        }

        //restore data
        binaryList = JSON.parse(localStorage.getItem("correctAnswers"));
      }

      ended = false;
      curPos = 0;
      var binaryRecallString = "";

      //add the page links if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusBinRecall(" + binaryPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br/><br />";
        document.getElementById("menuRecallDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuRecallDiv").innerHTML = "";
      }


      //add the recall content
      for (i = 0; i < numberOfPages; i++) {
        if (i < numberOfPages - 1) {
          binaryOnThisPage = binaryPerPage;
        }
        else {
          binaryOnThisPage = amount - i * binaryPerPage;
        }

        binaryRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";

        for (j = 0; j < binaryOnThisPage; j++) {
          currentSquare = i * binaryPerPage + j;
          var nextSquare = 0;
          nextSquare = getNextSquare(currentSquare);

          binaryRecallString += "<td id='tdRecall" + currentSquare + "' class='" + skin + "binaryRecallTD'><input ondblclick='toggleMark(this);' class='" + skin + "binaryRecall' id='inpRecall" + currentSquare + "' maxlength='1'	  onclick='moveFocusBinRecall(" + currentSquare + ")' oninput='checkMoveFocusBinRecall(" + nextSquare + ")'></input><span style='height:10px' class='slash'><sup class='binaryMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";
          //binaryRecallString += "<td id='tdRecall" + currentSquare + "' class='" + skin + "binaryRecallTD'><input class='" + skin + "binaryRecall' id='inpRecall" + currentSquare + "' maxlength='1'	  onclick='moveFocusBinRecall(" + (i * binaryPerPage + j) + ")' oninput='checkMoveFocusBinRecall(" + nextSquare + ")'></input><span style='height:10px' class='slash'><sup class='binaryMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";

          if ((j + 1) % binaryPerRow == 0) {
            if (j + 1 == binaryOnThisPage) {
              binaryRecallString += "</tr></table></div>";

            }

            else {

              binaryRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor(currentSquare / binaryPerRow + 2) + "&nbsp;&nbsp;</td>";



            }

          }

        }

      }


      //kept finish button for recall
      binaryRecallString += "</div><br />";
      //binaryRecallString += "</div><br /><button class='btnDigital finishBtn' onclick='finishRecall();'>Finish</button>";



      document.getElementById("recallContentDiv").innerHTML = binaryRecallString;

      //***FINISH BUTTON kEpT fOr ReCall
      var button = document.createElement("button");
      button.setAttribute("class", "btnDigital finishBtn");
      button.addEventListener("click", confirmFinishRecall);
      button.innerText = "Finish";
      $("#finishBtnDiv").empty();
      document.getElementById("finishBtnDiv").appendChild(button);



      //add intra-group separations
      // if (separations.length > 0) {
      //     for (var i = 0; i < amount; i++) {
      //         if (separations.indexOf((i + 1) % groupingW) > -1 || (i + 1) % groupingW == 0) {
      //             document.getElementById("tdRecall" + i).classList.add("separation");
      //         }

      //     }
      // }

      //add separations
      if (separations.length > 0) {
        let separationIndex = 0; // Initialize the separation index
        let separationCountdown = separations[separationIndex]; // Initialize the separation countdown

        let storedSeparationIndex = 0;
        let storedSeparationCountdown = 0;

        for (var i = 0; i < amount; i++) {
          //if we reach the start of a row save counter settings if we are at row 0 of a big row
          //if this is NOT row 0 in the big row, set the counter settings to what they were at start of last row
          if (i % binaryPerRow === 0) {
            const rowNumber = Math.floor(i / binaryPerRow)
            const rowNumberInBigRow = rowNumber % groupingH;
            if (rowNumberInBigRow === 0) {
              storedSeparationIndex = separationIndex;
              storedSeparationCountdown = separationCountdown;
            } else {
              separationIndex = storedSeparationIndex;
              separationCountdown = storedSeparationCountdown;
            }

          }

          if (separationCountdown === 1) {
            document.getElementById("inpRecall" + i).classList.add("separationRecall");
            // Increment the separation index
            separationIndex++;

            // If the separation index exceeds the separations array length, reset it
            if (separationIndex >= separations.length) {
              separationIndex = 0;
            }

            // Update the separation countdown based on the current separation index
            separationCountdown = separations[separationIndex];
          } else {
            // Decrement the separation countdown for the next iteration
            separationCountdown--;
          }
        }
      }



      if (skin.indexOf('analogue') > -1 && !resuming) {
        var fontSizeArray = dualFontRandomizer(fontReenieBeanie, fontShadowsIntoLight);
        for (var i = 0; i < amount; i++) {
          document.getElementById("inpRecall" + i).style.fontSize = fontSizeArray[i][1];
          document.getElementById("inpRecall" + i).style.fontFamily = fontSizeArray[i][0];
        }

      }



      //restore data if resuming
      if (resuming) {
        restoreBinaryData();
        restoreMarks();
      }


      //go to first digits 
      setTimeout(function () {
        moveFocusBinRecall(0);
      }, 40);

      //$("#spanShift").show();


      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }

      //display memo time
      if (memoTimeNeeded) displayMemoTime();

      //set current position
      curPos = 0;

      //set the timer
      var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
      recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
      (function f() {
        recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
        r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);

        //every 10 seconds, save
        if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
          saveBinaryData();
        }

        //save the elapsed time every second
        localStorage.setItem("timeElapsed", recallTimeDiff);


        //When timer reaches 0, go to score display
        if (recallTimeDiff / 1e3 >= recallTime) {

          finishRecall();
        }
        //Otherwise repeat this function
        else {
          if (!ended || intermediate) {
            myTimer = setTimeout(f, 1000);
          }
        }
      })();


      document.onkeydown = function (e) {
        //If Enter is pressed
        // 	if (e.key == "Enter" && !ended) {
        if (e.key == "Enter" && !ended && !competitionMode) {
          confirmFinishRecall();


        }

        //if right arrow pressed, move on
        //    if (e.key == "ArrowRight" && !ended) {
        if (e.key == "ArrowRight" && !ended) {
          e.preventDefault();
          moveNextBinRecall();
        }


        //if left arrow is pressed to go back
        //   if (e.key == "ArrowLeft" && !ended) {
        if (e.key == "ArrowLeft" && !ended) {
          e.preventDefault();
          movePreviousBinRecall();
        }

        //if up arrow pressed, move up
        //  if (e.key == "ArrowUp" && !ended) {
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveUpBinRecall();
        }

        //if down arrow pressed, move down
        //if (e.key == "ArrowDown" && !ended) {
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveDownBinRecall();
        }


        //if backspace (8) is pressed, 

        //	if (e.key == "Backspace" && !ended) {
        if (e.key == "Backspace" && !ended) {
          e.preventDefault();
          if (document.getElementById("inpRecall" + curPos).value == "") {
            //if nothing in this box, delete the number in previous box and move back to that space
            movePreviousBinRecall();
            document.getElementById("inpRecall" + curPos).value = "";
          } else {
            //else delete what's in this box
            document.getElementById("inpRecall" + curPos).value = "";
          }
        }


        //If + is pressed
        //  if ((e.key == '+' || e.key == '=') && !ended) {
        if ((e.key == "+" || e.key == "=") && !ended) {
          e.preventDefault();
          shiftBinForward();

        }

        //If - is pressed
        //  if ((e.key == '-' || e.key == '-') && !ended) {
        if ((e.key == "-" || e.key == "_") && !ended) {
          e.preventDefault();

          shiftBinBackward();

        }

        //if [ is pressed, previous page
        //if (e.key == ',') {
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusBinRecall(binaryPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        //	if (e.key == '.') {
        if (e.key == '.' && !ended) {
          e.preventDefault();
          if (curPage < numberOfPages - 1) moveFocusBinRecall(binaryPerPage * (curPage + 1));

        }



        //if space is pressed, return to start
        // if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusBinRecall(0);
        }

      };





    }

    function moveFocusBinRecall(newPos) {
      if (!ended && newPos < amount) {
        //get grouping
        const positions = getHighlightPositionsBin(curPos);

        //remove highlight from existing grouping
        for (let i = 0; i < positions.length; i++) {
          if (positions[i] < binaryList.length) {
            document.getElementById("inpRecall" + (positions[i])).classList.remove(skin + "binarySelectedRecall");
            document.getElementById("inpRecall" + (positions[i])).classList.remove(skin + "binaryInGroup");
            document.getElementById("inpRecall" + (positions[i])).style.backgroundColor = "";
          }

        }

        //get new page
        var newPage = Math.floor(newPos / binaryPerPage);
        if (newPage != curPage || curPos == 0) {

          //show/hide correct pages
          for (var i = 0; i < numberOfPages; i++) {
            if (i == newPage) {
              document.getElementById("page" + i + "Recall").style.display = "block";


              if (numberOfPages > 1) {
                //highlight this page tab
                document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
              }
            }
            else {
              document.getElementById("page" + i + "Recall").style.display = "none";
              if (numberOfPages > 1) {
                //un-highlight this page tab
                document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
              }
            }
          }
          curPage = newPage;
        }


        //get grouping
        var newPositions = getHighlightPositionsBin(newPos);

        //add highlight to new grouping

        for (let i = 0; i < newPositions.length; i++) {
          if (newPositions[i] < binaryList.length) {
            if (newPositions[i] === newPos) {
              document.getElementById("inpRecall" + (newPositions[i])).classList.add(skin + "binarySelectedRecall");

            }
            else {
              document.getElementById("inpRecall" + (newPositions[i])).classList.add(skin + "binaryInGroup");
            }
          }

        }

        document.getElementById("inpRecall" + newPos).focus();
        document.getElementById("inpRecall" + newPos).select();
        curPos = newPos;
      }
    }

    function moveUpBinRecall() {

      //if we are on first row, don't move

      if (curPos >= binaryPerRow) {


        moveFocusBinRecall(curPos - binaryPerRow);


      }
    }

    function moveDownBinRecall() {

      //if we are on last row, don't move

      if (curPos + binaryPerRow < amount) {


        moveFocusBinRecall(curPos + binaryPerRow);


      }
    }

    function movePreviousBinRecall() {

      //if we are at start of list, don't move

      if (curPos > 0) {

        moveFocusBinRecall(getPreviousSquare(curPos));


      }


    }

    function moveNextBinRecall() {

      if (curPos < amount - 1) {
        moveFocusBinRecall(getNextSquare(curPos));
      }



    }


    function shiftBinForward() {

      //shift all the cells after this big row
      const curPosBigRowIndex = Math.floor(curPos / (binaryPerRow * groupingH));
      const curPosX = curPos % binaryPerRow;
      const firstIndexOfBigRow = curPosBigRowIndex * groupingH * binaryPerRow;
      const finalIndexOfBigRow = firstIndexOfBigRow + (groupingH * binaryPerRow - 1);

      //everything after this big row
      for (let i = amount - 1; i > finalIndexOfBigRow; i--) {
        if (i % binaryPerRow !== 0) { //not at start of a row                                
          document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
        } else { //at start of a row
          if (groupingH > 1) {
            let cellToCopy = i - 1 - (groupingH - 1) * binaryPerRow;
            if (cellToCopy < 0) cellToCopy = 0;
            document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + cellToCopy).value;
          } else {
            if (i === 1) {
              document.getElementById("inpRecall" + i).value = '';
            } else document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
          }
        }
      }

      //shift cells in this big row if after curPos x-position
      for (let i = finalIndexOfBigRow; i >= firstIndexOfBigRow; i--) {
        if (i < amount) {
          const positionX = i % binaryPerRow

          //only process everything from curPos x-position 
          if (positionX >= curPosX) {
            if (positionX === curPosX) {
              document.getElementById("inpRecall" + i).value = '';
            } else if (i % binaryPerRow !== 0) { //not at start of a row                     
              document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
            } else { //at start of a row
              if (groupingH > 1) {
                let cellToCopy = i - 1 - (groupingH - 1) * binaryPerRow; //60 -> 29
                if (cellToCopy < 0) cellToCopy = 0;
                document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (cellToCopy)).value;
              } else {
                document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
              }
            }
          }
        }
      }
    }

    function shiftBinBackward() {
      const curPosBigRowIndex = Math.floor(curPos / (binaryPerRow * groupingH));
      const curPosX = curPos % binaryPerRow;
      const firstIndexOfBigRow = curPosBigRowIndex * groupingH * binaryPerRow;
      const finalIndexOfBigRow = firstIndexOfBigRow + (groupingH * binaryPerRow - 1);


      //shift cells in this big row if after curPos x-position
      for (let i = firstIndexOfBigRow; i <= finalIndexOfBigRow && i < amount; i++) {
        const positionX = i % binaryPerRow

        //only process everything from curPos x-position 
        if (positionX >= curPosX) {
          if (i % binaryPerRow !== binaryPerRow - 1) { //not at end of a row
            document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
          } else { //at end of a row
            if (groupingH > 1) {
              let cellToCopy = i + 1 + (groupingH - 1) * binaryPerRow; //29 -> 60 if groupingH is 2
              if (cellToCopy < amount) {
                document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (cellToCopy)).value;
              } else document.getElementById("inpRecall" + i).value = '';  //need to make sure final cell and all those above it in its big row are set to blank 
            } else {
              if (i + 1 === amount) {
                document.getElementById("inpRecall" + i).value = '';
              } else document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
            }
          }
        }
      }

      //shift all the cells after this big row

      //everything after this big row
      for (let i = finalIndexOfBigRow + 1; i < amount; i++) {
        if (i % binaryPerRow !== binaryPerRow - 1) { //not at start of a row                                
          document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1))?.value || '';   //changed 7/12/2023 as someone had error here
        } else { //at end of a row
          if (groupingH > 1) {
            let cellToCopy = i + 1 + (groupingH - 1) * binaryPerRow; //29 -> 60 if groupingH is 2
            if (cellToCopy < amount) {
              document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + cellToCopy).value;
            } else document.getElementById("inpRecall" + i).value = '';  //need to make sure final cell and all those above it in its big row are set to blank            
          } else {
            if (i + 1 === amount) {
              document.getElementById("inpRecall" + i).value = '';
            } else document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
          }
        }
      }
    }


    function getNextMatrix(pos) {
      //gets a position in next matrix

      var x = (pos + groupingW) % binaryPerRow; // add imageW onto pos, as long as we don't reach the end of a row
      var y = Math.floor(pos / binaryPerRow); //y (the row) should be the floor of pos/30

      if (pos + groupingW >= (y + 1) * binaryPerRow) {  // if adding groupingW onto pos means we end up on the next row:
        y += groupingH;   //  then we go down by groupingH
      }

      return ((y * binaryPerRow + x) <= (amount - 1)) ? (y * binaryPerRow + x) : -1;

    }

    function getPreviousMatrix(pos) {
      //gets previous matrix
      pos = getHighlightPositionsBin(pos)[0];
      var x = (pos - groupingW) % binaryPerRow; // subtract imageW from pos, as long as we don't reach the start of a row
      var y = Math.floor(pos / binaryPerRow); //y (the row) should be the floor of pos/30

      if (pos - groupingW < y * binaryPerRow) {  // if subtracting groupingW from pos means we end up on the previous row:
        y -= groupingH;   //  then we go up by groupingH
      }


      // if (pos - prevImageW < y * binaryPerRow) {  // if subtrating prevImageW from pos means we end up on the next row:
      //     y -= groupingH;   //  then we go up by groupingH
      // }

      return ((y * binaryPerRow + x) >= 0) ? (y * binaryPerRow + x) : -1;


    }

    function moveFocusCardRecall(newPos) {

      if (newPos < amount * 52 && newPos > -1) {
        //ended || $("#cardRecall" + curPos).toggleClass('cardRecallSelected');
        ended || document.getElementsByClassName("cardRecall")[curPos].classList.remove("cardRecallSelected")

        //get current page
        curPage = Math.floor(newPos / 52);


        //show/hide correct pages
        for (var i = 0; i < amount; i++) {
          if (i == curPage) {
            document.getElementById("page" + i + "Recall").style.display = "block";
            if (amount > 1) {
              //highlight this page tab
              document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
            }
          }
          else {
            document.getElementById("page" + i + "Recall").style.display = "none";
            if (amount > 1) {
              //un-highlight this page tab
              document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
            }
          }
        }
        if (ended) return;

        //$("#cardRecall" + newPos).toggleClass('cardRecallSelected');
        ended || document.getElementsByClassName("cardRecall")[newPos].classList.add("cardRecallSelected");

        curPos = newPos;
      }


    }


    function startImagesRecall() {

      ended = false;
      //curPos = 0;


      if (resuming) {
        amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
        numberOfPages = Math.ceil(amount / imagesPerPage); //added in case went straight to recall

        //restore data
        imageArray = JSON.parse(localStorage.getItem("imageArray"));
        answerArray = JSON.parse(localStorage.getItem("answerArray"));
      } else if (!competitionMode || !preloadAll || competitionTestMode) {
        //shuffle each set of 5 within itself if we are in training mode (or in comp mode but not preloading all, i.e. images preloaded but not from file)

        var setOfFive = [1, 2, 3, 4, 5];
        for (let g = 0; g < amount; g += 5) {
          shuffle(setOfFive);
          answerArray.push(...setOfFive);
        }
        //and save it
        localStorage.setItem("answerArray", JSON.stringify(answerArray));
      }


      var imagesRecallString = "";

      //add the page links if >1 page
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusImagesRecall(" + imagesPerPage * i + ")'>" + (i + 1) + "</a></li>";
        }
        menuString += "</ul><br /><br />";
        document.getElementById("menuRecallDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuRecallDiv").innerHTML = "";
      }




      //add the recall content
      for (i = 0; i < numberOfPages; i++) {
        if (i < numberOfPages - 1) {
          imagesOnThisPage = imagesPerPage;
        }
        else {
          imagesOnThisPage = amount - i * imagesPerPage;
        }

        imagesRecallString += "<div id='page" + i + "Recall'><table class='imageTable' id='recallTable" + i + "'>";


        for (var j = 0; j < imagesOnThisPage; j++) {
          //if we haven't reached the end

          //add row num if needed
          if (j % 5 == 0) {
            imagesRecallString += "<tr><td class='imageRowNumCell'>" + (Math.floor((i * imagesPerPage / 5) + j / 5) + 1) + "</td>";
          }


          //add the next image and a box below it
          //	imagesRecallString += "<td id='tdRecall" + Number(i*imagesPerPage+j) + "'><table><tr><td><img class='imageClass' id='imgRecall" + Number(i*imagesPerPage+j) + "'  src='IAM Images/" + imageArray[i*imagesPerPage+j] + "' height=80></td></tr><tr><td id='inpRecall" + Number(i*imagesPerPage+j) + "'><input type='text'  class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i*imagesPerPage+j) + ")' oninput='checkMoveFocusImagesRecall(" + (i*imagesPerPage+j+1) + ")'></td></tr></table></td>";

          //add image with box before it 
          imagesRecallString += "<td class='" + skin + "imagesRecallTD' ondblclick='toggleMark(this)' id='tdRecall" + Number(i * imagesPerPage + j) + "'><input type='text' id='inpRecall" + Number(i * imagesPerPage + j) + "' class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' oninput='checkMoveFocusImagesRecall(" + (i * imagesPerPage + j + 1) + ")'><img class='imageClass' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' id='imgRecall" + Number(i * imagesPerPage + j) + "'  src='IAM Images/" + imageArray[Math.floor((i * imagesPerPage + j) / 5) * 5 + answerArray[i * imagesPerPage + j] - 1] + "' height=80></td>";


          //close the row if needed and spacer row
          if ((j + 1) % 5 == 0) {
            if (j + 1 == imagesOnThisPage) {
              imagesRecallString += "</tr>";
            } else {
              imagesRecallString += "</tr><tr><td colspan='6' height='20px'></td></tr>";
            }
          }

        }
        imagesRecallString += "</table><br /><button class='btnDigital finishBtn' onclick='confirmFinishRecall();'>Finish</button></div>";
        //	imagesRecallString += "</table><br /></div>";
      }




      imagesRecallString += "</div>";
      /*
      var btn = document.createElement("button");
      var node = document.createTextNode("Finish");
      btn.appendChild(node);
      btn.classList.add("btn");
      btn.classList.add("btn-primary");
      btn.classList.add("finishBtn");*/
      //btn.onclick = finishRecall;
      //"<button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button>"

      document.getElementById("recallContentDiv").innerHTML = imagesRecallString;
      //document.getElementsByClassName("bottom-right-timer")[1].insertBefore(btn,document.getElementById(skin + "RecallTimeOuter"));
      //document.getElementById("buttonGoesHereForImages").appendChild(btn);


      if (skin.indexOf('analogue') > -1 && !resuming) {
        var fontSizeArray = dualFontRandomizer(fontReenieBeanie, fontShadowsIntoLight);
        for (var i = 0; i < amount; i++) {
          document.getElementById("inpRecall" + i).style.fontSize = fontSizeArray[i][1];
          document.getElementById("inpRecall" + i).style.fontFamily = fontSizeArray[i][0];
        }
      }

      //restore data if resuming
      if (resuming) {

        restoreImagesData();
        restoreMarks();
      }

      //go to first digits

      setTimeout(function () {
        moveFocusImagesRecall(0);
      }, 40);


      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }


      //set current position
      curPos = 0;
      curPage = 0;

      //set the timer
      var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

      recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
      (function f() {
        recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
        r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
        //ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
        //r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

        //every 10 seconds, save
        if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
          saveImagesData();
        }

        //save the elapsed time every second
        localStorage.setItem("timeElapsed", recallTimeDiff);


        //When timer reaches 0, go to score display
        if (recallTimeDiff / 1e3 >= recallTime) {

          finishRecall();
        }
        //Otherwise repeat this function
        else {
          if (!ended || intermediate) {
            myTimer = setTimeout(f, 1000);
          }
        }
      })();

      //display memo time
      if (memoTimeNeeded) displayMemoTime();


      document.onkeydown = function (e) {

        //If Enter is pressed
        if (e.key == "Enter" && !ended && !competitionMode) {
          confirmFinishRecall();

        }

        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          e.preventDefault();
          moveNextImagesRecall();
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          e.preventDefault();
          movePreviousImagesRecall();
        }

        //if up arrow pressed, move up
        if (e.key == "ArrowUp" && !ended) {
          e.preventDefault();
          moveUpImagesRecall();
        }

        //if down arrow pressed, move down
        if (e.key == "ArrowDown" && !ended) {
          e.preventDefault();
          moveDownImagesRecall();
        }

        //if backspace (8) is pressed, delete the number in previous box and move back to that space
        if ((e.key == "Backspace") && !ended) {
          e.preventDefault();
          console.log("deleted in images recall");
          movePreviousImagesRecall();
          document.getElementById("inpRecall" + curPos).value = "";
        }

        //if [ is pressed, previous page
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusImagesRecall(imagesPerPage * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.') {
          e.preventDefault();
          if (curPage < numberOfPages - 1) moveFocusImagesRecall(imagesPerPage * (curPage + 1));

        }



        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusImagesRecall(0);
        }

      };


    }

    function moveNextImagesRecall() {
      //check if skipping and if this is the final image
      if (curPos + 1 < amount) {

        moveFocusImagesRecall(curPos + 1);

      }
    }

    function movePreviousImagesRecall() {
      //check if skipping and if this is the final image
      if (curPos > 0) {

        moveFocusImagesRecall(curPos - 1);

      }
    }

    function moveUpImagesRecall() {
      if (curPos >= 5) {

        moveFocusImagesRecall(curPos - 5);

      }
    }


    function moveDownImagesRecall() {
      if (curPos + 5 < amount) {

        moveFocusImagesRecall(curPos + 5);

      }
    }

    function intermediateScreen() {
      document.getElementById("menuRecallDiv").style.display = "none";
      document.getElementById("recallContentDiv").style.display = "none";
      document.getElementById("analogueCardsRecallContentDiv").style.display = "none";
      document.getElementById("intermediateDiv").style.display = "block";
      document.getElementById("finishBtnDiv").style.display = "none";

      intermediate = true;
      ended = true;
    }


    function intermediateScreenSR() {
      document.getElementById("menuDiv").style.display = "none";
      document.getElementById("memoContentDiv").style.display = "none";
      document.getElementById("analogueCardsMemoContentDiv").style.display = "none";

      document.getElementById("memoRow").style.display = "block";
      document.getElementById("bottomRightTimerDiv").style.display = "none";
      document.getElementById("digital1MemoTimeOuter").style.display = "none";
      document.getElementById("intermediateDivSR").style.display = "block";
      if (currentDiscipline === "SC" || currentDiscipline === "TC") {
        document.getElementById("intermediateDivMemoTime").style.display = "block";
        document.getElementById("intermediateDivMemoTime").innerHTML = "Memorisation time: " + memoTimeTaken / 1000;
      }

      intermediateSR = true;

    }

    function confirmFinishMemo() {
      if (confirm("Are you sure you wish to finish memorisation now?")) {
        memoTimeNeeded = true;
        finishMemo();
      }
    }

    function confirmFinishRecall() {
      if (confirm("Are you sure you wish to finish recall now?")) {
        //INTERMEDIATE SCREEN ONLY FOR COMPETITION MODE
        if (competitionMode) {
          intermediateScreen();
        } else {
          finishRecall();
        }
      }
    }

    function finishRecall(test = false) {

      if (test) {
        goToSettings();
        return;
      }

      document.getElementById("intermediateDiv").style.display = "none";
      intermediate = false;

      recallTimeTaken = Date.now() - recallStart;

      //Clear display
      document.getElementById("recallRow").style.display = "none";

      //set ended to true
      ended = true;
      clearTimeout(myTimer);
      resuming = false;
      localStorage.setItem("phase", "score");

      //Score
      displayScore();


    }


    function displayScore() {
      ended = true;
      document.getElementById("scoreContentDiv").innerHTML = "";
      document.getElementById("analogueCardsScoreContentDiv").innerHTML = "";
      //Display score section only
      document.getElementById("selectionRow").style = "display:none";	//added in case we are resuming and go straight from selection to score
      document.getElementById("countdownRow").style = "display:none";
      document.getElementById("recallRow").style = "display:none";
      document.getElementById("scoreRow").style = "display:none";

      //show logo and main back button only if digital theme
      //*** display logo on score page for digital theme but it shifts everything, but if you comment out line 8539 then it goes full height
      document.getElementById("logoRow").style = (skin.indexOf("analogue") > -1) ? "display:none" : "display:block";
      document.getElementById("btnBackToSelection").style = (skin.indexOf("analogue") > -1) ? "display:none" : "display:inline";

      //  document.getElementById("btnSubmitScore").style = (skin.indexOf("analogue")>-1) ? "display:none" : "display:inline";

      if (competitionMode) {
        if (skin.indexOf("analogue") > -1) {
          document.getElementById("submitScoreAnalogue").style = "display:inline";
          if (submitScoreOption == "copy") {
            document.getElementById("submitScoreAnalogue").innerHTML = "COPY SCORE";
          } else {
            document.getElementById("submitScoreAnalogue").innerHTML = "EMAIL SCORE";
          }
          document.getElementById("btnSubmitScore").style = "display:none";
        } else {
          document.getElementById("submitScoreAnalogue").style = "display:none";
          if (submitScoreOption == "email" || submitScoreOption == "copy") {
            document.getElementById("btnSubmitScore").style = "display:inline";
            if (submitScoreOption == "copy") {
              document.getElementById("btnSubmitScore").innerHTML = "COPY SCORE";
            } else {
              document.getElementById("btnSubmitScore").innerHTML = "EMAIL SCORE";
            }
          }
        }


      } else {
        document.getElementById("btnSubmitScore").style = "display:none";
        document.getElementById("submitScoreAnalogue").style = "display:none";
      }

      //show bottom row back button and top margin only if analogue theme
      document.getElementById("bottomRow").style = (skin.indexOf("analogue") > -1) ? "display:block" : "display:none";
      document.getElementById("topMargin").style = (skin.indexOf("analogue") > -1) ? "display:block" : "display:none";
      //document.getElementById("topMargin").style = "display:block";

      //Display relevant score screen depending on discipline
      switch (currentDiscipline) {
        case "5N":
        case "15N":
        case "30N":
        case "60N":
        case "TN":
        case "K1":
        case "K2":
        case "K3":
          displayNumberScore();
          break;
        case "5B":
        case "30B":
        case "TB":
          displayBinaryScore();
          break;
        case "10C":
        case "30C":
        case "60C":
        case "SC":
        case "SXC":
        case "TXC":
        case "TC":
          displayCardScore();
          break;
        case "D":
        case "TD":
          displayDateScore();
          break;
        case "5F":
        case "15F":
        case "TF":
          displayNamesScore();
          break;
        case "5W":
        case "15W":
        case "TW":
          displayWordsScore();
          break;
        case "S":
          displaySpokenScore();
          break;
        default:
          displayImagesScore();
      }
    }


    function displaySpokenScore() {

    }

    function displayNumberScore() {
      var broken = false; //this is for Spoken

      if (resuming) {
        numberList = JSON.parse(localStorage.getItem("correctAnswers"));
        amount = localStorage.getItem("amount");
        numberOfPages = Math.ceil(amount / numbersPerPage);
      } else {
        saveNumbersData();
      }
      var score = 0;
      var rowNum = 0;
      var menuString = "";
      var scoreString = "";
      curPage = 0;

      //collect answers into a new array
      chosenAnswers = [];

      if (resuming) {
        chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

        //add the recall content
        var numberRecallString = "";

        for (i = 0; i < numberOfPages; i++) {
          if (i < numberOfPages - 1) {
            numbersOnThisPage = numbersPerPage;
          }
          else {
            numbersOnThisPage = amount - i * numbersPerPage;
          }

          numberRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";

          for (j = 0; j < numbersOnThisPage; j++) {
            numberRecallString += "<td id='tdRecall" + (i * numbersPerPage + j) + "' class='" + skin + "numbersRecallTD'><input class='" + skin + "numbersRecall' id='inpRecall" + (i * numbersPerPage + j) + "' maxlength='1'	  onclick='moveFocusNumRecall(" + (i * numbersPerPage + j) + ")' oninput='checkMoveLocusNumRecall(" + (i * numbersPerPage + j + 1) + ")'></input><span style='height:10px' class='slash'><sup class='digitMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";
            if ((j + 1) % numbersPerRow == 0) {
              if (j + 1 == numbersOnThisPage) {
                numberRecallString += "</tr></table></div>";
              }
              else {
                numberRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage + j) / numbersPerRow + 2) + "&nbsp;&nbsp;</td>";
              }
            }

          }

        }

        document.getElementById("scoreContentDiv").innerHTML = numberRecallString;

        //add separations
        if (separations.length > 0) {
          for (var i = 0; i < amount; i++) {
            if (separations.indexOf((i + 1) % locusSize) > -1 || (i + 1) % locusSize == 0) {
              document.getElementById("tdRecall" + i).classList.add("separation");
            }

          }
        }
      }

      //add the page links if >1 page
      if (numberOfPages > 1) {

        menuString += "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkScore' class='" + skin + "pagelink' onclick='moveFocusNumScore(" + i * numbersPerPage + ")'>" + (i + 1) + "</a></li>";
        }


        menuString += "</ul><br/>";
        document.getElementById("menuScoreDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuScoreDiv").innerHTML = "";
      }


      //for every page
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many digits on page
        if (j < numberOfPages - 1) {
          numberOfDigits = numbersPerPage;
        }
        else {
          numberOfDigits = amount - j * numbersPerPage;
        }

        //add the start tags for the div (with page number) and table

        //loop through the digits on the page
        for (var i = 0; i < numberOfDigits; i++) {

          //get the chosen answer for the digit
          if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).value);
          var chosenAnswer = chosenAnswers[((j * numbersPerPage) + i)];
          var correctAnswer = numberList[((j * numbersPerPage) + i)];

          //add the correct answer to the correction row string
          //correctionRowString += "<td class='correction shadowyScore' id='scoreCorr" + ((j*numbersPerPage)+i) + "''>" + correctAnswer + "</td>";

          if (chosenAnswer == correctAnswer && chosenAnswer.length > 0) {
            score++; //if Spoken, don't add on to score if already got one wrong
            document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).classList.add(skin + "correct");

          }
          else {

            if (currentDiscipline.indexOf("K") > -1) {
              if (!broken) totalEval = score;
              broken = true;
            }


            if (chosenAnswer.length === 0) {
              //nothing chosen
              if (skin.indexOf('analogue') > -1) {
                //20-07-2018 add marking sup 
                //22-07-2018 marking sup and sub exist already; just add correct answer			
                document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;
              }
              else {
                //22-07-2018 add mouseover
                //currently not adding anything if they didn't enter a digit
                //scoreString += "<td class='" + skin + "score' onmouseover='showCorrect(" + ((j*numbersPerPage)+i) + ")' onmouseout='showChosen(" + ((j*numbersPerPage)+i) + ")' id='score" + ((j*numbersPerPage)+i) + "'></td>";
              }
            }
            else {

              if (skin.indexOf('analogue') > -1) {
                //22-07-2018 marking sup and sub exist already; just add correct answer
                //also need an X in the sub
                console.log("adding x to " + ((j * numbersPerPage) + i));
                document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;
                document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).parentNode.childNodes[1].childNodes[1].innerHTML = "x";
              }
              else {
                //22-07-2018 add mouseover
                //  scoreString += "<td class='" + skin + "score " + skin + "incorrect' onmouseover='showCorrect(" + ((j*numbersPerPage)+i) + ")' onmouseout='showChosen(" + ((j*numbersPerPage)+i) + ")' id='score" + ((j*numbersPerPage)+i) + "'>" + chosenAnswer + "</td>";
                document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).classList.add(skin + "incorrect");
              }
            }
          }



        }

        //if all correct, then totalEval is equal to the score
        if (currentDiscipline.indexOf("K") > -1) {
          if (!broken) totalEval = score;

        }
      }


      if (!resuming) {
        document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
        document.getElementById("recallContentDiv").innerHTML = "";
      }



      //deselect current position and group
      document.getElementById("inpRecall" + curPos).classList.add(skin + "numbersRecall");
      document.getElementById("inpRecall" + curPos).classList.remove(skin + "numbersSelectedRecall");
      var firstOfGroup = curPos - (curPos % grouping);
      for (var i = 0; i < grouping; i++) {
        //check that firstOfGroup + i isn't greater than total amount - for Spoken where we don't always have 40 in a row
        if (firstOfGroup + i < amount) {
          document.getElementById("inpRecall" + (firstOfGroup + i)).classList.remove(skin + "numbersInGroup");
          document.getElementById("inpRecall" + (firstOfGroup + i)).classList.add(skin + "numbersRecall");
        }
      }


      //mouseover handlers here for digital only
      if (skin.indexOf('digital') > -1) {
        for (var m = 0; m < amount; m++) {
          if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
            $("#inpRecall" + m).mouseover(function (ev) {
              showCorrect(ev.target.id.match(/\d+/g));
            });
            $("#inpRecall" + m).mouseout(function (ev) {
              showChosen(ev.target.id.match(/\d+/g));
            });
          }
        }
      }


      //add the chosen answers
      for (var i = 0; i < amount; i++) {
        document.getElementById("inpRecall" + i).value = chosenAnswers[i];
        document.getElementById("inpRecall" + i).setAttribute("readonly", "");



      }



      if (numberOfPages > 1) {
        document.getElementById("page0tablinkScore").className = skin + "pagelinkred";
      }

      for (var i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }


      if (currentDiscipline.indexOf("K") > -1) {
        //totalEval = score;
        //totalEval now worked out at the time of first mistake
      } else {
        totalEval = 0;



        //calculate the number of rows
        if (amount % numbersPerRow == 0) {
          numberOfRows = amount / numbersPerRow;
        }
        else {
          numberOfRows = Math.floor(amount / numbersPerRow) + 1;
        }

        var lastRow = 0;

        //find last non-empty row
        for (var i = numberOfRows - 1; i > -1; i--) {
          for (var j = 0; j < numbersPerRow; j++) {
            //check that we only go as far as the amount; see if there is an answer in each cell
            if (numbersPerRow * i + j < amount && chosenAnswers[numbersPerRow * i + j].length > 0) {
              //if we find a digit, this is the last row
              lastRow = i;
              //change conditions to break out of loop
              j = numbersPerRow;
              i = 0;
            }
          }
        }


        //go through from row 0 to last row
        var rowLength = 0;

        for (var i = 0; i <= lastRow; i++) {
          var incorrectThisRow = 0;

          //calculate row length
          if (i == lastRow) {
            //check how many in last row - remembering this may not be the actual last row on page, just the last filled one
            var numbersInLastRow = (amount % numbersPerRow == 0 || lastRow != numberOfRows - 1) ? numbersPerRow : amount % numbersPerRow;

            //go through row and see how many in row
            for (var j = numbersInLastRow - 1; j >= 0; j--) {
              if (chosenAnswers[numbersInLastRow * i + j].length !== 0) {
                rowLength = j + 1;
                j = -1;
              }
            }

          }
          else {
            rowLength = numbersPerRow;
          }

          //go through row and see how many incorrect
          for (var j = 0; j < rowLength; j++) {
            if (chosenAnswers[numbersPerRow * i + j] == "" || Number(chosenAnswers[numbersPerRow * i + j]) !== Number(numberList[numbersPerRow * i + j])) {
              incorrectThisRow++;
            }
            if (incorrectThisRow == 2) {
              thisRowEval = 0;
              j = rowLength;
            }
          }


          if (incorrectThisRow == 1) {
            //special case: if only one digit and it's wrong, score 0
            thisRowEval = rowLength == 1 ? 0 : Math.ceil(rowLength / 2);
          }
          if (incorrectThisRow == 0) {
            thisRowEval = rowLength;
          }
          totalEval += thisRowEval;
        }

      }

      document.getElementById("spanScore").innerHTML = totalEval;
      scoreInfo = encryptWithAES("Discipline: " + lookupProperty(currentDiscipline, "label") + (currentDiscipline === '5N' ? " Trial " + trialNo : "") + " // Score: " + totalEval.toString() + " // Timestamp: " + getTimestamp());
      document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + score + " correct)";

      if (memoTimeNeeded) displayMemoTimeScore();

      $(".finishBtn").hide();

      document.getElementById("scoreRow").style.display = "block";


      if (resuming) {
        document.onkeydown = function (e) {
          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusNumberRecall(numbersPerPage * (curPage - 1));
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusNumberRecall(numbersPerPage * (curPage + 1));
          }


        };

      } else {
        document.onkeydown = function (e) {

          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusNumScore(numbersPerPage * (curPage - 1));
            //if (curPage>0) displayPage(curPage-1);
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusNumScore(numbersPerPage * (curPage + 1));

          }

        };

      }

    }

    function moveFocusNumScore(newPos) {

      //get current page
      curPage = Math.floor(newPos / numbersPerPage);

      //show/hide correct pages
      for (i = 0; i < numberOfPages; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + "Recall").style.display = "block";
          if (numberOfPages > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablinkScore").className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
          if (numberOfPages > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablinkScore").className = skin + "pagelink";
          }
        }
      }

    }

    function moveFocusBinScore(newPos) {

      //get current page
      curPage = Math.floor(newPos / binaryPerPage);

      //show/hide correct pages
      for (i = 0; i < numberOfPages; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + "Recall").style.display = "block";
          if (numberOfPages > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablinkScore").className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
          if (numberOfPages > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablinkScore").className = skin + "pagelink";
          }
        }
      }

    }

    function moveFocusCardScore(newPos) {

      //get current page
      curPage = Math.floor(newPos / 52);

      //show/hide correct pages
      for (i = 0; i < amount; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + "Recall").style.display = "block";
          if (amount > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
          if (amount > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
          }
        }
      }
      // $("#cardRecall" + newPos).toggleClass("cardRecallSelected");
    }

    function displayMemoTime() {
      if (skin.indexOf('analogue') > -1 && currentDiscipline.includes("C")) {
        $("#cardsMemoTimeScore").css("color", "white");
      } else {
        $("#cardsMemoTimeScore").css("color", "black");
      }
      //display memo time
      $("#cardsMemoTime").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));
    }

    function displayMemoTimeScore() {
      if (skin.indexOf('analogue') > -1 && currentDiscipline.includes("C")) {
        $("#cardsMemoTimeScore").css("color", "white");
      } else {
        $("#cardsMemoTimeScore").css("color", "black");
      }
      //display memo time
      $("#cardsMemoTimeScore").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));
    }

    function displayBinaryScore() {

      if (resuming) {
        binaryList = JSON.parse(localStorage.getItem("correctAnswers"));
        amount = localStorage.getItem("amount");
        numberOfPages = Math.ceil(amount / binaryPerPage);
        separations = JSON.parse(localStorage.getItem("separationsBin"));

      } else {
        saveBinaryData();
      }


      var score = 0;
      var rowNum = 0;
      var menuString = "";
      curPage = 0;

      //collect answers into a new array
      chosenAnswers = [];

      if (resuming) {
        chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

        //add the recall content
        var binaryRecallString = "";

        for (i = 0; i < numberOfPages; i++) {
          if (i < numberOfPages - 1) {
            binaryOnThisPage = binaryPerPage;
          }
          else {
            binaryOnThisPage = amount - i * binaryPerPage;
          }

          binaryRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";

          for (j = 0; j < binaryOnThisPage; j++) {
            currentSquare = i * binaryPerPage + j;
            var nextSquare = 0;
            nextSquare = getNextSquare(currentSquare);

            binaryRecallString += "<td id='tdRecall" + currentSquare + "' class='" + skin + "binaryRecallTD'><input class='" + skin + "binaryRecall' id='inpRecall" + currentSquare + "' maxlength='1'	  onclick='moveFocusBinRecall(" + (i * binaryPerPage + j) + ")' oninput='checkMoveFocusBinRecall(" + nextSquare + ")'></input><span style='height:10px' class='slash'><sup class='binaryMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";

            if ((j + 1) % binaryPerRow == 0) {
              if (j + 1 == binaryOnThisPage) {
                binaryRecallString += "</tr></table></div>";

              }

              else {

                binaryRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor(currentSquare / binaryPerRow + 2) + "&nbsp;&nbsp;</td>";

              }
            }
          }
        }

        document.getElementById("scoreContentDiv").innerHTML = binaryRecallString;

        //add separations
        //add intra-group separations
        // if (separations.length > 0) {
        //     for (var i = 0; i < amount; i++) {
        //         if (separations.indexOf((i + 1) % groupingW) > -1 || (i + 1) % groupingW == 0) {
        //             document.getElementById("tdRecall" + i).classList.add("separation");
        //         }
        //     }
        // }

        //add separations
        if (separations.length > 0) {
          let separationIndex = 0; // Initialize the separation index
          let separationCountdown = separations[separationIndex]; // Initialize the separation countdown

          let storedSeparationIndex = 0;
          let storedSeparationCountdown = 0;

          for (var i = 0; i < amount; i++) {
            //if we reach the start of a row save counter settings if we are at row 0 of a big row
            //if this is NOT row 0 in the big row, set the counter settings to what they were at start of last row
            if (i % binaryPerRow === 0) {
              const rowNumber = Math.floor(i / binaryPerRow)
              const rowNumberInBigRow = rowNumber % groupingH;
              if (rowNumberInBigRow === 0) {
                storedSeparationIndex = separationIndex;
                storedSeparationCountdown = separationCountdown;
              } else {
                separationIndex = storedSeparationIndex;
                separationCountdown = storedSeparationCountdown;
              }

            }

            if (separationCountdown === 1) {
              document.getElementById("inpRecall" + i).classList.add("separationRecall");
              // Increment the separation index
              separationIndex++;

              // If the separation index exceeds the separations array length, reset it
              if (separationIndex >= separations.length) {
                separationIndex = 0;
              }

              // Update the separation countdown based on the current separation index
              separationCountdown = separations[separationIndex];
            } else {
              // Decrement the separation countdown for the next iteration
              separationCountdown--;
            }
          }
        }

      }

      //add the page links if >1 page
      if (numberOfPages > 1) {

        menuString += "<ul class='menu'>";

        for (i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkScore' class='" + skin + "pagelink' onclick='moveFocusBinScore(" + i * binaryPerPage + ")'>" + (i + 1) + "</a></li>";
        }


        menuString += "</ul><br/><br />";
        document.getElementById("menuScoreDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuScoreDiv").innerHTML = "";
      }


      //for every page
      for (var j = 0; j < numberOfPages; j++) {
        //calculate how many digits on page
        if (j < numberOfPages - 1) {
          numberOfDigits = binaryPerPage;
        }
        else {
          numberOfDigits = amount - j * binaryPerPage;
        }

        //loop through the digits on the page
        for (var i = 0; i < numberOfDigits; i++) {

          //get the chosen answer for the digit
          if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).value);
          var chosenAnswer = chosenAnswers[((j * binaryPerPage) + i)];
          var correctAnswer = binaryList[((j * binaryPerPage) + i)];

          //add the correct answer to the correction row string


          if (chosenAnswer == correctAnswer && chosenAnswer.length > 0) {
            score++;
            document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).classList.add(skin + "correct");
          }
          else {

            if (chosenAnswer.length === 0) {
              //nothing chosen
              if (skin.indexOf('analogue') > -1) {
                document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;

              }
              else {
                //23-07-2018 add mouseover
                //do we make it red if nothing entered?
                //		document.getElementById("inpRecall" + ((j*binaryPerPage)+i)).classList.add(skin + "incorrect");
              }
            }
            else {

              if (skin.indexOf('analogue') > -1) {

                console.log("adding x to " + ((j * binaryPerPage) + i));
                document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;
                document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).parentNode.childNodes[1].childNodes[1].innerHTML = "x";
                //document.getElementById("inpRecall" + ((j*binaryPerPage)+i)).parentNode.childNodes[1].childNodes[0].style.display = "block";
                //document.getElementById("inpRecall" + ((j*binaryPerPage)+i)).parentNode.childNodes[1].childNodes[1].style.display = "block";
              }
              else {
                //23-07-2018 add mouseover and green/red
                document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).classList.add(skin + "incorrect");
              }
            }
          }




        }



      }


      if (!resuming) {
        document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
        document.getElementById("recallContentDiv").innerHTML = "";
      }



      //deselect current position and group
      //get grouping
      var positions = getHighlightPositionsBin(curPos);
      document.getElementById("inpRecall" + curPos).classList.remove(skin + "binarySelectedRecall");
      document.getElementById("inpRecall" + curPos).classList.add(skin + "binaryRecall");
      //remove highlight from existing grouping

      for (var i = 0; i < positions.length; i++) {
        if (positions[i] < binaryList.length) {
          document.getElementById("inpRecall" + (positions[i])).classList.remove(skin + "binaryInGroup");
          document.getElementById("inpRecall" + (positions[i])).classList.add(skin + "binaryRecall");
        }

      }


      //mouseover handlers here for digital only
      if (skin.indexOf('digital') > -1) {
        for (var m = 0; m < amount; m++) {
          if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
            $("#inpRecall" + m).mouseover(function (ev) {
              showCorrect(ev.target.id.match(/\d+/g));
            });
            $("#inpRecall" + m).mouseout(function (ev) {
              showChosen(ev.target.id.match(/\d+/g));
            });
          }
        }
      }


      //add the chosen answers
      for (var i = 0; i < amount; i++) {
        document.getElementById("inpRecall" + i).value = chosenAnswers[i];
        document.getElementById("inpRecall" + i).setAttribute("readonly", "");



      }



      if (numberOfPages > 1) {
        document.getElementById("page0tablinkScore").className = skin + "pagelinkred";
      }

      for (i = 0; i < numberOfPages; i++) {
        if (i == 0) {
          document.getElementById("page" + i + "Recall").style.display = "block";
        }
        else {
          document.getElementById("page" + i + "Recall").style.display = "none";
        }
      }


      totalEval = 0;

      //calculate the number of rows
      if (amount % binaryPerRow == 0) {
        numberOfRows = amount / binaryPerRow;
      }
      else {
        numberOfRows = Math.floor(amount / binaryPerRow) + 1;
      }

      var lastRow = 0;

      //find last non-empty row
      for (i = numberOfRows - 1; i > -1; i--) {
        for (j = 0; j < binaryPerRow; j++) {
          //check that we only go as far as the amount; see if there is an answer in each cell
          if (binaryPerRow * i + j >= amount || chosenAnswers[binaryPerRow * i + j].length > 0) {
            lastRow = i;
            j = binaryPerRow;
            i = 0;
          }
        }
      }

      var rowLength = 0;

      //go through from row 0 to last row
      for (i = 0; i <= lastRow; i++) {
        var incorrectThisRow = 0;

        //calculate row length
        if (i == lastRow) {
          //check how many in last row
          var binaryInLastRow = (amount % binaryPerRow == 0 || lastRow != numberOfRows - 1) ? binaryPerRow : amount % binaryPerRow;

          //go through row and see how many in row
          for (j = binaryInLastRow - 1; j >= 0; j--) {
            if (chosenAnswers[binaryInLastRow * i + j].length !== 0) {
              rowLength = j + 1;
              j = -1;
            }
          }

          console.log("rowLength:" + rowLength);
        }
        else {
          rowLength = binaryPerRow;
        }

        //go through row and see how many incorrect
        for (j = 0; j < rowLength; j++) {
          if (chosenAnswers[binaryPerRow * i + j] == "" || Number(chosenAnswers[binaryPerRow * i + j]) != binaryList[binaryPerRow * i + j]) {
            console.log(j + " is incorrect");
            incorrectThisRow++;
          }
          if (incorrectThisRow == 2) {
            thisRowEval = 0;
            j = rowLength;
          }
        }
        if (i == lastRow) console.log("incorrect this row: " + incorrectThisRow);

        if (incorrectThisRow == 1) {
          //special case - if only one digit and it's wrong then score 0
          thisRowEval = rowLength == 1 ? 0 : Math.ceil(rowLength / 2);
        }
        if (incorrectThisRow == 0) {
          thisRowEval = rowLength;
        }
        totalEval += thisRowEval;
      }

      document.getElementById("spanScore").innerHTML = totalEval;
      scoreInfo = encryptWithAES("Discipline: " + lookupProperty(currentDiscipline, "label") + " // Score: " + totalEval.toString() + " // Timestamp: " + getTimestamp());
      document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + score + " correct)";

      //display memo time
      if (memoTimeNeeded) displayMemoTimeScore();

      $(".finishBtn").hide();

      document.getElementById("scoreRow").style.display = "block";

      if (resuming) {
        document.onkeydown = function (e) {
          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusBinScore(binaryPerPage * (curPage - 1));
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusBinScore(binaryPerPage * (curPage + 1));
          }


        };


      } else {
        document.onkeydown = function (e) {

          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusBinScore(binaryPerPage * (curPage - 1));
            //if (curPage>0) displayPage(curPage-1);
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusBinScore(binaryPerPage * (curPage + 1));

          }

        };

      }

    }

    function startCardRecall(test = false) {
      document.getElementById("analogueCardsRecallContentDiv").innerHTML = "";
      document.getElementById("recallContentDiv").innerHTML = "";
      if (skin.indexOf("analogue") > -1) {
        $("#recallBox").addClass("analogue1boxGreen");
        $("#recallBox").removeClass("analogue1boxB");

      }
      ended = false;

      // If doing right to left and starting from right, we add the cards backwards so 1 is at bottom right
      let cardsLeftToRight, startFromRight;

      if (resuming) {
        amount = Number(localStorage.getItem("amount")); //added in case going straight to recall

        //restore data
        cardList = JSON.parse(localStorage.getItem("correctAnswers"));

        cardsLeftToRight = localStorage.getItem("cardsLeftToRight");
        startFromRight = localStorage.getItem("startFromRight");

        memoTimeTaken = localStorage.getItem("memoTimeTaken");
      } else {
        cardsLeftToRight = document.getElementById("chkLeftToRight").checked;
        startFromRight = cardsLeftToRight ? false : document.getElementById("chkStartRecallRight").checked;

      }

      if (currentDiscipline.indexOf("SC") > -1 || memoTimeNeeded) {
        $("#cardsMemoTime").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));
        localStorage.setItem("memoTimeTaken", memoTimeTaken);
      }

      //reset boneyard array
      boneyardArray = [];


      //add the page links if >1 page
      if (amount > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < amount; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusCardRecall(" + 52 * i + ")'>" + (i + 1) + "</a></li>";

        }
        menuString += "</ul><br/><br /><br />";

        document.getElementById("menuRecallDiv").innerHTML = menuString;

      } else {
        document.getElementById("menuRecallDiv").innerHTML = "<br /><br /><br />";
      }



      document.getElementById("recallContentDiv").innerHTML = "<br/><br/>";
      //add extra lines
      //add three more rows if we are doing more than 26 decks, otherwise the page numbers overlap the numbers

      if (skin.indexOf("analogue") > -1) {
        if (amount > 26) document.getElementById("analogueCardsRecallContentDiv").innerHTML += "<br /><br /><br />";
        if (amount > 52) document.getElementById("analogueCardsRecallContentDiv").innerHTML += "<br /><br /><br />";
        if (amount <= 26) document.getElementById("analogueCardsRecallContentDiv").innerHTML += "<br /><br />";
      } else {
        if (amount > 26) document.getElementById("recallContentDiv").innerHTML += "<br /><br /><br />";
        if (amount > 52) document.getElementById("recallContentDiv").innerHTML += "<br /><br /><br />";
      }

      for (var d = 0; d < amount; d++) {

        var cardPage = document.createElement("div");
        cardPage.setAttribute("id", "page" + d + "Recall");
        cardPage.setAttribute("style", "position:relative");
        var cardContainer1 = document.createElement("div");
        var cardContainer2 = document.createElement("div");
        cardContainer1.classList.add("cardContainer");
        cardContainer2.classList.add("cardContainer");


        if (startFromRight) {
          cardContainer1.classList.add("reverseCards");
          cardContainer2.classList.add("reverseCards");
        } else {
          cardContainer1.classList.remove("reverseCards");
          cardContainer2.classList.remove("reverseCards");
        }

        //ADD RECALL SECTION (cardContainer)

        for (let i = 0; i < 52; i++) {

          var individualCardDiv = document.createElement("div");

          if (!startFromRight && i > 25) {

            individualCardDiv.classList.add("secondRow");

          }

          if (startFromRight && i <= 25) {
            individualCardDiv.classList.add("secondRow");

          }

          var individualCardNum = document.createElement("div");
          var individualCardImg = document.createElement("img");
          individualCardImg.setAttribute("src", "Card images " + cardSet + "/back.png");
          individualCardDiv.classList.add("cardDiv");
          individualCardImg.classList.add("cardRecall");
          individualCardNum.classList.add("cardRecallNum");
          //let cardIndexInDeck = startFromRight ? 51 - i : i
          //individualCardNum.innerText = (cardIndexInDeck + 1).toString();
          individualCardNum.innerText = (i + 1).toString();
          individualCardDiv.appendChild(individualCardNum);
          individualCardDiv.appendChild(individualCardImg);

          individualCardImg.thisIndex = d * 52 + i;
          individualCardImg.addEventListener("click", function (e) {
            moveFocusCardRecall(e.target.thisIndex);
          });

          individualCardImg.addEventListener("dblclick", function (e) {
            toggleMark(e.target);
          });
          individualCardImg.setAttribute("id", "cardRecall" + Number(d * 52 + i));

          if (i > 25) {
            if (startFromRight) {
              cardContainer1.appendChild(individualCardDiv);
            } else cardContainer2.appendChild(individualCardDiv);
          } else {
            if (startFromRight) {
              cardContainer2.appendChild(individualCardDiv);
            } else cardContainer1.appendChild(individualCardDiv);
          }
        }

        //Make sure stacked correct way
        if (startFromRight) {
          for (let i = 0; i < 52; i++) {
            var individualCardDiv = (i > 25) ? cardContainer2.children[51 - i] : cardContainer1.children[25 - i];
            individualCardDiv.style.zIndex = i; // Adjust z-index for stacking
          }
        } else {
          for (let i = 0; i < 52; i++) {
            var individualCardDiv = (i > 25) ? cardContainer2.children[i - 26] : cardContainer1.children[i];
            individualCardDiv.style.zIndex = i; // Adjust z-index for stacking
          }
        }


        //ADD BONEYARD (cardBoneyardDiv)
        var boneyardDiv = document.createElement("div");
        boneyardDiv.classList.add("cardBoneyardDiv");
        boneyardDiv.classList.add(skin + "cardBoneyardDiv");


        var boneyard = getStandardDeck();
        sortBoneyard(boneyard);
        var count = 0;
        boneyard.forEach(function (card) {
          boneyardArray.push({cs: card["cs"], cv: card["cv"], recallPos: []});
          var boneyardCard = document.createElement("img");
          boneyardCard.setAttribute("src", "Card images " + cardSet + "/" + card["cs"] + getValueName(card["cv"]) + ".png");
          boneyardCard.thisIndex = d * 52 + count;
          boneyardCard.setAttribute("id", "cardBoneyard" + Number(d * 52 + count));
          boneyardCard.classList.add("cardBoneyard");
          boneyardCard.classList.add(skin + "cardBoneyard");
          boneyardCard.addEventListener("click", function (e) {
            chooseFromBoneyard(e.target.thisIndex);
          });
          //id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
          //cardRecallString += "<img src='Card images/" + card["cs"] + getValueName(card["cv"]) + ".png' class='cardBoneyard " + skin + "cardBoneyard' id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
          count++;
          boneyardDiv.appendChild(boneyardCard);
        });


        if (startFromRight) {
          cardPage.appendChild(cardContainer2);
          cardPage.appendChild(cardContainer1);
        } else {
          cardPage.appendChild(cardContainer1);
          cardPage.appendChild(cardContainer2);
        }
        cardPage.appendChild(boneyardDiv);

        if (skin.indexOf("analogue") > -1) {
          document.getElementById("analogueCardsRecallContentDiv").appendChild(cardPage);
        } else {
          document.getElementById("recallContentDiv").appendChild(cardPage);
        }
      }
      //end of each page


      //***FINISH BUTTON kEpT fOr ReCall
      if (!test) {
        var button = document.createElement("button");
        button.setAttribute("class", "btnDigital finishBtn");
        button.addEventListener("click", confirmFinishRecall);
        button.innerText = "Finish";
        $("#finishBtnDiv").empty();
        document.getElementById("finishBtnDiv").appendChild(button);
      }
      //restore data if resuming
      if (resuming) {
        restoreCardsData();
        restoreMarks();
      }


      //move to first card
      $("#cardRecall0").toggleClass('cardRecallSelected');
      curPos = 0;
      moveFocusCardRecall(1);
      moveFocusCardRecall(26);

      setTimeout(function () {
        moveFocusCardRecall(0);
      }, 40);



      //fan recall cards out
      //**


      for (var deck = 0; deck < amount; deck++) {


        var cardDivs = document.getElementsByClassName("cardDiv");
        var cardsRNum = document.getElementsByClassName("cardRecallNum");
        var cardsSecondRow = document.getElementsByClassName("secondRow");
        var cw = document.getElementsByClassName("cardContainer")[0].clientWidth;
        //var offset = cw/52+20;
        var offset = 40;
        var i;

        for (let j = 0; j < 26; j++) {
          i = deck * 52 + j;
          s = deck * 26 + j;

          // cardDivs[i].style.transform = "translateX(-" + offset * (i % 26) + "px)";
          // cardsSecondRow[s].style.transform = "translateX(-" + offset * (i % 26) + "px) translateY(+40px)";

          if (startFromRight) {
            const leftOffset = -1000;
            // When reversed, adjust transform in the opposite direction

            cardDivs[i + 26].style.transform = "translateX(" + (leftOffset + offset * (i % 26)) + "px) translateY(-120px)";
            cardDivs[i].style.transform = "translateX(" + (leftOffset + offset * (i % 26)) + "px) translateY(+160px)";
          } else {
            // Normal (left-to-right) layout
            cardDivs[i].style.transform = "translateX(-" + offset * (i % 26) + "px)";
            cardsSecondRow[s].style.transform = "translateX(-" + offset * (i % 26) + "px) translateY(+40px)";
          }
        }
        for (let j = 0; j < 52; j++) {
          i = deck * 52 + j;
          cardsRNum[i].style.transform = " translateY(-20px)";
        }



        //fan boneyard cards out
        if (skin.indexOf("analogue") > -1) {

          var cardsBF = document.getElementsByClassName("cardBoneyard");


          //	i != 0 && (cardsR[i].style.transform = "translateX(-" + offset * (i%26) + "px);");
          for (let j = 0; j < 52; j++) {
            i = deck * 52 + j;
            cardsBF[i].style.transform = "rotate(0deg)";
          }

          for (let j = 0; j < 52; j++) {
            i = deck * 52 + j;
            cardsBF[i].style.transform = "rotate(" + ((j % 52) * 1) + "deg) translateY(+60px)";
          }
        } else {
          //digital (spread out but no fanning)

          //var cardsB = document.getElementsByClassName("cardBoneyard"),	offset = cw/52+57	;	
          var cardsB = document.getElementsByClassName("cardBoneyard"), offset = 1000 / 52 + 57;

          for (let j = 0; j < 52; j++) {
            i = deck * 52 + j;

            cardsB[i].style.transform = "translateX(-" + (offset * (i % 52)) + "px) translateY(+100px";
          }

        }
      }

      var r = document.getElementById(skin + 'RecallTimeInner')
      if (!test) {
        //set the timer
        var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

        recallStart = Date.now();
        (function f() {
          recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
          r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);

          //every 10 seconds, save
          if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
            saveCardsData();
          }

          //save the elapsed time every second
          localStorage.setItem("timeElapsed", recallTimeDiff);


          //When timer reaches 0, go to score display
          if (recallTimeDiff / 1e3 >= recallTime) {

            finishRecall();
          }
          //Otherwise repeat this function
          else {
            if (!ended || intermediate) {
              myTimer = setTimeout(f, 1000);
            }
          }
        })();
      } else {
        r.textContent = "Press Enter to exit";
      }

      document.onkeydown = function (e) {
        //If Enter is pressed
        if (e.key == "Enter" && !ended && (!competitionMode || test)) {
          if (!test) {
            confirmFinishRecall();
          } else {
            finishRecall(test);
          }

        }

        //if right arrow pressed, move on
        if (e.key == "ArrowRight" && !ended) {
          e.preventDefault();
          if (startFromRight) {
            movePreviousCardRecall();
          } else moveNextCardRecall();
        }


        //if left arrow is pressed to go back
        if (e.key == "ArrowLeft" && !ended) {
          e.preventDefault();
          if (startFromRight) {
            moveNextCardRecall();
          } else movePreviousCardRecall();
        }



        //if backspace (8) is pressed, delete the card in previous box and move back to that space
        if ((e.key == "Backspace") && !ended) {
          e.preventDefault();
          movePreviousCardRecall();

          restoreBoneyardCard(curPos);
          //boneyardArray[curPos].recallPos = -1;
          //display the sent-back card in the boneyard position
          //document.getElementById("cardBoneyard" + curPos).src = "Card images " + cardSet + "/" + boneyardArray[curPos].cs + getValueName(boneyardArray[curPos].cv) + ".png";

        }

        //if delete is pressed, delete the card in current space
        if ((e.key == "Delete") && !ended) {
          e.preventDefault();

          restoreBoneyardCard(curPos);
          //boneyardArray[curPos].recallPos = -1;
          //display the sent-back card in the boneyard position
          //document.getElementById("cardBoneyard" + curPos).src = "Card images " + cardSet + "/" + boneyardArray[curPos].cs + getValueName(boneyardArray[curPos].cv) + ".png";

        }



        //If + is pressed
        if ((e.key == '+' || e.key == '=') && !ended) {
          e.preventDefault();
          shiftCardsForward();

        }

        //If - is pressed
        if ((e.key == '-' || e.key == '-') && !ended) {

          e.preventDefault();
          shiftCardsBackward();

        }

        //if [ is pressed, previous page
        if (e.key == ',' && !ended) {

          if (curPage > 0) moveFocusCardRecall(52 * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if ] is pressed, next page
        if (e.key == '.' && !ended) {

          if (curPage < amount - 1) moveFocusCardRecall(52 * (curPage + 1));

        }

        //if up arrow is pressed, restart deck
        if (e.key == 'ArrowUp' && !ended) {

          moveFocusCardRecall(52 * (curPage));

        }

        //if space is pressed, return to start
        if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
          e.preventDefault();
          moveFocusCardRecall(0);

        }

      };


    }

    function getBoneyardPosition(pos) {
      var originalPosition = -1;
      var count = 0;
      for (let i = 0; i < boneyardArray.length; i++) {
        if (boneyardArray[i].recallPos.indexOf(pos) > -1) {
          originalPosition = i;
          break;
        }
      }
      return originalPosition;
    }



    function chooseFromBoneyard(position) {

      var cs = boneyardArray[position].cs;
      var cv = boneyardArray[position].cv;

      //only do something if this card hasn't already been picked up, i.e. recallPos == -1)   
      //OR if we are resuming on the score page, where it will be already in the boneyard array but won't appear on the screen yet
      //if (boneyardArray[position].recallPos == -1 || (resuming && localStorage.getItem("phase") == "score")) {
      //this card has not been picked up

      //only do something if this card hasn't already been placed in this position
      //OR if we are resuming on the score page, where it will be already in the boneyard array but won't appear on the screen yet
      if (boneyardArray[position].recallPos.indexOf(curPos) == -1 && localStorage.getItem("phase") != "score" || (resuming && localStorage.getItem("phase") == "score" && !displayed)) {

        //set it to the "back" image in the boneyard
        //document.getElementById("cardBoneyard" + position).src = "Card images " + cardSet + "/back.png";


        //if the chosen recall position is full, send that card back to boneyard
        var originalPosition = getBoneyardPosition(curPos);

        console.log("originalPosition = " + originalPosition);
        if (originalPosition > -1) {
          restoreBoneyardCard(curPos);
        }

        //invert boneyard card if not been picked up before
        if (boneyardArray[position].recallPos.length == 0) {
          document.getElementById("cardBoneyard" + position).classList.add("inverted");
        }

        //set the corresponding boneyardArray entry if not already in there (e.g. because we are resuming score page)
        if (boneyardArray[position].recallPos.indexOf(curPos) == -1) boneyardArray[position].recallPos.push(curPos);

        //display the card in the recall position
        document.getElementById("cardRecall" + curPos).src = "Card images " + cardSet + "/" + cs + getValueName(cv) + ".png";

        // invert it in the recall section if already picked up
        if (boneyardArray[position].recallPos.length > 1 && localStorage.getItem("phase") != "score") {
          boneyardArray[position].recallPos.forEach(el => document.getElementById("cardRecall" + el).classList.add("inverted"));
        }


        //used to move to next space, now moves to next empty space
        if (!ended && curPos % 52 != 51) moveNextEmptyCardRecall();
      }
    }

    function moveNextEmptyCardRecall() {
      //after feedback, this should never move to next deck	
      var nextEmpty = curPos + 1;
      while (getBoneyardPosition(nextEmpty) > -1) {
        nextEmpty++;
        if (curPos == amount * 52 - 1 || nextEmpty % 52 == 0) return;
      }
      moveFocusCardRecall(nextEmpty);

    }

    function moveNextCardRecall() {
      ended || moveFocusCardRecall(curPos + 1);
    }

    function movePreviousCardRecall() {
      ended || moveFocusCardRecall(curPos - 1);
    }

    function shiftCardsBackward() {
      //restore cur pos card to boneyard
      if (getBoneyardPosition(curPos) > -1) {
        restoreBoneyardCard(curPos);
      }

      //only within this deck
      var d = Math.floor(curPos / 52);
      for (var i = curPos; i < d * 52 + 51; i++) {
        if (document.getElementById("cardRecall" + Number(i + 1)).classList.contains("inverted")) {
          document.getElementById("cardRecall" + Number(i + 1)).classList.remove("inverted");
          document.getElementById("cardRecall" + i).classList.add("inverted");
        }

        if (document.getElementById("cardRecall" + Number(i + 1)).classList.contains("markCards")) {
          document.getElementById("cardRecall" + Number(i + 1)).classList.remove("markCards");
          document.getElementById("cardRecall" + i).classList.add("markCards");
        }

        var nextPosition = getBoneyardPosition(i + 1);
        console.log(i + " " + nextPosition);
        if (nextPosition > -1) {
          //we find the boneyard card in next position and then inside its recallPos array we change i+1 to i	
          var index = boneyardArray[nextPosition].recallPos.indexOf(i + 1);
          boneyardArray[nextPosition].recallPos[index]--;
          document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/" + boneyardArray[nextPosition].cs + getValueName(boneyardArray[nextPosition].cv) + ".png";
        } else {
          document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/back.png";
        }
      }
      //whatever image is in curPos+1, we overwrite it with curPos+2, but we need to restore it

      //we are deleting card in last pos so replace with "back" image in recall
      document.getElementById("cardRecall" + (d * 52 + 51)).src = "Card images " + cardSet + "/back.png";

    }

    function shiftCardsForward() {
      //only within this deck
      var d = Math.floor(curPos / 52);

      if (getBoneyardPosition(d * 52 + 51) > -1) {
        console.log("there is a card in last position");
        restoreBoneyardCard(d * 52 + 51);
      }

      for (var i = d * 52 + 51; i >= curPos + 1; i--) {


        if (document.getElementById("cardRecall" + Number(i - 1)).classList.contains("inverted")) {
          document.getElementById("cardRecall" + Number(i - 1)).classList.remove("inverted");
          document.getElementById("cardRecall" + i).classList.add("inverted");
        } else {
          document.getElementById("cardRecall" + i).classList.remove("inverted");
        }
        if (document.getElementById("cardRecall" + Number(i - 1)).classList.contains("markCards")) {
          document.getElementById("cardRecall" + Number(i - 1)).classList.remove("markCards");
          document.getElementById("cardRecall" + i).classList.add("markCards");
        } else {
          document.getElementById("cardRecall" + i).classList.remove("markCards");
        }

        var previousPosition = getBoneyardPosition(i - 1);
        console.log(previousPosition);
        if (previousPosition > -1) {
          //we find the boneyard card in prev position and then inside its recallPos array we change i-1 to i	
          var index = boneyardArray[previousPosition].recallPos.indexOf(i - 1);
          boneyardArray[previousPosition].recallPos[index]++;
          document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/" + boneyardArray[previousPosition].cs + getValueName(boneyardArray[previousPosition].cv) + ".png";
        } else {
          document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/back.png";
        }
      }

      //we have deleted card in curPos so replace with "back" image in recall
      document.getElementById("cardRecall" + curPos).src = "Card images " + cardSet + "/back.png";

    }

    function restoreBoneyardCard(recallPos) {
      if (ended) return;

      var pos = getBoneyardPosition(recallPos);
      console.log("boneyard pos of last card was " + pos);
      //remove this index from the recallPos array
      var index = boneyardArray[pos].recallPos.indexOf(recallPos);
      boneyardArray[pos].recallPos.splice(index, 1);

      //remove inversion
      document.getElementById("cardRecall" + recallPos).classList.remove("inverted");
      //document.getElementById("cardRecall" + recallPos).classList.remove("lighter");

      //if this boneyard card now has nothing in recallPos array, we can take off the inversion in boneyard
      if (boneyardArray[pos].recallPos.length == 0) {
        document.getElementById("cardBoneyard" + pos).classList.remove("inverted");
      } else if (boneyardArray[pos].recallPos.length == 1) {
        //card now only appears once, so remove inversion in recall section
        document.getElementById("cardRecall" + boneyardArray[pos].recallPos[0]).classList.remove("inverted");
      }
      //display the sent-back card in the boneyard position
      document.getElementById("cardBoneyard" + pos).src = "Card images " + cardSet + "/" + boneyardArray[pos].cs + getValueName(boneyardArray[pos].cv) + ".png";
      document.getElementById("cardRecall" + recallPos).src = "Card images " + cardSet + "/back.png";
    }

    function displayCardScore() {

      if (skin.indexOf("analogue") > -1) {
        $("#scoreBox").addClass("analogue1boxGreen");
        $("#scoreBox").removeClass("analogue1boxB");
      }

      displayed = false;
      if (resuming) {
        if (currentDiscipline.indexOf("XC") == -1) {
          cardList = JSON.parse(localStorage.getItem("correctAnswers"));
          memoTimeTaken = localStorage.getItem("memoTimeTaken");
          $("#spanOuterScore").show();
          $("#spanScore").show();
          $("#spanCorrect").show();
        } else {
          $("#spanOuterScore").hide();
          $("#spanScore").hide();
          $("#spanCorrect").hide();
        }
        amount = localStorage.getItem("amount");

        //add extra lines
        //add more rows if we are doing more than 26 decks, otherwise the page numbers overlap the numbers

        if (skin.indexOf("analogue") > -1) {
          if (amount > 26) document.getElementById("analogueCardsScoreContentDiv").innerHTML += "<br /><br /><br />";
          if (amount > 52) document.getElementById("analogueCardsScoreContentDiv").innerHTML += "<br /><br /><br />";
          if (amount <= 26) document.getElementById("analogueCardsScoreContentDiv").innerHTML += "<br /><br />";
        } else {
          if (amount > 26) document.getElementById("scoreContentDiv").innerHTML += "<br /><br /><br />";
          if (amount > 52) document.getElementById("scoreContentDiv").innerHTML += "<br /><br /><br />";

        }


        if (skin.indexOf("analogue") > -1) {
          $("#recallBox").addClass("analogue1boxGreen");

          $("#recallBox").removeClass("analogue1boxB");

        }

      } else {
        saveCardsData();
      }



      var totalEval = 0;
      var correct = 0;
      var correctThisDeck = 0;
      var deckScore = [];
      var firstMistake = [];
      var deckLength;
      var lastDeck = -1;

      let startFromRight;

      if (resuming) {
        startFromRight = localStorage.getItem("cardsLeftToRight") === 'false' && localStorage.getItem("startFromRight") === 'true';
        boneyardArray = JSON.parse(localStorage.getItem("chosen"));

        //add the recall content

        for (var d = 0; d < amount; d++) {

          var cardPage = document.createElement("div");
          cardPage.setAttribute("id", "page" + d + "Recall");
          cardPage.setAttribute("style", "position:relative");
          var cardContainer1 = document.createElement("div");
          var cardContainer2 = document.createElement("div");
          cardContainer1.classList.add("cardContainer");
          cardContainer2.classList.add("cardContainer");

          if (startFromRight) {
            cardContainer1.classList.add("reverseCards");
            cardContainer2.classList.add("reverseCards");
          } else {
            cardContainer1.classList.remove("reverseCards");
            cardContainer2.classList.remove("reverseCards");
          }



          for (let i = 0; i < 52; i++) {

            var individualCardDiv = document.createElement("div");

            if (startFromRight && i <= 25) {
              individualCardDiv.classList.add("secondRow");
            }
            if (!startFromRight && i > 25) {
              individualCardDiv.classList.add("secondRow");
            }

            var individualCardNum = document.createElement("div");
            var individualCardImg = document.createElement("img");
            individualCardImg.setAttribute("src", "Card images " + cardSet + "/back.png");
            individualCardDiv.classList.add("cardDiv");
            individualCardImg.classList.add("cardRecall");
            individualCardImg.classList.remove("markCards");
            individualCardImg.classList.remove("inverted");
            individualCardNum.classList.add("cardRecallNum");
            individualCardNum.innerText = (i + 1).toString();
            individualCardDiv.appendChild(individualCardNum);
            individualCardDiv.appendChild(individualCardImg);
            // ondblclick='restoreBoneyardCard(" + Number(d*52+i) + ")' id='cardRecall" + (d*52+i) + "'
            individualCardImg.thisIndex = d * 52 + i;
            individualCardImg.addEventListener("click", function (e) {
              moveFocusCardRecall(e.target.thisIndex);
            });
            individualCardImg.setAttribute("id", "cardRecall" + Number(d * 52 + i));

            if (i > 25) {
              cardContainer2.appendChild(individualCardDiv);
            } else {
              cardContainer1.appendChild(individualCardDiv);
            }
          }

          //stack right way
          if (startFromRight) {
            for (let i = 0; i < 52; i++) {
              var individualCardDiv = (i > 25) ? cardContainer2.children[51 - i] : cardContainer1.children[25 - i];
              individualCardDiv.style.zIndex = i; // Adjust z-index for stacking
            }
          } else {
            for (let i = 0; i < 52; i++) {
              var individualCardDiv = (i > 25) ? cardContainer2.children[i - 26] : cardContainer1.children[i];
              individualCardDiv.style.zIndex = i; // Adjust z-index for stacking
            }
          }


          //ADD BONEYARD (cardBoneyardDiv)
          var boneyardDiv = document.createElement("div");
          boneyardDiv.classList.add("cardBoneyardDiv");
          boneyardDiv.classList.add(skin + "cardBoneyardDiv");


          var boneyard = getStandardDeck();
          sortBoneyard(boneyard);
          var count = 0;
          boneyard.forEach(function (card) {
            //boneyardArray.push({cs:card["cs"],cv:card["cv"],recallPos:[]});

            var boneyardCard = document.createElement("img");
            boneyardCard.setAttribute("src", "Card images " + cardSet + "/" + card["cs"] + getValueName(card["cv"]) + ".png");
            boneyardCard.thisIndex = d * 52 + count;
            boneyardCard.setAttribute("id", "cardBoneyard" + Number(d * 52 + count));
            boneyardCard.classList.add("cardBoneyard");
            boneyardCard.classList.add(skin + "cardBoneyard");
            boneyardCard.addEventListener("click", function (e) {
              chooseFromBoneyard(e.target.thisIndex);
            });
            //id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
            //cardRecallString += "<img src='Card images/" + card["cs"] + getValueName(card["cv"]) + ".png' class='cardBoneyard " + skin + "cardBoneyard' id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
            count++;
            boneyardDiv.appendChild(boneyardCard);
          });



          if (startFromRight) {
            cardPage.appendChild(cardContainer2);
            cardPage.appendChild(cardContainer1);
          } else {
            cardPage.appendChild(cardContainer1);
            cardPage.appendChild(cardContainer2);
          }
          cardPage.appendChild(boneyardDiv);



          if (skin.indexOf("analogue") > -1) {
            document.getElementById("analogueCardsScoreContentDiv").appendChild(cardPage);
          } else {
            document.getElementById("scoreContentDiv").appendChild(cardPage);
          }

        }

        if (skin.indexOf("analogue") > -1) {
          document.getElementById("analogueCardsRecallContentDiv").innerHTML = "";
        } else {
          document.getElementById("recallContentDiv").innerHTML = "";
        }
        //fan cards out

        for (var deck = 0; deck < amount; deck++) {
          var cardDivs = document.getElementsByClassName("cardDiv");


          var cardsRNum = document.getElementsByClassName("cardRecallNum");
          var cardsSecondRow = document.getElementsByClassName("secondRow");
          var cw = document.getElementsByClassName("cardContainer")[0].clientWidth;
          //var offset = cw/52+20;
          var offset = 40;
          var i;

          for (let j = 0; j < 26; j++) {
            i = deck * 52 + j;
            s = deck * 26 + j;

            // cardDivs[i].style.transform = "translateX(-" + offset * (i % 26) + "px)";
            // cardsSecondRow[s].style.transform = "translateX(-" + offset * (i % 26) + "px) translateY(+40px)";


            if (startFromRight) {
              const leftOffset = -1000;
              // When reversed, adjust transform in the opposite direction

              cardDivs[i].style.transform = "translateX(" + (leftOffset + offset * (i % 26)) + "px)";
              cardDivs[i + 26].style.transform = "translateX(" + (leftOffset + offset * (i % 26)) + "px) translateY(+40px)";
            } else {
              // Normal (left-to-right) layout
              cardDivs[i].style.transform = "translateX(-" + offset * (i % 26) + "px)";
              cardsSecondRow[s].style.transform = "translateX(-" + offset * (i % 26) + "px) translateY(+40px)";
            }
          }


          for (let j = 0; j < 52; j++) {
            i = deck * 52 + j;
            cardsRNum[i].style.transform = " translateY(-20px)";
          }

          //fan boneyard cards out
          if (skin.indexOf("analogue") > -1) {

            var cardsBF = document.getElementsByClassName("cardBoneyard");


            //	i != 0 && (cardsR[i].style.transform = "translateX(-" + offset * (i%26) + "px);");
            for (let j = 0; j < 52; j++) {
              i = deck * 52 + j;
              cardsBF[i].style.transform = "rotate(0deg)";
            }

            for (let j = 0; j < 52; j++) {
              i = deck * 52 + j;
              cardsBF[i].style.transform = "rotate(" + ((j % 52) * 1) + "deg) translateY(+60px)";
            }
          } else {
            //digital (spread out but no fanning)

            //var cardsB = document.getElementsByClassName("cardBoneyard"),	offset = cw/52+57	;	
            var cardsB = document.getElementsByClassName("cardBoneyard"), offset = 1000 / 52 + 57;

            for (let j = 0; j < 52; j++) {
              i = deck * 52 + j;

              cardsB[i].style.transform = "translateX(-" + (offset * (i % 52)) + "px) translateY(+100px";
            }

          }
        }


      } else {
        startFromRight = document.getElementById("chkStartRecallRight").checked;
      }

      //Go through all decks, storing the number correct, the first mistake, and whether they were attempted

      if (currentDiscipline.indexOf("XC") == -1) {
        for (var d = amount - 1; d >= 0; d--) {

          firstMistake[d] = -1;


          for (let i = 0; i < 52; i++) {
            //remove cardRecallSelected class
            document.getElementById("cardRecall" + Number(d * 52 + i)).classList.remove("cardRecallSelected");
            var boneyardPos = getBoneyardPosition(d * 52 + i);
            if (boneyardPos > -1) {
              //If we haven't found the last deck, this is it, and we need to store the deck length for special calculation
              //if we already found that this is the last deck, make sure we keep incrementing deckLength with each card
              if (lastDeck == -1 || lastDeck == d) {
                lastDeck = d;
                deckLength = i + 1;
              }
              if (cardList[d][i].cv == boneyardArray[boneyardPos].cv && cardList[d][i].cs == boneyardArray[boneyardPos].cs) {
                correctThisDeck++;
                document.getElementById("cardRecall" + Number(d * 52 + i)).classList.add("cardRecallCorrect");
              } else {
                //set firstMistake if not already set
                firstMistake[d] = (firstMistake[d] == -1 ? i : firstMistake[d]);
                document.getElementById("cardRecall" + Number(d * 52 + i)).classList.add("cardRecallIncorrect");

              }
            } else {

              //if not even attempted
              //set firstMistake if not already set
              firstMistake[d] = (firstMistake[d] == -1 ? i : firstMistake[d]);
            }
          }

          deckScore[d] = correctThisDeck;
          correctThisDeck = 0;
        }

        //Calculate last deck
        //lastDeck = (isAttempted.lastIndexOf(true)>-1 ? isAttempted.lastIndexOf(true) : 0);
        //console.log(lastDeck);


        //score for last deck - the deck length is taken to be the last card attempted
        //totalEval += (firstMistake[lastDeck] == -1 ? deckScore[lastDeck] : firstMistake[lastDeck]);

        if (currentDiscipline.indexOf("SC") > -1) {
          totalEval = (firstMistake[0] == -1 ? deckScore[0] : firstMistake[0]);
        } else {

          //Go through deckScore array and convert + sum the scores for each deck except last
          for (d = 0; d < lastDeck; d++) {
            if (deckScore[d] == 52) {
              totalEval += 52;
            } else if (deckScore[d] == 51) {
              totalEval += 26;
            }
          }
          if (deckScore[lastDeck] == deckLength) {
            totalEval += deckLength;
          } else if (deckScore[d] == deckLength - 1) {
            totalEval += deckLength == 1 ? 0 : Math.ceil(deckLength / 2);
          }
        }

        //This shouldn't be necessary
        if (isNaN(totalEval)) totalEval = 0;

        document.getElementById("spanScore").innerHTML = totalEval;
        rawScoreInfo = "Discipline: " + lookupProperty(currentDiscipline, "label") + (currentDiscipline === 'SC' ? " Trial " + trialNo : "") + " // Score: " + totalEval.toString() + " // Time: " + (memoTimeTaken / 1000).toFixed(2);
        scoreInfo = encryptWithAES(rawScoreInfo + " // Timestamp: " + getTimestamp());



        document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + deckScore.reduce(function (acc, val) {return acc + val;}) + " correct)";
      }

      if (!resuming) {
        if (skin.indexOf("analogue") > -1) {
          document.getElementById("analogueCardsScoreContentDiv").innerHTML = document.getElementById("analogueCardsRecallContentDiv").innerHTML;
          document.getElementById("analogueCardsRecallContentDiv").innerHTML = "";

        } else {
          document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
          document.getElementById("recallContentDiv").innerHTML = "";
        }
      } else {

        restoreCardsData();
        displayed = true;




      }

      document.onkeydown = function (e) {

        //if , is pressed, previous page
        if (e.key == ',') {
          e.preventDefault();
          if (curPage > 0) moveFocusCardScore(52 * (curPage - 1));
          //if (curPage>0) displayPage(curPage-1);
        }


        //if . is pressed, next page
        if (e.key == '.') {
          e.preventDefault();
          if (curPage < amount - 1) moveFocusCardScore(52 * (curPage + 1));

        }

      };


      //mouseover handlers
      for (var d = 0; d < amount; d++) {


        for (let i = 0; i < 52; i++) {
          $("#cardRecall" + Number(d * 52 + i)).mouseover(function (ev) {
            showCorrectCard(ev.target.id.match(/\d+/g));
          });
          $("#cardRecall" + Number(d * 52 + i)).mouseout(function (ev) {
            showChosenCard(ev.target.id.match(/\d+/g));
          });
        }
      }

      //show pages
      if (amount > 1) {
        // add two rows before the menu
        var menuString = "<br /><ul class='menu'>";

        for (var i = 0; i < amount; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusCardScore(" + 52 * i + ")'>" + (i + 1) + "</a></li>";

        }
        menuString += "</ul><br/><br /><br />";
        document.getElementById("menuScoreDiv").innerHTML = menuString + "<br /><br />";
        document.getElementById("menuRecallDiv").innerHTML = "";
      } else {
        document.getElementById("menuScoreDiv").innerHTML = "<br /><br /><br />";
      }

      $(".finishBtn").hide();
      document.getElementById("scoreRow").style.display = "block";



      //display memo time
      if (memoTimeNeeded) displayMemoTimeScore();


      if ((amount == 1 && currentDiscipline.indexOf("XC") == -1) || memoTimeNeeded) $("#cardsMemoTimeScore").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));

      //moveFocusCardScore(0);
      //move to first page
      displayPage(0, true);


      if (currentDiscipline.indexOf("XC") == 1) {

        $("#spanOuterScore").hide();
        $("#spanScore").hide();
        $("#spanCorrect").hide();
      }

    }



    function showCorrectCard(num) {
      if (currentDiscipline === 'SXC') return; //Don't need this function in Recall Only Speed Cards, it will cause an error as there is no 'cardList'
      var d = Math.floor(num / 52);
      var i = num - d * 52;
      var boneyardPos = getBoneyardPosition(d * 52 + i);
      if (boneyardPos == -1 || (cardList[d][i].cv != boneyardArray[boneyardPos].cv || cardList[d][i].cs != boneyardArray[boneyardPos].cs)) {
        document.getElementById("cardRecall" + num).src = "Card images " + cardSet + "/" + cardList[d][i].cs + getValueName(cardList[d][i].cv) + ".png";
        document.getElementById("cardRecall" + num).classList.add("cardRecallCorrected");
      }
    }

    function showChosenCard(num) {
      var d = Math.floor(num / 52);
      if (currentDiscipline === 'SXC') return; //Don't need this function in Recall Only Speed Cards, it will cause an error as there is no 'cardList'
      var i = num - d * 52;
      var boneyardPos = getBoneyardPosition(d * 52 + i);
      if (boneyardPos == -1 || (cardList[d][i].cv != boneyardArray[boneyardPos].cv || cardList[d][i].cs != boneyardArray[boneyardPos].cs)) {
        document.getElementById("cardRecall" + num).classList.remove("cardRecallCorrected");
        if (boneyardPos == -1) {
          document.getElementById("cardRecall" + num).src = "Card images " + cardSet + "/back.png";
        } else {
          document.getElementById("cardRecall" + num).src = "Card images " + cardSet + "/" + boneyardArray[boneyardPos].cs + getValueName(boneyardArray[boneyardPos].cv) + ".png";
        }
      }
    }

    function lookupProperty(key, property) {
      for (j = 0; j < events.length; j++) {
        if (events[j].ref === key) {
          if (events[j].hasOwnProperty(property)) {
            return events[j][property];
          }
          else {
            return "";
          }

        }

      }
      return "";

    }

    function showCorrect(pos) {
      if (currentDiscipline.indexOf("N") > -1) {
        // if (pos < numberList.length && pos > 0) {
        //get first of grouping
        var firstOfGroup = pos - (pos % grouping);
        for (var g = 0; g < grouping && firstOfGroup + g < numberList.length; g++) {
          var chosenAnswer = chosenAnswers[firstOfGroup + g];

          if (chosenAnswer !== numberList[firstOfGroup + g] || chosenAnswer.length == 0) {
            document.getElementById("inpRecall" + (firstOfGroup + g)).classList.add(skin + "corrected");
            document.getElementById("inpRecall" + (firstOfGroup + g)).classList.remove(skin + "incorrect");
            document.getElementById("inpRecall" + (firstOfGroup + g)).value = numberList[firstOfGroup + g];

          }
        }
        // }
        /*
                else {
                //  document.getElementById("score" + (firstOfGroup+g)).className = skin + "score " + skin + "correct";
                }
        */
      } else if (currentDiscipline.indexOf("K") > -1) {
        var chosenAnswer = chosenAnswers[pos];

        if (chosenAnswer !== numberList[pos] || chosenAnswer.length == 0) {
          document.getElementById("inpRecall" + pos).classList.add(skin + "corrected");
          document.getElementById("inpRecall" + pos).classList.remove(skin + "incorrect");
          document.getElementById("inpRecall" + pos).value = numberList[pos];
        }

      } else {
        //binary
        //get positions
        var positions = getHighlightPositionsBin(pos);
        for (var g = 0; g < positions.length && positions[g] < binaryList.length; g++) {
          var chosenAnswer = chosenAnswers[positions[g]];

          if (chosenAnswer !== binaryList[positions[g]] || chosenAnswer.length == 0) {
            document.getElementById("inpRecall" + (positions[g])).classList.add(skin + "corrected");
            document.getElementById("inpRecall" + (positions[g])).classList.remove(skin + "incorrect");
            document.getElementById("inpRecall" + (positions[g])).value = binaryList[positions[g]];

          }
        }
      }
    }

    function showChosen(pos) {
      if (currentDiscipline.indexOf("N") > -1) {
        //get first of grouping
        var firstOfGroup = pos - (pos % grouping);
        for (var g = 0; g < grouping && firstOfGroup + g < numberList.length; g++) {
          var corrClass = "";
          var chosenAnswer = chosenAnswers[firstOfGroup + g];
          if (chosenAnswer == numberList[firstOfGroup + g] && chosenAnswer.length > 0) {
            corrClass = skin + "correct";
          }
          else {
            //nothing chosen
            if (chosenAnswer.length === 0) {
              corrClass = "";
            }
            else {

              corrClass = skin + "incorrect";
            }
          }
          //document.getElementById("inpRecall" + (firstOfGroup+g)).className = skin + "score " + corrClass;
          document.getElementById("inpRecall" + (firstOfGroup + g)).classList.remove(skin + "corrected");
          corrClass && document.getElementById("inpRecall" + (firstOfGroup + g)).classList.add(corrClass);

          document.getElementById("inpRecall" + (firstOfGroup + g)).value = chosenAnswers[firstOfGroup + g];

          /*
                  if (skin.indexOf("analogue")>-1 && chosenAnswer != numberList[firstOfGroup+g] && chosenAnswer.length > 0) {
                      document.getElementById('score' + (firstOfGroup+g)).innerHTML += "<span class='slash'><sub>x</sub><sup>" + correctAnswer + "</sup></span>";
                  }
                  */
        }
      } else if (currentDiscipline.indexOf("K") > -1) {
        var corrClass = "";
        var chosenAnswer = chosenAnswers[pos];
        if (chosenAnswer == numberList[pos] && chosenAnswer.length > 0) {
          corrClass = skin + "correct";
        }
        else {
          //nothing chosen
          if (chosenAnswer.length === 0) {
            corrClass = "";
          }
          else {

            corrClass = skin + "incorrect";
          }
        }

        document.getElementById("inpRecall" + pos).classList.remove(skin + "corrected");
        corrClass && document.getElementById("inpRecall" + pos).classList.add(corrClass);
        document.getElementById("inpRecall" + pos).value = chosenAnswers[pos];

      }

      else {
        //binary
        var positions = getHighlightPositionsBin(pos);

        for (var g = 0; g < positions.length && positions[g] < binaryList.length; g++) {
          var chosenAnswer = chosenAnswers[positions[g]];

          var corrClass = "";

          if (chosenAnswer == binaryList[positions[g]] && chosenAnswer.length > 0) {
            corrClass = skin + "correct";
          }
          else {
            //nothing chosen
            if (chosenAnswer.length === 0) {
              corrClass = "";
            }
            else {

              corrClass = skin + "incorrect";
            }
          }
          corrClass && document.getElementById("inpRecall" + (positions[g])).classList.add(corrClass);
          document.getElementById("inpRecall" + (positions[g])).classList.remove(skin + "corrected");
          document.getElementById("inpRecall" + (positions[g])).value = chosenAnswers[positions[g]];


        }

      }
    }


    function displayWordsScore() {
      var wordsInfo = "";

      if (resuming) {
        wordList = JSON.parse(localStorage.getItem("correctAnswers")).map(normalise);
        amount = localStorage.getItem("amount");
        wordsPerPage = wordsPerColumn * wordColumnsPerPage;
        numberOfPages = Math.ceil(amount / wordsPerPage);
      } else {
        wordList = wordList.map(normalise);
        saveWordsData();
      }

      var totalEval = 0;
      var correct = 0;
      var correctThisColumn = 0;
      var lastColumn = Math.floor(amount / wordsPerColumn);
      var lastCellInColumn = wordsPerColumn;
      var sequence = 0;
      curPage = 0;

      function normalise(word) {
        return word.replace(/‘/g, "'").trim();  // replace all occurrences of ‘ with ' - added for Uzbek words
      }

      //collect (trimmed) answers into a new array
      chosenAnswers = [];

      if (resuming) {
        chosenAnswers = JSON.parse(localStorage.getItem("chosen")).map(normalise);

        //add the recall content
        for (i = 0; i < numberOfPages; i++) {


          //create a new page that can be hidden or shown
          var pageDiv = document.createElement("div");
          pageDiv.setAttribute("id", "page" + i + "Recall");

          //add table to hold the words
          var thisPageTable = document.createElement("table");

          if (wordsLanguageIsRToL()) {
            thisPageTable.setAttribute("class", "wordsRecallTable tableRtoL")
          } else {
            thisPageTable.setAttribute("class", "wordsRecallTable");
          }

          //add rows with cells
          for (j = 0; j < wordsPerColumn; j++) {
            var row = document.createElement("tr");
            if (wordsLanguageIsRToL()) {


              for (k = wordColumnsPerPage - 1; k >= 0; k--) {
                var wordCell = document.createElement("td");
                var wordInput = document.createElement("input");

                var numberCell = document.createElement("td");
                var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

                if (thisIndex < wordList.length) {
                  numberCell.innerHTML = "&nbsp;&nbsp;." + Number(thisIndex + 1);
                  numberCell.setAttribute("class", skin + "wordsNum");
                  wordInput.setAttribute("id", "inpRecall" + thisIndex);
                  wordInput.setAttribute("class", skin + "wordsRecall");
                  wordInput.thisIndex = thisIndex;
                  wordInput.addEventListener("click", function (e) {
                    moveFocusWordsRecall(e.target.thisIndex);
                  });
                  wordCell.setAttribute("class", skin + "wordsRecallTD");
                  wordCell.setAttribute("id", "tdRecall" + thisIndex);
                  wordCell.appendChild(wordInput);
                }

                row.appendChild(wordCell);
                row.appendChild(numberCell);

              }
            } else {

              for (k = 0; k < wordColumnsPerPage; k++) {
                var wordCell = document.createElement("td");
                var wordInput = document.createElement("input");

                var numberCell = document.createElement("td");
                var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

                if (thisIndex < wordList.length) {
                  numberCell.innerHTML = Number(thisIndex + 1) + ".&nbsp;&nbsp;";
                  numberCell.setAttribute("class", skin + "wordsNum");
                  wordInput.setAttribute("id", "inpRecall" + thisIndex);
                  wordInput.setAttribute("class", skin + "wordsRecall");
                  wordInput.thisIndex = thisIndex;
                  wordInput.addEventListener("click", function (e) {
                    moveFocusWordsRecall(e.target.thisIndex);
                  });
                  wordCell.setAttribute("class", skin + "wordsRecallTD");
                  wordCell.setAttribute("id", "tdRecall" + thisIndex);
                  wordCell.appendChild(wordInput);
                }
                if (wordsLanguageIsRToL()) {
                  row.appendChild(wordCell);
                  row.appendChild(numberCell);
                } else {
                  row.appendChild(numberCell);
                  row.appendChild(wordCell);
                }
              }
            }
            thisPageTable.appendChild(row);
          }

          pageDiv.appendChild(thisPageTable);

          document.getElementById("scoreContentDiv").appendChild(pageDiv);

        }

        document.getElementById("recallContentDiv").innerHTML = "";
      } else {
        for (let i = 0; i < amount; i++) {
          chosenAnswers.push(document.getElementById("inpRecall" + i).value.trim().toLowerCase());
        }
      }



      //Find last column and cell within column

      for (var i = amount - 1; i >= 0; i--) {

        if (chosenAnswers[i].length > 0) {
          lastColumn = Math.floor(i / wordsPerColumn);
          lastCellInColumn = i % wordsPerColumn;
          console.log("last column is " + lastColumn);
          console.log("last cell in last column is " + lastCellInColumn);
          break;
        }


      }

      var columnScores = [];
      var incorrectWordsThisColumn = [];

      //Go through all words until last cell
      for (var i = 0; i < amount; i++) {
        console.log(i);
        document.getElementById("inpRecall" + i).classList = [skin + "wordsRecall"];
        document.getElementById("inpRecall" + i).setAttribute("readonly", "");

        var thisIsLastColumn = (i >= lastColumn * wordsPerColumn);

        if (i % wordsPerColumn == 0 && i <= lastColumn * wordsPerColumn + lastCellInColumn) {
          wordsInfo += (Math.floor(i / wordsPerColumn) + 1).toString() + "*";
        }

        if (words_fold(chosenAnswers[i].toLowerCase().trim()) == words_fold(wordList[i].toLowerCase().replace(/-/g, ""))) {
          //correct answer!
          if (thisIsLastColumn) {
            sequence++;
            console.log(chosenAnswers[i]);
          }
          correctThisColumn++;
          wordsInfo += "1";
          if (skin.indexOf('analogue') > -1) {
            //does nothing right now
            document.getElementById("inpRecall" + i).classList.add(skin + "correct");
          }
          else {
            //display correct (green) background
            document.getElementById("inpRecall" + i).classList.add(skin + "correct");
          }
        } else {

          //nothing entered! So just show correct word
          if (chosenAnswers[i].length == 0) {

            if (thisIsLastColumn) {
              sequence++;
              console.log("blank");
            }
            if (i <= lastColumn * wordsPerColumn + lastCellInColumn) wordsInfo += "0";

            console.log(i + " - not entered");
            if (skin.indexOf('analogue') > -1) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slash');

              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('wordMarkingSup');
              var answer = document.createTextNode(wordList[i]);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            }
            else {

              //document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");		
            }
          }
          else {
            //incorrect answer!
            if (thisIsLastColumn) {
              sequence++;
              console.log(chosenAnswers[i]);
            }


            wordsInfo += "X";
            incorrectWordsThisColumn.push([words_fold(chosenAnswers[i].toLowerCase().trim()), i + 1]);
            console.log(incorrectWordsThisColumn);

            //add the chosen incorrect answer (with slash if analogue)      
            if (skin.indexOf('analogue') > -1) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slash');
              var markingSubSpan = document.createElement("sub");
              markingSubSpan.classList.add('wordMarkingSub');
              var x = document.createTextNode("x");
              markingSubSpan.appendChild(x);
              markingSpan.appendChild(markingSubSpan);
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('wordMarkingSup');
              var answer = document.createTextNode(wordList[i]);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            }
            else {
              document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");

            }


          }
        }


        //Don't add any more scores after final cell
        if (i <= lastColumn * wordsPerColumn + lastCellInColumn) {
          //after each column, add 20 to total eval if all on row are correct
          if ((i + 1) % wordsPerColumn == 0 || i == lastColumn * wordsPerColumn + lastCellInColumn) {
            console.log("end of column");
            correct += correctThisColumn;
            wordsInfo += "#";
            if (correctThisColumn == 20) {

              columnScores.push(20);
            } else if (!thisIsLastColumn || sequence == wordsPerColumn) {
              if (thisIsLastColumn) console.log("all words were filled in");
              //normal rules apply as this isn't last column (OR it is last column but all words were filled in)
              if (correctThisColumn == 19) {

                columnScores.push(10);
              } else {
                columnScores.push(0);
              }
            } else {
              console.log("special rules - sequence was " + sequence);
              //last column and not all were filled in - special rules
              if (sequence == correctThisColumn) {
                //all filled in are correct
                console.log("all filld in were correct");
                columnScores.push(correctThisColumn);
              } else if (sequence - 1 == correctThisColumn) {
                //just one is wrong: halve it and round up, or 0 if sequence is 1
                console.log("one was wrong");
                columnScores.push(sequence == 1 ? 0 : Math.ceil(correctThisColumn / 2));
              } else {
                //more than one mistake, so 0
                console.log("more than one was wrong");
                columnScores.push(0);
              }

            }
            correctThisColumn = 0;
            console.log("incorrect words: " + incorrectWordsThisColumn);
            if (incorrectWordsThisColumn.length > 0) wordsInfo += incorrectWordsThisColumn.map(x => "*" + x[0] + "(" + x[1] + ")").join("#") + "#";
            incorrectWordsThisColumn = [];
          }
        }

      }

      totalEval = columnScores.reduce((acc, val) => acc + val);

      if (!resuming) {
        document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
        document.getElementById("recallContentDiv").innerHTML = "";
      } else {


        document.onkeydown = function (e) {
          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusWordsRecall(wordsPerPage * (curPage - 1));
            //if (curPage>0) displayPage(curPage-1);
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusWordsRecall(wordsPerPage * (curPage + 1));

          }


        };

      }

      //mouseover handlers here for digital only
      if (skin.indexOf('digital') > -1) {
        for (var m = 0; m < amount; m++) {
          if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
            $("#inpRecall" + m).mouseover(function (ev) {
              showCorrectWord(ev.target.id.match(/\d+/g));
            });
            $("#inpRecall" + m).mouseout(function (ev) {
              showChosenWord(ev.target.id.match(/\d+/g));
            });
          }
        }
      }


      //add chosen answers
      for (let i = 0; i < amount; i++) {
        document.getElementById("inpRecall" + i).value = chosenAnswers[i];
      }

      //show pages
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusWordsRecall(" + wordsPerPage * i + ")'>" + (i + 1) + "</a></li>";

        }
        // menuString += "</ul><br/><br /><br />";
        menuString += "</ul><br/>"; //changed for WMC 2023
        document.getElementById("menuScoreDiv").innerHTML = menuString;
        document.getElementById("menuRecallDiv").innerHTML = "";
      } else {
        document.getElementById("menuScoreDiv").innerHTML = "";
      }

      document.getElementById("spanScore").innerHTML = totalEval;

      rawScoreInfo = "Discipline: " + lookupProperty(currentDiscipline, "label") + " // Score: " + totalEval.toString() + "#" + wordsInfo;
      console.log(rawScoreInfo);
      scoreInfo = encryptWithAES(rawScoreInfo + " // Timestamp: " + getTimestamp());

      document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

      $(".finishBtn").hide();


      document.getElementById("scoreRow").style.display = "block";

      //display memo time
      if (memoTimeNeeded) displayMemoTimeScore();

      //move to first page
      displayPage(0, true);
    }


    function displayDateScore() {


      if (resuming) {
        dateList = JSON.parse(localStorage.getItem("correctAnswers"));
        shuffledDateList = JSON.parse(localStorage.getItem("shuffledDateList"));
        amount = localStorage.getItem("amount");
        numberOfPages = Math.ceil(amount / datesPerPage);
      } else {
        saveDatesData();
      }

      var totalEval = 0;
      var correct = 0;
      curPage = 0;

      if (!isAnalogue()) {
        document.getElementById("scoreBox").classList.remove(skin + "memoHeight");
        document.getElementById("scoreBox").classList.add(skin + "memoHeightDates");
      }

      //collect answers into a new array
      chosenAnswers = [];

      if (resuming) {
        chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

        //add the recall content
        for (i = 0; i < numberOfPages; i++) {
          //create a new page that can be hidden or shown
          var pageDiv = document.createElement("div");
          pageDiv.setAttribute("id", "page" + i + "Recall");
          //add table to hold the words
          var thisPageTable = document.createElement("table");
          if (datesLanguageIsRToL()) {
            thisPageTable.setAttribute("class", "datesRecallTable tableRToL");
          }
          else {
            thisPageTable.setAttribute("class", "datesRecallTable");
          }
          //add rows with cells
          for (j = 0; j < datesPerPage; j++) {
            var row = document.createElement("tr");
            var thisIndex = i * datesPerPage + j;
            if (thisIndex < dateList.length) {
              var yearCell = document.createElement("td");
              var yearInput = document.createElement("input");
              var eventCell = document.createElement("td");
              yearInput.setAttribute("id", "inpRecall" + thisIndex);
              yearInput.setAttribute("size", 4);
              yearInput.setAttribute("maxlength", 4);
              eventCell.innerHTML = shuffledDateList[thisIndex].event;
              row.setAttribute("id", "trRecall" + thisIndex);
              yearInput.setAttribute("class", skin + "datesYearRecall");
              yearCell.setAttribute("class", skin + "datesRecallTD");
              eventCell.setAttribute("class", skin + "datesEventRecall");
              yearInput.thisIndex = thisIndex;
              yearInput.addEventListener("click", function (e) {
                moveFocusDatesRecall(e.target.thisIndex);
              });


              yearCell.appendChild(yearInput);

              if (datesLanguageIsRToL()) {
                row.appendChild(eventCell);
                row.appendChild(yearCell);
              } else {
                row.appendChild(yearCell);
                row.appendChild(eventCell);
              }
            }
            thisPageTable.appendChild(row);
          }
          pageDiv.appendChild(thisPageTable);
          document.getElementById("scoreContentDiv").appendChild(pageDiv);
        }
        document.getElementById("recallContentDiv").innerHTML = "";
      }

      for (let i = 0; i < amount; i++) {
        if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + i).value);
        document.getElementById("inpRecall" + i).setAttribute("readonly", "");
      }


      //Go through all dates

      for (var i = 0; i < amount; i++) {
        document.getElementById("inpRecall" + i).classList = [skin + "datesYearRecall"];
        if (chosenAnswers[i] == shuffledDateList[i].year) {
          console.log(i + " - correct");
          correct++;
          totalEval++;
          if (skin.indexOf('analogue') > -1) {
            //does nothing right now
            document.getElementById("inpRecall" + i).classList.add(skin + "correct");
          }
          else {
            //display correct (green) background
            document.getElementById("inpRecall" + i).classList.add(skin + "correct");
          }
        } else {

          //nothing entered, just show correct word
          if (chosenAnswers[i].length == 0) {
            console.log(i + " - not entered");
            if (isAnalogue()) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slash');

              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('dateMarkingSup');
              var answer = document.createTextNode(shuffledDateList[i].year);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("inpRecall" + i).parentNode.appendChild(markingSpan);
            }
            else {
              //document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");		
            }
          }
          else {
            console.log(i + " - incorrect");
            totalEval -= 0.5;
            //add the chosen incorrect answer (with slash if analogue)      
            if (isAnalogue()) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slash');
              var markingSubSpan = document.createElement("sub");
              markingSubSpan.classList.add('dateMarkingSub');
              var x = document.createTextNode("x");
              markingSubSpan.appendChild(x);
              markingSpan.appendChild(markingSubSpan);
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('dateMarkingSup');
              var answer = document.createTextNode(shuffledDateList[i].year); //CHANGED FOR WMC 2023? was dateList
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("inpRecall" + i).parentNode.appendChild(markingSpan);
            }
            else {
              document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");

            }


          }
        }

      }

      totalEval = totalEval > 0 ? totalEval : 0;

      if (!resuming) {
        document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
        document.getElementById("recallContentDiv").innerHTML = "";
      } else {

        document.onkeydown = function (e) {
          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusDatesRecall(datesPerPage * (curPage - 1));
            //if (curPage>0) displayPage(curPage-1);
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusDatesRecall(datesPerPage * (curPage + 1));

          }


        };

      }

      //mouseover handlers here for digital only
      if (skin.indexOf('digital') > -1) {
        for (var m = 0; m < amount; m++) {
          if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
            $("#inpRecall" + m).mouseover(function (ev) {
              showCorrectDate(ev.target.id.match(/\d+/g));
            });
            $("#inpRecall" + m).mouseout(function (ev) {
              showChosenDate(ev.target.id.match(/\d+/g));
            });
          }
        }
      }


      //add chosen answers
      for (let i = 0; i < amount; i++) {
        document.getElementById("inpRecall" + i).value = chosenAnswers[i];
      }

      //show pages
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusDatesRecall(" + datesPerPage * i + ")'>" + (i + 1) + "</a></li>";

        }
        menuString += "</ul><br />";
        document.getElementById("menuScoreDiv").innerHTML = menuString;
        document.getElementById("menuRecallDiv").innerHTML = "";
      } else {
        document.getElementById("menuScoreDiv").innerHTML = "";
      }

      document.getElementById("spanScore").innerHTML = Math.ceil(totalEval);
      scoreInfo = encryptWithAES("Discipline: " + lookupProperty(currentDiscipline, "label") + " // Score: " + totalEval.toString() + " // Timestamp: " + getTimestamp());
      document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

      //display memo time
      if (memoTimeNeeded) displayMemoTimeScore();

      $(".finishBtn").hide();
      document.getElementById("scoreRow").style.display = "block";

      //move to first page
      displayPage(0, true);
    }

    function displayNamesScore() {
      if (resuming) {
        nameList = JSON.parse(localStorage.getItem("nameList"));
        shuffledNameList = JSON.parse(localStorage.getItem("shuffledNameList"));
        amount = localStorage.getItem("amount");
        facesAmount = Math.ceil(amount / 2);
        namesPerPage = namesPerRow * nameRowsPerPage;
        numberOfPages = Math.ceil(facesAmount / namesPerPage);
      } else {
        saveNamesData();
      }

      var totalEval = 0;
      var correct = 0;
      curPage = 0;

      chosenFirstNames = [];
      chosenSurnames = [];

      if (resuming) {
        //get chosen answers into array from storage
        chosenFirstNames = JSON.parse(localStorage.getItem("chosenFirstNames"));
        chosenSurnames = JSON.parse(localStorage.getItem("chosenSurnames"));

        //add the recall content
        for (i = 0; i < numberOfPages; i++) {

          //create a new page that can be hidden or shown
          var pageDiv = document.createElement("div");
          pageDiv.setAttribute("id", "page" + i + "Recall");
          //add table to hold the names
          var thisPageTable = document.createElement("table");
          thisPageTable.setAttribute("class", "nameTable");

          //add rows with cells
          for (j = 0; j < nameRowsPerPage; j++) {
            var faceRow = document.createElement("tr");
            var nameRow = document.createElement("tr");

            for (k = 0; k < namesPerRow; k++) {
              var thisIndex = i * namesPerPage + j * nameRowsPerPage + k;
              if (thisIndex < nameList.length) {
                var faceCell = document.createElement("td");
                faceCell.classList.add("faceMemo");
                var faceImg = document.createElement("img");

                faceImg.setAttribute("src", shuffledNameList[thisIndex].imageURL);

                if (competitionMode && !competitionTestMode) {
                  faceImg.setAttribute("height", "128");
                  faceImg.setAttribute("width", "128");
                } else {
                  faceImg.setAttribute("height", "128");
                  faceImg.setAttribute("width", "101.5");
                }

                var nameCell = document.createElement("td");

                // nameCell.classList.add("nameRecallTD");
                // nameCell.classList.add(skin + "nameRecallTD");

                var nameInputFCell = document.createElement("input");
                nameInputFCell.classList.add("nameRecall");
                nameInputFCell.classList.add(skin + "nameRecall");
                nameInputFCell.setAttribute("id", "inpRecallF" + thisIndex);
                nameInputFCell.thisIndex = thisIndex;
                nameInputFCell.addEventListener("click", function (e) {
                  moveFocusNamesRecall(e.target.thisIndex, true);
                });
                nameInputFCell.addEventListener("dblclick", function (e) {
                  toggleMark(e.target);
                });

                var nameInputSCell = document.createElement("input");
                nameInputSCell.classList.add("nameRecall");
                nameInputSCell.classList.add(skin + "nameRecall");
                nameInputSCell.setAttribute("id", "inpRecallS" + thisIndex);
                nameInputSCell.thisIndex = thisIndex;
                nameInputSCell.addEventListener("click", function (e) {
                  moveFocusNamesRecall(e.target.thisIndex, false);
                });
                nameInputSCell.addEventListener("dblclick", function (e) {
                  toggleMark(e.target);
                });
                faceCell.appendChild(faceImg);
                faceCell.setAttribute("id", "tdFace" + thisIndex);


                nameCell.setAttribute("id", "tdRecall" + thisIndex);

              }

              if (namesCharsetIsRToL()) {
                nameCell.appendChild(nameInputSCell);
                nameCell.appendChild(nameInputFCell);
              } else {
                nameCell.appendChild(nameInputFCell);
                nameCell.appendChild(nameInputSCell);
              }
              nameRow.appendChild(nameCell);
              faceRow.appendChild(faceCell);
            }
            thisPageTable.appendChild(faceRow);
            thisPageTable.appendChild(nameRow);
          }

          pageDiv.appendChild(thisPageTable);

          document.getElementById("scoreContentDiv").appendChild(pageDiv);
        }

      } else {
        //get chosen answers into array from recall boxes
        for (let i = 0; i < facesAmount; i++) {
          chosenFirstNames.push(document.getElementById("inpRecallF" + i).value);
          chosenSurnames.push(document.getElementById("inpRecallS" + i).value);
        }
      }



      //Go through all names

      for (var i = 0; i < facesAmount; i++) {
        document.getElementById("inpRecallF" + i).classList = [skin + "nameRecall"];
        document.getElementById("inpRecallS" + i).classList = [skin + "nameRecall"];
        if (accent_fold(chosenFirstNames[i].toLowerCase().trim()) == accent_fold(shuffledNameList[i].firstname.toLowerCase())) {
          correct++;
          if (skin.indexOf('analogue') > -1) {
            //nothing	
            document.getElementById("inpRecallF" + i).classList.add(skin + "correct");
          }
          else {
            //display correct (green) background
            document.getElementById("inpRecallF" + i).classList.add(skin + "correct");
          }
        } else {
          //nothing entered, just show correct name
          if (chosenFirstNames[i].length == 0) {
            console.log(i + " - first name not entered");
            if (skin.indexOf('analogue') > -1) {
              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slashNames');
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('nameFMarkingSup');
              var answer = document.createTextNode(shuffledNameList[i].firstname);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            }
            else {
              //	document.getElementById("inpRecallF" + i).classList.add(skin + "incorrect");		
            }
          } else {
            console.log(i + " - first name incorrect");
            //add the chosen incorrect answer (with slash if analogue)      
            if (skin.indexOf('analogue') > -1) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slashNames');
              var markingSubSpan = document.createElement("sub");
              markingSubSpan.classList.add('nameFMarkingSub');
              var x = document.createTextNode("x");
              markingSubSpan.appendChild(x);
              markingSpan.appendChild(markingSubSpan);
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('nameFMarkingSup');
              var answer = document.createTextNode(shuffledNameList[i].firstname);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            } else {
              document.getElementById("inpRecallF" + i).classList.add(skin + "incorrect");
            }
          }
        }

        if (accent_fold(chosenSurnames[i].toLowerCase().trim()) == accent_fold(shuffledNameList[i].surname.toLowerCase())) {
          console.log(i + " - correct");
          correct++;
          if (skin.indexOf('analogue') > -1) {
            //does nothing right now
            document.getElementById("inpRecallS" + i).classList.add(skin + "correct");
          }
          else {
            //display correct (green) background
            document.getElementById("inpRecallS" + i).classList.add(skin + "correct");
          }
        } else {
          //nothing entered, just show correct name
          if (chosenSurnames[i].length == 0) {
            console.log(i + " - surname not entered");
            if (skin.indexOf('analogue') > -1) {
              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slashNames');
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('nameSMarkingSup');
              var answer = document.createTextNode(shuffledNameList[i].surname);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            } else {
              //	document.getElementById("inpRecallS" + i).classList.add(skin + "incorrect");		
            }
          } else {
            console.log(i + " - surname incorrect");
            //add the chosen incorrect answer (with slash if analogue)      
            if (skin.indexOf('analogue') > -1) {
              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slashNames');
              var markingSubSpan = document.createElement("sub");
              markingSubSpan.classList.add('nameSMarkingSub');
              var x = document.createTextNode("x");
              markingSubSpan.appendChild(x);
              markingSpan.appendChild(markingSubSpan);
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('nameSMarkingSup');
              var answer = document.createTextNode(shuffledNameList[i].surname);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            } else {
              document.getElementById("inpRecallS" + i).classList.add(skin + "incorrect");
            }
          }
        }
      }

      totalEval = correct;

      //adjust total eval here according to anti-guessing rules
      //From the third name on, there is a penalty of -0.5 for each. 	
      var allNames = (chosenSurnames.concat(chosenFirstNames)).filter(v => v !== "");

      while (allNames.length > 0) {

        var curLength = allNames.length;
        allNames = allNames.filter(function (v) {return v !== allNames[0];});
        var occurrences = curLength - allNames.length;
        if (occurrences > 2) {
          totalEval -= 0.5 * (occurrences - 2);
        }

      }

      if (totalEval < 0) totalEval = 0;


      if (!resuming) {
        document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
        document.getElementById("recallContentDiv").innerHTML = "";
      } else {

        document.onkeydown = function (e) {
          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusNamesRecall(namesPerPage * (curPage - 1));
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusNamesRecall(namesPerPage * (curPage + 1));
          }
        };
      }

      //for all recall boxes, remove selection highlight and set to read only
      for (let i = 0; i < facesAmount; i++) {
        document.getElementById("inpRecallF" + i).classList.remove(skin + "namesSelectedRecall");
        document.getElementById("inpRecallS" + i).classList.remove(skin + "namesSelectedRecall");
        document.getElementById("inpRecallF" + i).setAttribute("readonly", "");
        document.getElementById("inpRecallS" + i).setAttribute("readonly", "");

      }


      //mouseover handlers here for digital only
      if (skin.indexOf('digital') > -1) {
        for (var m = 0; m < facesAmount; m++) {
          if (!(document.getElementById("inpRecallF" + m).classList.contains(skin + "correct"))) {
            $("#inpRecallF" + m).mouseover(function (ev) {
              showCorrectName(ev.target.id.match(/\d+/g), true);
            });
            $("#inpRecallF" + m).mouseout(function (ev) {
              showChosenName(ev.target.id.match(/\d+/g), true);
            });
          }
          if (!(document.getElementById("inpRecallS" + m).classList.contains(skin + "correct"))) {
            $("#inpRecallS" + m).mouseover(function (ev) {
              showCorrectName(ev.target.id.match(/\d+/g), false);
            });
            $("#inpRecallS" + m).mouseout(function (ev) {
              showChosenName(ev.target.id.match(/\d+/g), false);
            });
          }
        }
      }

      //add chosen answers
      for (let i = 0; i < facesAmount; i++) {
        document.getElementById("inpRecallF" + i).value = chosenFirstNames[i];
        document.getElementById("inpRecallS" + i).value = chosenSurnames[i];
      }

      //show pages
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNamesRecall(" + namesPerPage * i + ", true)'>" + (i + 1) + "</a></li>";

        }
        menuString += "</ul><br/>";
        document.getElementById("menuScoreDiv").innerHTML = menuString;
        document.getElementById("menuRecallDiv").innerHTML = "";
      } else {
        document.getElementById("menuScoreDiv").innerHTML = "";
      }

      document.getElementById("spanScore").innerHTML = totalEval;
      scoreInfo = encryptWithAES("Discipline: " + lookupProperty(currentDiscipline, "label") + " // Score: " + totalEval.toString() + " // Timestamp: " + getTimestamp());
      document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

      //display memo time
      if (memoTimeNeeded) displayMemoTimeScore();

      $(".finishBtn").hide();
      document.getElementById("scoreRow").style.display = "block";

      //move to first page
      displayPage(0, true);
    }


    function displayImagesScore() {

      if (resuming) {
        imageArray = JSON.parse(localStorage.getItem("imageArray"));
        answerArray = JSON.parse(localStorage.getItem("answerArray"));
        amount = localStorage.getItem("amount");
        numberOfPages = Math.ceil(amount / imagesPerPage);
      } else {
        saveImagesData();
      }

      var totalEval = 0;
      var correct = 0;
      var correctThisRow = 0;
      var rowFailed = false;
      var somethingEnteredThisRow = false;
      curPage = 0;

      //collect answers into a new array
      chosenAnswers = [];

      if (resuming) {
        chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

        //add the recall content

        var imagesRecallString = "";

        for (i = 0; i < numberOfPages; i++) {
          if (i < numberOfPages - 1) {
            imagesOnThisPage = imagesPerPage;
          }
          else {
            imagesOnThisPage = amount - i * imagesPerPage;
          }

          imagesRecallString += "<div id='page" + i + "Recall'><table class='imageTable' id='recallTable" + i + "'>";


          for (var j = 0; j < imagesOnThisPage; j++) {
            //if we haven't reached the end

            //add row num if needed
            if (j % 5 == 0) {
              imagesRecallString += "<tr><td class='imageRowNumCell'>" + (Math.floor((i * imagesPerPage / 5) + j / 5) + 1) + "</td>";
            }


            //add the next image and a box below it
            //	imagesRecallString += "<td id='tdRecall" + Number(i*imagesPerPage+j) + "'><table><tr><td><img class='imageClass' id='imgRecall" + Number(i*imagesPerPage+j) + "'  src='IAM Images/" + imageArray[i*imagesPerPage+j] + "' height=80></td></tr><tr><td id='inpRecall" + Number(i*imagesPerPage+j) + "'><input type='text'  class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i*imagesPerPage+j) + ")' oninput='checkMoveFocusImagesRecall(" + (i*imagesPerPage+j+1) + ")'></td></tr></table></td>";

            //add image with box before it 
            imagesRecallString += "<td class='" + skin + "imagesRecallTD' id='tdRecall" + Number(i * imagesPerPage + j) + "'><input type='text' id='inpRecall" + Number(i * imagesPerPage + j) + "' class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' oninput='checkMoveFocusImagesRecall(" + (i * imagesPerPage + j + 1) + ")'><img class='imageClass' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' id='imgRecall" + Number(i * imagesPerPage + j) + "'  src='IAM Images/" + imageArray[Math.floor((i * imagesPerPage + j) / 5) * 5 + answerArray[i * imagesPerPage + j] - 1] + "' height=80></td>";


            //close the row if needed and spacer row
            if ((j + 1) % 5 == 0) {
              if (j + 1 == imagesOnThisPage) {
                imagesRecallString += "</tr>";
              } else {
                imagesRecallString += "</tr><tr><td colspan='6' height='20px'></td></tr>";
              }
            }

          }
          imagesRecallString += "</table><br /><button class='btnDigital finishBtn' onclick='confirmFinishRecall();'>Finish</button></div>";
          //	imagesRecallString += "</table><br /></div>";
        }

        imagesRecallString += "</div>";
        document.getElementById("scoreContentDiv").innerHTML = imagesRecallString;

        document.getElementById("recallContentDiv").innerHTML = "";
      }

      //display answers in the boxes
      for (let i = 0; i < amount; i++) {
        if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + i).value);
        document.getElementById("inpRecall" + i).setAttribute("readonly", "");
        document.getElementById("inpRecall" + i).classList.remove(skin + "imagesSelected");
      }


      //Go through all images

      for (var i = 0; i < amount; i++) {
        if (chosenAnswers[i] == answerArray[i]) {
          console.log(i + " - correct");
          correctThisRow++;
          somethingEnteredThisRow = true;
          if (skin.indexOf('analogue') > -1) {
            //does nothing right now
            document.getElementById("inpRecall" + i).classList.add(skin + "correct");
          }
          else {
            //display correct (green) background
            document.getElementById("inpRecall" + i).classList.add(skin + "correct");
          }
        } else {

          //nothing entered, just show correct number
          if (chosenAnswers[i].length == 0) {
            rowFailed = true;
            console.log(i + " - not entered");
            if (skin.indexOf('analogue') > -1) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slash');

              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('imageMarkingSup');
              var answer = document.createTextNode(answerArray[i]);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            }
            else {
              //	document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");		
            }
          }
          else {
            console.log(i + " - incorrect");
            rowFailed = true;
            somethingEnteredThisRow = true;
            //add the chosen incorrect answer to the score row string (with slash if analogue)      
            if (skin.indexOf('analogue') > -1) {

              var markingSpan = document.createElement("span");
              markingSpan.classList.add('slash');
              var markingSubSpan = document.createElement("sub");
              markingSubSpan.classList.add('imageMarkingSub');
              var x = document.createTextNode("x");
              markingSubSpan.appendChild(x);
              markingSpan.appendChild(markingSubSpan);
              var markingSupSpan = document.createElement("sup");
              markingSupSpan.classList.add('imageMarkingSup');
              var answer = document.createTextNode(answerArray[i]);
              markingSupSpan.appendChild(answer);
              markingSpan.appendChild(markingSupSpan);
              document.getElementById("tdRecall" + i).appendChild(markingSpan);
            }
            else {
              document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");

            }


          }
        }
        //after each row, add 5 to total eval if all on row are correct
        if ((i + 1) % 5 == 0) {
          correct += correctThisRow;

          if (correctThisRow == 5) {
            totalEval += 5;
          } else {
            //deduct 1 if row failed unless nothing entered
            if (rowFailed && somethingEnteredThisRow) totalEval--;
          }
          correctThisRow = 0;
          rowFailed = false;
          somethingEnteredThisRow = false;
        }


      }

      //Score cannot be negative
      totalEval = totalEval < 0 ? 0 : totalEval;

      if (!resuming) {
        document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
        document.getElementById("recallContentDiv").innerHTML = "";
      } else {

        document.onkeydown = function (e) {
          //if [ is pressed, previous page
          if (e.key == ',') {
            e.preventDefault();
            if (curPage > 0) moveFocusImagesRecall(imagesPerPage * (curPage - 1));
            //if (curPage>0) displayPage(curPage-1);
          }


          //if ] is pressed, next page
          if (e.key == '.') {
            e.preventDefault();
            if (curPage < numberOfPages - 1) moveFocusImagesRecall(imagesPerPage * (curPage + 1));

          }


        };

      }


      //mouseover handlers here for digital only
      if (skin.indexOf('digital') > -1) {
        for (var m = 0; m < amount; m++) {
          if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
            $("#inpRecall" + m).mouseover(function (ev) {
              showCorrectImage(ev.target.id.match(/\d+/g));
            });
            $("#inpRecall" + m).mouseout(function (ev) {
              showChosenImage(ev.target.id.match(/\d+/g));
            });
          }
        }
      }


      //add chosen answers to score page
      for (let i = 0; i < amount; i++) {
        document.getElementById("inpRecall" + i).value = chosenAnswers[i];
      }

      //show pages
      if (numberOfPages > 1) {

        var menuString = "<ul class='menu'>";

        for (var i = 0; i < numberOfPages; i++) {
          menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusImagesRecall(" + imagesPerPage * i + ")'>" + (i + 1) + "</a></li>";

        }
        menuString += "</ul><br/>";
        document.getElementById("menuScoreDiv").innerHTML = menuString;
        document.getElementById("menuRecallDiv").innerHTML = "";
      } else {
        document.getElementById("menuScoreDiv").innerHTML = "";
      }

      document.getElementById("spanScore").innerHTML = totalEval;
      scoreInfo = encryptWithAES("Discipline: " + lookupProperty(currentDiscipline, "label") + " // Score: " + totalEval.toString() + " // Timestamp: " + getTimestamp());
      document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

      //display memo time
      if (memoTimeNeeded) displayMemoTimeScore();

      $(".finishBtn").hide();
      document.getElementById("scoreRow").style.display = "block";

      moveFocusImagesRecall(0);
    }

    function showChosenImage(num) {
      $("#inpRecall" + num).val(chosenAnswers[num]);
      if (document.getElementById("inpRecall" + num).value.length > 0) {
        document.getElementById("inpRecall" + num).classList.add(skin + "incorrect");
      }
      document.getElementById("inpRecall" + num).classList.remove(skin + "corrected");
    }

    function showCorrectImage(num) {
      $("#inpRecall" + num).val(answerArray[num]);
      document.getElementById("inpRecall" + num).classList.remove(skin + "incorrect");
      document.getElementById("inpRecall" + num).classList.add(skin + "corrected");
    }

    function showChosenWord(num) {
      $("#inpRecall" + num).val(chosenAnswers[num]);
      if (document.getElementById("inpRecall" + num).value.length > 0) {
        document.getElementById("inpRecall" + num).classList.add(skin + "incorrect");
      }
      document.getElementById("inpRecall" + num).classList.remove(skin + "corrected");
    }

    function showCorrectWord(num) {
      $("#inpRecall" + num).val(wordList[num]);
      document.getElementById("inpRecall" + num).classList.remove(skin + "incorrect");
      document.getElementById("inpRecall" + num).classList.add(skin + "corrected");
    }



    function showChosenDate(num) {

      $("#inpRecall" + num).val(chosenAnswers[num]);
      if (document.getElementById("inpRecall" + num).value.length > 0) {
        document.getElementById("inpRecall" + num).classList.add(skin + "incorrect");
      }
      document.getElementById("inpRecall" + num).classList.remove(skin + "corrected");

    }


    function showCorrectDate(num) {
      $("#inpRecall" + num).val(shuffledDateList[num].year);

      document.getElementById("inpRecall" + num).classList.remove(skin + "incorrect");
      document.getElementById("inpRecall" + num).classList.add(skin + "corrected");



    }

    function showChosenName(num, isFirstname) {
      if (isFirstname) {
        $("#inpRecallF" + num).val(chosenFirstNames[num]);
        if (document.getElementById("inpRecallF" + num).value.length > 0) {
          document.getElementById("inpRecallF" + num).classList.add(skin + "incorrect");
        }
        document.getElementById("inpRecallF" + num).classList.remove(skin + "corrected");
      } else {
        $("#inpRecallS" + num).val(chosenSurnames[num]);
        if (document.getElementById("inpRecallS" + num).value.length > 0) {
          document.getElementById("inpRecallS" + num).classList.add(skin + "incorrect");
        }
        document.getElementById("inpRecallS" + num).classList.remove(skin + "corrected");
      }
    }

    function showCorrectName(num, isFirstname) {
      if (isFirstname) {
        $("#inpRecallF" + num).val(shuffledNameList[num].firstname);

        document.getElementById("inpRecallF" + num).classList.remove(skin + "incorrect");
        document.getElementById("inpRecallF" + num).classList.add(skin + "corrected");
      }
      else {
        $("#inpRecallS" + num).val(shuffledNameList[num].surname);
        document.getElementById("inpRecallS" + num).classList.remove(skin + "incorrect");
        document.getElementById("inpRecallS" + num).classList.add(skin + "corrected");
      }

    }



    function timeFormat(t) {
      //only showing minutes and seconds
      ns = (((t) / 1e3)), m = (ns / 60) >> 0, s = Math.floor(ns - m * 60);
      //return m + ":" + ((""+s).length>1?"":"0")+s;
      return (("" + m).length > 1 ? "" : "0") + m + ":" + (("" + s).length > 1 ? "" : "0") + s;
    }

    function timeFormatLong(t) {
      ns = (((t) / 1e3)), m = (ns / 60) >> 0, s = Math.floor(ns - m * 60), hs = Math.floor((ns - (Math.floor(ns))) * 100);
      return m + ":" + (("" + s).length > 1 ? "" : "0") + s + ":" + (("" + hs).length > 1 ? "" : "0") + hs;
    }

    function selectHiColour(colour) {
      hiColour = colour;
      localStorage.setItem("hiColour", hiColour);
      var items = document.getElementsByClassName("highlighterListItem");
      for (var i = 0; i < items.length; i++) {
        items[i].classList.remove("highlighterListItemSelected");
        items[i].classList.remove("noHighlightListItemSelected");
      }
      document.getElementById(colour).classList.add(colour === "transparent" ? "noHighlightListItemSelected" : "highlighterListItemSelected");

      document.body.style.setProperty("--highlightColor", this[hiColour]);
      updatePreview();
    }

    /*
        function changeSelHColour() {
            hiColour = document.getElementById("selHColour").options[document.getElementById("selHColour").selectedIndex].value;
            localStorage.setItem("hiColour", hiColour);
            //document.getElementById("selHColour").style.backgroundColor = document.getElementById("selHColour").options[document.getElementById("selHColour").selectedIndex].value;
            document.getElementById("selHColour").style.backgroundColor = this[hiColour];
    
            //change css variable
            document.body.style.setProperty("--highlightColor", this[hiColour]);
            updatePreview();
    
    
        }*/

    function isAnalogue() {
      return skin.indexOf('analogue') > -1;
    }

    function changeSkin() {
      //skin = document.getElementById("selSkin").options[document.getElementById("selSkin").selectedIndex].value;
      document.body.className = skin;
      document.getElementById("memoBox").className = "col-md-10 jumbotron " + skin + "boxA " + skin + "memoHeight";
      document.getElementById("recallBox").className = "col-md-10 " + skin + "boxB " + skin + "memoHeight";
      document.getElementById("scoreBox").className = "col-md-10 " + skin + "boxB " + skin + "memoHeight";
      //  document.getElementById("preview").className = "centred " + skin + "box";
      document.getElementById("settingsBox").className = "col-md-10 jumbotron settings text-center " + skin + "boxA " + skin + "memoHeight";
      document.getElementById("countdownBox").className = "col-md-10 jumbotron countdown text-center " + skin + "boxB " + skin + "memoHeight";

      var contentBoxes = document.getElementsByClassName("paperContent");
      for (var i = 0; i < contentBoxes.length; i++) {
        //	contentBoxes[i].className = skin + "paperContent paperContent";
        contentBoxes[i].classList.remove("analogue1paperContent");
        contentBoxes[i].classList.remove("digital1paperContent");
        contentBoxes[i].classList.add(skin + "paperContent");
        //contentBoxes[i].classList.add("paperContent");
      }
      //document.getElementById("wrapper").className = skin + "memoHeight";
      //  document.getElementById("memoRow").className = "row " + skin + "container";
      if (skin.indexOf('analogue') > -1) {
        document.getElementById('digital1MemoTimeOuter').style.display = 'none';
        //	document.getElementById('digital1MemoTimeOuter').innerHTML = "";
        document.getElementById('analogue1MemoTimeOuter').style.display = 'block';
        document.getElementById('digital1RecallTimeOuter').style.display = 'none';
        document.getElementById('analogue1RecallTimeOuter').style.display = 'block';
      } else {
        document.getElementById('digital1MemoTimeOuter').style.display = 'inline';
        //	document.getElementById('digital1MemoTimeOuter').innerHTML = "Memorisation time remaining:";
        document.getElementById('analogue1MemoTimeOuter').style.display = 'none';
        document.getElementById('digital1RecallTimeOuter').style.display = 'inline';
        document.getElementById('analogue1RecallTimeOuter').style.display = 'none';
      }
      /*
	
	
      } else {
	
      }
      if (skin.indexOf('analogue')>-1) {
              document.getElementById('digital1ScoreTimeOuter').style.display = 'none';
              document.getElementById('analogue1ScoreTimeOuter').style.display = 'block';
          } else {
              document.getElementById('digital1ScoreTimeOuter').style.display = 'inline';
              document.getElementById('analogue1ScoreTimeOuter').style.display = 'none';
          }
          */
      if (!resuming) updatePreview();

    }


    function displayPage(curPage, isRecall) {
      if (currentDiscipline.indexOf("C") > -1) numberOfPages = amount;

      for (var i = 0; i < numberOfPages; i++) {
        if (i == curPage) {
          document.getElementById("page" + i + (isRecall ? "Recall" : "")).style.display = "block";

          if (numberOfPages > 1) {
            //highlight this page tab
            document.getElementById("page" + i + "tablink" + (isRecall ? "Recall" : "")).className = skin + "pagelinkred";
          }
        }
        else {
          document.getElementById("page" + i + (isRecall ? "Recall" : "")).style.display = "none";
          if (numberOfPages > 1) {
            //un-highlight this page tab
            document.getElementById("page" + i + "tablink" + (isRecall ? "Recall" : "")).className = skin + "pagelink";
          }
        }
      }
    }

    function resumeAttempt() {
      resuming = true;


      //get skin
      skin = getSkin();

      //remove logo row if skin is analogue

      if (skin.indexOf("analogue") > -1) {
        document.getElementById("logoRow").style = "display:none";
        document.getElementById("topMargin").style = "display:block";
        document.getElementById("btnBackToSelection2").style = "display:block";
      }

      //get discipline back
      currentDiscipline = localStorage.getItem("discipline");
      if (!currentDiscipline) {
        alert("No previous attempt found");
        return;
      }
      determineIfPreloadingRequired();


      //if free training, get amount back
      if (freeTraining()) {

        amount = localStorage.getItem("amount" + currentDiscipline);

      }

      var titleElements = document.getElementsByClassName("disciplineTitle");
      var title = lookupProperty(currentDiscipline, "label");
      for (var i = 0; i < titleElements.length; i++) {
        titleElements[i].innerHTML = title;
      }

      titleElements = document.getElementsByClassName("disciplineTitleMemo");
      title = lookupProperty(currentDiscipline, "label");
      for (var i = 0; i < titleElements.length; i++) {
        titleElements[i].innerHTML = title;
      }

      //get phase
      var phase = localStorage.getItem("phase");

      // get mark array
      if (JSON.parse(localStorage.getItem("markArray"))) {
        markArray = JSON.parse(localStorage.getItem("markArray"));
      } else {
        markArray = [];
      }

      //change skin
      changeSkin();

      //get grouping
      grouping = Number(localStorage.getItem("grouping" + currentDiscipline));
      if (currentDiscipline.indexOf("N") > -1) miniGroupings = (localStorage.getItem("miniGroupings") ? JSON.parse(localStorage.getItem("miniGroupings")) : [1]);
      if (!Array.isArray(miniGroupings)) miniGroupings = [miniGroupings];
      groupingH = Number(localStorage.getItem("groupingH"));
      groupingW = Number(localStorage.getItem("groupingW"));
      cardSet = localStorage.getItem("cardSet");
      //use worn set for standard set if analogue skin
      if (cardSet == 1 && skin.indexOf("analogue") > -1) {
        cardSet = 3;
      }

      blnImageSkip = localStorage.getItem("blnImageSkip");

      //get colour back
      hiColour = localStorage.getItem("hiColour");
      document.body.style.setProperty("--highlightColor", this[hiColour]);

      //go to relevant phase
      if (phase == "memo") {
        startMemoCountdown();
      } else if (phase == "recall") {
        startRecallCountdown()
      } else {
        displayScore();
      }
    }

    function resetPreload() {
      if (competitionPreloadingRequired) {
        document.getElementById('btnPreload').removeAttribute('disabled');
        document.getElementById("btnPreload").innerText = "Preload data";
        document.getElementById('btnStartMemoCountdown').innerText = "Start";
        document.getElementById('btnStartMemoCountdown').setAttribute('disabled', '');
        document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
      }
    }

    var freeTraining = () => currentDiscipline.indexOf("T") > -1;

    function handleStartClick() {
      if (currentDiscipline.includes("5N") || currentDiscipline === 'SC') {
        //get trial number
        trialNo = document.getElementById("selTrial").value;

      }

      if (currentDiscipline.indexOf("XC") > -1) {
        recallTime = lookupProperty(currentDiscipline, "recallTime");
        amount = lookupProperty(currentDiscipline, "amount");
        startRecallCountdown();
        return;
      }

      if (currentDiscipline.indexOf("K") > -1) {
        recallTime = amount * 3;
        if (amount > 500) recallTime = 1500;
        //recallTime = lookupProperty(currentDiscipline, "recallTime");
        //amount = lookupProperty(currentDiscipline, "amount");
        setupGroupingsAndLoci();
        startRecallCountdown();
        return;
      }

      if (competitionPreloadingRequired) {
        startMemoCountdown();
      }
      else {

        //save free training settings
        if (currentDiscipline.indexOf("T") > -1) {
          amount = validateAmount(document.getElementById("inpAmount").value);
          localStorage.setItem("amount" + currentDiscipline, amount);
          localStorage.setItem("memoTime" + currentDiscipline, document.getElementById("inpMemoMins").value * 60);
          localStorage.setItem("recallTime" + currentDiscipline, document.getElementById("inpRecallMins").value * 60);

        } else {
          amount = lookupProperty(currentDiscipline, "amount");
        }

        //if we are not doing images,numbers or binary, we preload now
        if (currentDiscipline.indexOf("I") == -1 && currentDiscipline.indexOf("N") == -1 && currentDiscipline.indexOf("B") == -1) {
          document.getElementById('btnStartMemoCountdown').setAttribute('disabled', '');
          document.getElementById("btnStartMemoCountdown").innerText = "Loading images... Please wait";
          document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
          preloadData();
        } else {

          startMemoCountdown();
        }
        //	if (currentDiscipline.indexOf("N")>-1 || currentDiscipline.indexOf("B")>-1 || currentDiscipline.indexOf("C")>-1 || currentDiscipline.indexOf("I")>-1 ) startMemoCountdown();
        //if (currentDiscipline.indexOf("N")>-1 || currentDiscipline.indexOf("B")>-1) startMemoCountdown();
      }
    }

    function applyMiniGroupings() {

      if (currentDiscipline.indexOf("B") > -1) {
        //could add setup stuff for resuming binary recall here but doesn't make too much sense as this is applied in other places
        /*if (!document.getElementById("inpMiniGroupingsBin").value) {
            miniGroupings = [];
            localStorage.setItem("miniGroupings	", JSON.stringify(miniGroupings));
        } else {
            miniGroupings = document.getElementById("inpMiniGroupingsBin").value.split("-");
            localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
 
        }*/
      } else {
        if (resuming) {
          miniGroupings = JSON.parse(localStorage.getItem("miniGroupings"));
          grouping = miniGroupings[0];
        } else {
          if (!document.getElementById("inpMiniGroupings").value) {
            miniGroupings = [];
            localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
          } else {
            //   miniGroupings = document.getElementById("inpMiniGroupings").value.split("-");
            miniGroupings = validateNavGroupingsNum(document.getElementById("inpMiniGroupings").value);
            localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
            //add grouping for now otherwise it breaks
            grouping = miniGroupings[0];
            //	localStorage.setItem("miniGroupings", [grouping]);
          }
        }
      }
      //	document.getElementById("inpImgsPerLocus").value = "";	

      updatePreview();
    }

    function applySeparation() {
      var sepString = getValidSeparationsStringNum(document.getElementById("inpSeparation").value);
      if (sepString) {
        separations = sepString.split("-").map(Number).reduce(function (r, a) {
          r.push((r.length && r[r.length - 1] || 0) + a);
          return r;
        }, []);
        //recurring

        if (miniGroupings.length == 0) {
          miniGroupings = [3];
          document.getElementById("inpMiniGroupings").value = "3";
        }
        locusSize = miniGroupings.reduce((acc, val) => Number(acc) + Number(val));
        if (separations.length == 1) {
          cur = separations[0];
          while (cur + separations[0] < locusSize) {
            separations.push(cur + separations[0]);
            cur += separations[0];
          }
        }
      } else {
        separations = [];
      }
      localStorage.setItem("separations", JSON.stringify(separations));
      updatePreview();
    }

    function getValidNavNumString(str) {
      if (str === '') return '3';

      const numbers = str.split('-').map(part => {
        const num = parseFloat(part);
        return isNaN(num) ? null : num;
      }).filter(num => num !== null);

      if (numbers.length === 0) {
        return '3';
      }

      // Remove zeros from the array
      const filteredNumbers = numbers.filter(num => num !== 0);

      if (filteredNumbers.length === 0) {
        return '3';
      }

      if (filteredNumbers.every(num => num === filteredNumbers[0])) {
        return filteredNumbers[0].toString();
      }

      return filteredNumbers.join('-');
    }


    function getValidNavBinString(str) {
      //*** IDENTICAL TO getValidSeparationBinString
      if (str === '') return '';
      const numbers = str.split('-')
        .filter(str => !isNaN(parseInt(str)))
        .map(str => parseInt(str)); // Split the string by hyphens and convert each part to a number if possible

      if (numbers.every(num => num === numbers[0])) {
        // If all remaining numbers are equal, return a string with just one number
        return numbers[0].toString();
      }

      return numbers.join('-'); // Return the updated version of the input string
    }

    function getValidSeparationBinString(str) {
      if (str === '') return '';
      const numbers = str.split('-')
        .filter(str => !isNaN(parseInt(str)))
        .map(str => parseInt(str)); // Split the string by hyphens and convert each part to a number if possible

      //  let sum = numbers.reduce((total, num) => total + num, 0); // Calculate the initial sum of the numbers

      // while (sum > groupingW) {
      //     const lastNum = numbers.pop(); // Remove the last number from the array
      //     sum -= lastNum; // Update the sum by subtracting the removed number
      //     if (sum === 0) return '';
      // }

      if (numbers.every(num => num === numbers[0])) {
        // If all remaining numbers are equal, return a string with just one number
        return numbers[0].toString();
      }

      return numbers.join('-'); // Return the updated version of the input string

    }

    function validateNavGroupingsBin() {
      const navString = getValidNavBinString(document.getElementById("inpNavGroupingsBin").value);
      if (navString) {
        navGroupingsBin = navString.split('-').map(str => parseInt(str));
      } else {
        navGroupingsBin = [3];
      }
      localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
      document.getElementById("inpNavGroupingsBin").value = navString;

      updatePreview();
    }

    function validateNavGroupingsNum(input) {
      const navString = getValidNavNumString(input);
      if (navString) {
        navGroupingsNum = navString.split('-').map(str => parseInt(str));
      } else {
        navGroupingsNum = [3];
      }
      return navGroupingsNum;
      //  localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
      // document.getElementById("inpNavGroupingsBin").value = navString;

      //updatePreview();
    }

    const validateAmount = (input) => {
      // Trim the input to remove leading/trailing spaces
      input = input.trim();

      // Convert the input to a number
      let amount = parseFloat(input);

      // Check if the input is a valid number
      if (!isNaN(amount)) {
        // Make it positive if it's negative
        if (amount < 0) {
          amount = -amount;
        }

        // If it's 0, make it 20
        if (amount === 0) {
          amount = 20;
        }

        return amount;
      } else {
        // Return a default value (e.g., 0) or handle the invalid input as needed
        return 20;
      }
    }

    const getValidSeparationsStringNum = (input) => {
      // Trim the input to remove leading/trailing spaces
      input = input.trim();

      // Split the string by hyphens
      const elements = input.split('-');

      // Filter out invalid elements (non-integer elements)
      const validElements = elements.filter(element => {
        // Check if the element is a non-empty string and contains only digits
        return /^\d+$/.test(element);
      });

      // Return the corrected string by joining valid elements with hyphens
      return validElements.join('-');
    };


    function applySeparationBin() {
      // groupingW = Number(document.getElementById("selBinGroupingW").options[document.getElementById("selBinGroupingW").selectedIndex].value);

      //SHOULD THIS HAPPEN SOMEWHERE ELSE? JUST DON'T NEED IT HERE THOUGH **
      //    if (!document.getElementById("inpNavGroupingsBin").value) {
      //             navGroupingsBin = [3];
      //             document.getElementById("inpNavGroupingsBin").value = "3" //this happens in applySeparation but doesn't seem to happen in applyMiniGroupings weirdly
      //             localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
      //         } else {
      //             navGroupingsBin = document.getElementById("inpNavGroupingsBin").value.split("-");
      //             localStorage.setItem("navGroupingsBin", JSON.stringify(navGroupingsBin));
      //             //add grouping for now otherwise it breaks
      //             //grouping = miniGroupings[0];
      //             //	localStorage.setItem("miniGroupings", [grouping]);
      //         }

      //     let locusSize = navGroupingsBin.reduce((acc, val) => Number(acc) + Number(val));            

      //validate the separation string to remove those that aren't integers and reduce strings that have equal numbers like 3-3 to 3 
      const sepString = getValidSeparationBinString(document.getElementById("inpSeparationBin").value);

      if (sepString) {
        // separations = document.getElementById("inpSeparationBin").value.split("-").map(Number).reduce(function (r, a) {
        //     r.push((r.length && r[r.length - 1] || 0) + a);
        //     return r;
        // }, []);

        // // if (separations[separations.length - 1] === groupingW) {
        // //     let separationsNew = separations.slice(0, -1);
        // //     separations = separationsNew.slice();
        // // } shouldnt be needed now we have a validate fn

        // //recurring
        // if (separations.length === 1) {
        //     cur = separations[0];
        //     while (cur + separations[0] < locusSize) {
        //         separations.push(cur + separations[0]);
        //         cur += separations[0];
        //     }

        separations = sepString.split('-').map(str => parseInt(str));
      } else {
        separations = [];
      }
      localStorage.setItem("separationsBin", JSON.stringify(separations));
      document.getElementById("inpSeparationBin").value = sepString;
      updatePreview();
    }


    function restoreMarks() {

      if (currentDiscipline.indexOf("C") > -1) {
        for (var i = 0; i < amount; i++) {
          //remove mark by default
          document.getElementById("cardRecall" + i).classList.remove('markCards');

          //add mark if it should be there
          if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("cardRecall" + i));
        }

      } else if (currentDiscipline.indexOf("F") > -1) {
        for (var i = 0; i < amount; i++) {

          //remove mark by default
          if (i % 2 == 0) {
            document.getElementById("inpRecallF" + Math.floor(i / 2)).classList.remove('markOther');
          } else {
            document.getElementById("inpRecallS" + Math.floor(i / 2)).classList.remove('markOther');
          }
          //add mark if it should be there
          if (i % 2 == 0) {
            if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("inpRecallF" + Math.floor(i / 2)));
          } else {
            if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("inpRecallS" + Math.floor(i / 2)));
          }

        }

      } else {
        for (var i = 0; i < amount; i++) {

          //remove mark by default
          document.getElementById("inpRecall" + i).classList.remove('markOther');

          //add mark if it should be there
          if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("inpRecall" + i));
        }
      }
    }

    /*
    function shiftMarksForward() {
        markArray = markArray.map(el => if el+1);
        restoreMarks();
    }
	
    function shiftMarksBackward() {
        markArray = markArray.map(el => el-1);
        restoreMarks();
    }
    */

    function getCaretPosition(oField) {

      // Initialize
      var iCaretPos = 0;

      // IE Support
      if (document.selection) {

        // Set focus on the element
        oField.focus();

        // To get cursor position, get empty selection range
        var oSel = document.selection.createRange();

        // Move selection start to 0 position
        oSel.moveStart('character', -oField.value.length);

        // The caret position is selection length
        iCaretPos = oSel.text.length;
      }

      // Firefox support
      else if (oField.selectionStart || oField.selectionStart == '0')
        iCaretPos = oField.selectionStart;

      // Return results
      return iCaretPos;
    }

    function getTimestamp() {
      return new Date().toUTCString();
    }


    function wordsLanguageIsRToL() {
      return wordsLanguage.includes("Arabic") || wordsLanguage.includes("Hebrew");
    }

    function datesLanguageIsRToL() {
      return datesLanguage.includes("Arabic") || datesLanguage.includes("Hebrew");
    }


    function namesCharsetIsRToL() {
      return namesCharset.includes("Arabic") || namesCharset.includes("Hebrew");
    }

    function toggleMark(el) {

      if (currentDiscipline.indexOf("C") > -1) {
        if (el.classList.contains('markCards')) {
          el.classList.remove('markCards');
          var index = markArray.indexOf(Number(el.id.match(/\d+/g)[0]));
          markArray.splice(index, 1);
        } else {
          el.classList.add('markCards');
          markArray.push(Number(el.id.match(/\d+/g)[0]));
        }

      } else if (currentDiscipline.indexOf("F") > -1) {
        if (el.classList.contains('markOther')) {
          el.classList.remove('markOther');
          var index = markArray.indexOf(Number(el.id.match(/\d+/g)[0]) * 2 + ((el.id.indexOf("F") > -1) ? 0 : 1));

          markArray.splice(index, 1);
        } else {
          el.classList.add('markOther');
          markArray.push(Number(el.id.match(/\d+/g)[0]) * 2 + ((el.id.indexOf("F") > -1) ? 0 : 1));
        }
      } else {
        if (el.classList.contains('markOther')) {
          el.classList.remove('markOther');
          var index = markArray.indexOf(Number(el.id.match(/\d+/g))[0]);
          markArray.splice(index, 1);
        } else {
          el.classList.add('markOther');
          markArray.push(Number(el.id.match(/\d+/g)[0]));
        }
      }

      //save marks
      localStorage.setItem("markArray", JSON.stringify(markArray));


    }

    function getAndStoreSkin() {
      skin = getSkin();
      localStorage.setItem("skin", skin)
    }

    function setPreferredSkinOnStartup() {
      skin = localStorage.getItem("skin") || 'digital1';
      //set appropriate radio button with name selSkin as checked depending on value of skin
      document.querySelector(`input[name="selSkin"][value="${skin}"]`).checked = true;
    }

    function setLastFormatOnStartup() {

      //set appropriate radio button with name selDiscipline as checked depending on value of discipline item from localStorage

      const selectedFormat = localStorage.getItem("format");
      document.querySelector(`select[id="selFormat"]`).value = selectedFormat || 'N';
      //const selectedDiscipline = localStorage.getItem("discipline");
      //document.querySelector(`select[id="selDiscipline"]`).value = selectedDiscipline || '5N';
    }


    document.addEventListener("DOMContentLoaded", function () {
      setPreferredSkinOnStartup();
      setLastFormatOnStartup();
      //   setLastDisciplineOnStartup();
    });


    function submitScore() {
      if (submitScoreOption == "copy") {

        //copy scoreInfo to clipboard
        navigator.clipboard.writeText(scoreInfo);
      } else {
        //e.g. mailto:kjflkjfd@gmail.com?cc=sdfsdf@gmail.com
        window.open('mailto:test@test.com?subject=Score for ' + lookupProperty(currentDiscipline, "label") + '&body=' + scoreInfo + " " + getTimestamp());

      }
    }

    //MOBILE BROWSER CHECK
    var mobilecheck = function () {
      var check = false;
      (function (a) {if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;})(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    };


  </script>

  <title>IAM Training</title>
</head>
<!--<body onLoad="goToSelection()" oncontextmenu="return false" onselectstart="return false" onkeydown="if ((arguments[0] || window.event).ctrlKey && (arguments[0] || window.event).keyCode == 86) return false">-->

<body onLoad="goToSelection()">
  <div class="container-fluid full-height">

    <!--Logo row-->
    <div class="row" id="logoRow" style="display:block">
      <div class="col-md-3"><br /><button id="btnBackToSelection" style="display:none" class="btnDigital"
          onclick="goToSelection();">Back to discipline selection</button></div>
      <div class="col-md-6 text-center"><br /><img src="IAM-main-Logo-transparent-bg-for-web.png"
          height=40><br /><br /><br /></div>
      <div class="col-md-3"><br /><button id="btnSubmitScore" style="display:none" class="btnDigital"
          onclick="submitScore();">SUBMIT SCORE</button></div>
    </div>

    <div class="row" id="topMargin" style="display:none">
      <div class="col-md-3"></div>
      <div class="col-md-6 text-center"></div>
      <div class="col-md-3"></div>
    </div>

    <!--Selection container row-->
    <div class="row" id="selectionRow" style="display:block">
      <div class="col-md-2"></div>
      <div class="col-md-8 jumbotron selection text-center">
        <h4>Select a competition format:</h4>
        <select id="selFormat" onChange="changeDisciplines();">
          <option value="N">National standard</option>
          <option value="I">International standard</option>
          <option value="W">World championship standard</option>
          <option value="T">Free training</option>
        </select>
        <br /><br />
        <h4>Select a discipline:</h4>
        <select id="selDiscipline">
          <option value="5N">5-minute Numbers</option>
          <option value="15N">15-minute Numbers</option>
          <option value="5F">5-minute Names & Faces</option>
          <option value="5W">5-minute Words</option>
          <option value="D">5-minute Dates</option>
          <option value="SC">Speed cards</option>
          <option value="10C">10-minute Cards</option>
          <option value="5I">5-minute Images</option>
          <option value="S">Spoken Numbers</option>
          <option value="5B">5-minute Binary</option>
        </select>

        <br /><br />

        <div class="row">
          <div class="col-md-2"></div>
          <div class="col-md-4">
            <img src="analogueOption.png" class="skinOptionImg" />
            <br /><input type='radio' name='selSkin' value='analogue1' onClick='getAndStoreSkin()'>
            <br />"Analogue" skin
          </div>
          <div class="col-md-4">
            <img src="digitalOption.png" class="skinOptionImg" />
            <br /><input type='radio' name='selSkin' value='digital1' checked onClick='getAndStoreSkin()'>
            <br />"Digital" skin
          </div>
        </div>

        <br /><button id="btnGo" class="btnDigital" disabled onclick="goToSettings();">Loading images... Please
          wait</button>
        <br /><br /><button id="btnResume" class="btnDigital" style="visibility:hidden"
          onclick="resumeAttempt();">Resume previous attempt</button>

        <br /><br />
        <div style="font-size:smaller;">
          Please note: To ensure that you can resume memorisation and recall at any point, this website makes
          use of localStorage. If you have localStorage enabled, a small amount of data relating to your
          memorisation is stored in your browser.

        </div>


      </div>


      <div class="col-md-2"></div>

    </div>

    <!--Settings container row-->
    <div class="row" id="settingsRow0" style="display:none">
      <div class="col-md-1"></div>
      <div id="settingsBox" class="col-md-10 jumbotron settings text-center">
        <div class="paperContent">
          <br />
          <button id="btnBackToSelection2" class="btnDigital" onclick="goToSelection();">Back</button>
          <h3 class="disciplineTitle"></h3>
          <br />
          <br />
          <span style="border:1px dotted;padding:4px;"><b>Important:</b> <span style="font-weight:normal">please press
              <span class="keybutton">F11</span> (Windows) or
              <span class="keycombo">&Hat; + &#8984; + F (Control+Cmd+F)</span> (Mac) for full
              screen.</span> <span style="font-weight:normal">Adjust your browser zoom level if necessary
              (usually <span class="keycombo">Ctrl + +/-</span>)</span></span>

          <div id="divTrial">
            <br />
            <label for="selTrial">Trial no.:</label>
            <select id="selTrial">
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>


          <div id="divFocusBox">
            <br /><label for="chkFocusBox">Large focus box?&nbsp;&nbsp;</label><input type="checkbox" id="chkFocusBox"
              checked>&nbsp;&nbsp;&nbsp;&nbsp;
            <label for="chkHighlightOn">Keep highlight when focus box used?&nbsp;&nbsp;</label><input type="checkbox"
              id="chkHighlightOn" checked>
          </div>

          <div id="divGrouping" class="groupingSettings">

            <br />Grouping: <select id="selGrouping" onchange="updatePreview();">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
            </select>
            <div id="divComplexGrouping">
              <br />

              Grouping for highlight (e.g. 6, 4, or 6-6-6-6-6-6-4): <input size=5 id="inpMiniGroupings"
                onkeyup="applyMiniGroupings()" type="text"
                style="text-align:center">&nbsp;<!--<button class="btn btn-primary" onclick="applyMiniGroupings();">Apply</button>-->
              <br /><br />
              Draw lines every <input size=7 id="inpSeparation" onkeyup="applySeparation()" type="text"
                style="text-align:center">&nbsp;digits (usually the image sizes, e.g. 3 or
              3-2-3)&nbsp;<!--<button class="btn btn-primary" onclick="applySeparation();">Apply</button>-->
            </div>
          </div>
          <div id="divBinGrouping">
            <br />
            <span>
              Width of highlight (e.g. 6, 10, or 9-9-12):
              <input size=5 id="inpNavGroupingsBin" onkeyup="debounce(validateNavGroupingsBin, 1000)">
            </span><span>
              Height of highlight (if using matrices): <select id="selBinGroupingH"
                onchange="resetSeparations();updatePreview();">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
              </select>
              (select 1 for Height if not using matrices)

              <br /><br />
              Draw lines every <input size=7 id="inpSeparationBin" onkeyup="debounce(applySeparationBin, 500)"
                type="text" style="text-align:center">&nbsp;digits (usually the image widths, e.g. 3 or
              3-2-3)&nbsp;<!--<button class="btn btn-primary" onclick="applySeparationBin();">Apply</button>-->
            </span>
          </div>


          <div id="divSkip">
            <br />
            <label for="chkSkipFinalImage">Skip final image in row?</label><input type="checkbox"
              id="chkSkipFinalImage">
          </div>


          <div class="flexParent">

            <div class="flexChild" id="divFree">
              <br /><br />
              <table class="settingsTable">
                <tr>
                  <td id="amountText">Amount: </td>
                  <td><input id="inpAmount" type="text" size=4 onInput="handleImageAmountChange()"> </td>
                </tr>
                <tr>
                  <td>Memo time: </td>
                  <td><input id="inpMemoMins" type="text" size=4> mins</td>
                  <td><input id="inpMemoSecs" type="text" size=2> secs</td>
                </tr>
                <tr>
                  <td>Recall time:</td>
                  <td><input id="inpRecallMins" type="text" size=4> mins</td>
                  <td><input id="inpRecallSecs" type="text" size=2> secs</td>
                </tr>
              </table>
              <br />
            </div>
          </div>



          <div id="divCardSet" class="cardSettings">
            <div id="divDecks" style="flex:1">
              Decks: <input id="inpDecks" type="text" size=3>

            </div>

            <div style="flex:1">
              <label for="selCardSet">Card set:</label>
              <br /> <select id="selCardSet" onchange="resetPreload();updatePreview();">
                <option value="1">Standard</option>
                <option value="2">French (VDR)</option>
                <option value="5">4-colour deck</option>
                <!--	<option value="3">French (BDK)</option>		-->
                <!--	<option value="3">Worn</option>			-->
              </select>
            </div>
            <div style="flex:1" id="divEnd">
              <label id="lblChkDblToEnd" for="chkDblToEnd">End on double click of →:</label> <br /> <input
                type="checkbox" id="chkDblToEnd">
            </div>
            <div style="flex:1">
              <label for="chkLargerGap">Larger gap between cards:</label> <br /><input type="checkbox" id="chkLargerGap"
                onclick="this.checked?cardOffsetBig=42:cardOffsetBig=22;updatePreview();">
            </div>
            <div style="flex:1">
              <label for="chkLeftToRight">Cards from left to right:</label> <br /><input type="checkbox"
                id="chkLeftToRight" onChange="updateLeftToRightSettings()" checked>
            </div>
            <div id="divStartRecallRight" style="flex:1">
              <label for="chkStartRecallRight">Start recall on right:</label> <br /><input type="checkbox"
                id="chkStartRecallRight" checked>
            </div>
          </div>

          <!--
Highlight colour:     <select id="selHColour"  onchange="changeSelHColour()" > 
<option value="red" style="background-color:#ff8080">red</option>
<option value="orange" style="background-color:#ffa366">orange</option>
<option value="yellow" style="background-color:#ffff80">yellow</option>
<option value="green" style="background-color:#b3ff66">green</option>
<option value="sky"  style="background-color:#80bfff" selected>blue</option>
<option value="purple"  style="background-color:#df9fbf">purple</option>
</select>
-->
          <div id="divPreview">
            <br />
            <h4>Preview</h4>
            <div id="preview" class="centred text-center" style="width:100%;">

              <img src='Card images 1/c13.png'>

            </div>
            <div id="cardAttribution"></div>
          </div>
          <div id="divHighlightColour">
            <br />
            <div class="flexContainer" id="HColorList">
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', 'transparent');"
                class="highlighterListItem noHighlightItem" id="transparent">
                (No highlight)
              </div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="red" style="background-color:#ff8080"></div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="orange" style="background-color:#ffa366"></div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="yellow" style="background-color:#ffff80"></div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="green" style="background-color:#b3ff66"></div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="turquoise" style="background-color:#3eb5c8" selected>
              </div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="sky" style="background-color:#96bdf2"></div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="purple" style="background-color:#df9fbf"></div>
              <div class="highlighterListItemBlank"></div>
              <div onclick="selectHiColour(this.id)"
                onmouseover="document.body.style.setProperty('--optionColor', eval(this.id));"
                class="highlighterListItem" id="pink" style="background-color:#f6b8bd"></div>
            </div>
          </div>
          <br />
          <br />
          <div id="divDatesLanguages">
            <br />
            Language: <select id="selDatesLanguage" onchange="resetPreload();">
            </select>
          </div>

          <div id="divWordsLanguages">
            <br />
            Language: <select id="selWordsLanguage" onchange="resetPreload();">
            </select>
          </div>

          <div id="divNamesCharsets">
            <br />
            Character set: <select id="selNamesCharset" onchange="resetPreload();">
              <option value="Arabic">Arabic</option>
              <option value="Japanese">Japanese</option>
              <option value="Latin">Latin</option>
            </select>
            <div id="divFacesFormat">
              <br />
              Face format: <select id="selFacesFormat" onchange="saveFaceFormatPref();">
                <option value="oval">Oval</option>
                <option value="square">Square</option>
              </select>
            </div>
          </div>





          <div id="divInstructions" class="centred text-center">
          </div>
          <div class="flexParent settingsButtons">
            <div class="flexChild"><button class="btnDigital" id="btnPreload"
                onclick="preloadData();this.setAttribute('disabled','')">Preload data</button></div>
            <div class="flexChild"><button class="btnDigital glowButton" id="btnStartMemoCountdown"
                onclick="handleStartClick()">Start</button></div>
            <div class="flexChild"><button class="btnDigital" id="btnTest" onclick="testPage();">Test
                page</button></div>
          </div>
        </div>
        <div class="col-md-1"></div>

      </div>
    </div>

    <!--Countdown container row-->
    <div class="row" id="countdownRow">
      <div class="col-md-1"></div>
      <div id="countdownBox" class="col-md-10 jumbotron countdown text-center">
        <div class="paperContent">
          <h3 class="countdownDisciplineTitle"></h3>
          <!--<table class="countdownTable"><tr><td style="margin:0 auto"><span id="countdownText"></span><span style="width:40px" id="countdownTime"></span></td></tr></table>-->
          <table id="countdownTable">
            <tr>
              <td id="countdownText"></td>
            </tr>
            <tr>
              <td id="countdownTime"></td>
            </tr>
          </table>
          <table id="countdownRecallTable">
            <tr>
              <td><span id="countdownRecallText"></span></td>
            </tr>
            <tr>
              <td><span id="countdownRecallTime"></span></td>
            </tr>
          </table>
          <!--
  <div class="row">
  <div class="col-md-3"></div>
  <div class="col-md-6 text-center">
  <table class="countdownTable"><tr><td><span id="countdownText"></span><span id="countdownTime"></span></td></tr></table>
   </div>
   <div class="col-md-3"></div>
   </div>
-->
        </div>
      </div>
      <div class="col-md-1"></div>
    </div>

    <!--Memo container row-->
    <div class="row" id="memoRow">
      <!--<div class="row topMargin"></div>-->
      <div class="col-md-1"></div>
      <div id="memoBox" class="col-md-10 jumbotron">

        <table class="disciplineHeadingTable">
          <tr>
            <td class="disciplineTitleMemo textNonCards"></td>
            <!--<td><span id="digital1RecallTimeOuter" style="display:none"><span>Recall time remaining: </span></td>-->
            <td id='digital1MemoTimeOuterTd'><span id='digital1MemoTimeOuter'><span>Memorisation time
                  remaining: </span><span id="digital1MemoTimeInner"></span></span></td>
            <td></td>
            <td></td>
          </tr>
        </table>

        <div id="menuDiv"></div>
        <br />

        <div id="wrapper">
          <div id="memoContentDiv" class="memoContent paperContent"></div>
          <div id="analogueCardsMemoContentDiv" class="memoContent"></div>
          <div id="overlayDiv" class="overlay"></div>
          <div style="display:none" id="intermediateDivSR">
            Please wait until all other competitors are ready, and then click Start Recall when advised to
            do so.
            <br /><button id="btnStartRecall" class="btnDigital" onclick="startRecallCountdown();">Start
              Recall</button>
          </div>
          <div style="display:none;font-size:12px;padding-top:20px" id="intermediateDivMemoTime"></div>

        </div>

        <div id="bottomRightTimerDiv" class="bottom-right-timer row">
          <div class='col-md-10'></div>
          <div class='col-md-2' id='analogue1MemoTimeOuter'><span id="analogue1MemoTimeInner"></span></div>
        </div>

        <div class="col-md-1"></div>
      </div>

    </div>
    <!--Recall container row-->

    <div class="row" id="recallRow">
      <!--  <div class="row topMargin"></div>-->
      <div class="col-md-1"></div>
      <div id="recallBox" class="col-md-10">

        <table class="disciplineHeadingTable">
          <tr>
            <td class="disciplineTitleMemo textNonCards"></td>
            <td><span id="cardsMemoTime"></span></td>
            <td id="digital1RecallTimeOuterTd"><span id="digital1RecallTimeOuter" style="display:none"><span>Recall time
                  remaining: </span><span id="digital1RecallTimeInner"></span></span></td>
          </tr>
        </table>
        <div id="menuRecallDiv"></div>
        <div style="display:none" id="intermediateDiv">Your results will be displayed as soon as the recall
          period has finished.</div>

        <div id="recallContentDiv" class="recallContent paperContent"></div>
        <div id="analogueCardsRecallContentDiv" class="recallContent"></div>


        <div class="bottom-right-timer row">
          <br />
          <div class='col-md-8'></div>
          <div class='col-md-2' id="finishBtnDiv"></div>
          <div class='col-md-2' id='analogue1RecallTimeOuter'><span id="analogue1RecallTimeInner"></span>
          </div>
        </div>

        <div class="col-md-1"></div>
      </div>
    </div>

    <!--Score container row-->
    <div class="row full-height" id="scoreRow">

      <!--<div class="row topMargin"></div>-->
      <div class="col-md-1"></div>
      <div id="scoreBox" class="col-md-10">
        <!--<table class="disciplineHeadingTable"><tr><td class="disciplineTitleMemo"></td><td><span>Memorisation time: </span><span id="spanScoreMemoTimeTaken"></span></td><td><span>Recall time: </span><span id="spanScoreRecallTimeTaken"></span></td><td colspan=3><span id="spanOuterScore">Score: </span><span id="spanScore"></span><span id="spanCorrect"></span></td></tr></table>-->
        <table class="disciplineHeadingTable">
          <tr>
            <td class="disciplineTitleMemo textNonCards"></td>
            <td class="scoreTD"><span id="spanOuterScore">Score: </span><span id="spanScore"></span><span
                id="spanCorrect"></span></td>
            <td><span id="cardsMemoTimeScore"></span></td>
          </tr>
        </table>
        <div id="menuScoreDiv"></div>

        <div id="scoreContentDiv" class="scoreContent"></div>
        <div id="analogueCardsScoreContentDiv" class="scoreContent"></div>


        <div id="bottomRow" class="bottom-right-timer row">
          <div class='col-md-10'></div>
          <div class='col-md-2' id='analogue1ScoreTimeOuter'><!--<span id="analogue1ScoreTimeInner"></span>-->
            <div style="display:none" id="intermediateDiv">Your results will be displayed as soon as the
              recall period has finished.</div>

            <button id="btnBackToSelection3" class="btnDigital" onclick="goToSelection();">Back</button>
            <button id="submitScoreAnalogue" class="btnDigital" onclick="submitScore();">Submit
              score</button>
          </div>

        </div>

        <div class="col-md-1"></div>
      </div>

    </div>
    <div id="hiddenDiv">
      <div id="darkenVignette"></div>
    </div>

    <div id="dialog" style="display:none" title="">
      Press Enter to exit test.
    </div>
</body>

</html>
